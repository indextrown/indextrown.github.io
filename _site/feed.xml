<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-05-21T03:44:54+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">DongHyeon Kim’s Blog</title><subtitle>Swift와 크롤링 기술을 통해 안전한 세상을 만들고 싶습니다.</subtitle><author><name>Dong Hyeon</name></author><entry><title type="html">[Baekjoon] 백준 1992 쿼드트리</title><link href="http://localhost:4000/Baekjoon-1992/" rel="alternate" type="text/html" title="[Baekjoon] 백준 1992 쿼드트리" /><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-21T00:00:00+00:00</updated><id>http://localhost:4000/%5BBaekjoon%5D-1992</id><content type="html" xml:base="http://localhost:4000/Baekjoon-1992/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->
<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="문제">문제</h2>
<p><a href="https://www.acmicpc.net/problem/1992">쿼드트리</a></p>

<p><img src="/assets/img/2025-05-21-%5BBaekjoon%5D-1992/image-20250521124353945.png" alt="이미지" width="100%" /><br />
주어진 영상이 0으로만 이루어져 있다면 결과는 0이 되고 혹은 그 반대면 결과가 1이 된다.  <br />
만약 0과 1이 섞여 있으면 전체를 한번에 나타내지 못하고 4개의 영역으로 나누어 각 영역을 압축한 결과를 차례로 괄호 안에서 묶어서 표현한다.</p>

<h2 id="풀이">풀이</h2>
<p>분할 정복 알고리즘을 사용하여 해결할 수 있다.  <br />
분할 정복은 재귀적으로 큰 문제를 하위 문제로 쪼개어 상위 문제를 해결하는 방식이다.  <br />
2차원 배열을 같은 숫자로 구성된 4등분 단위로 압축 및 재귀적츠로 처리하여 괄호로 묶는다. Stack으로도 구현 가능하다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
┌───┬───┐
│ 1 │ 2 │
├───┼───┤
│ 3 │ 4 │
└───┴───┘
*/</span>
<span class="k">let</span> <span class="nv">n</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="nf">readLine</span><span class="p">()</span><span class="o">!</span><span class="p">)</span><span class="o">!</span>
<span class="k">var</span> <span class="nv">graph</span><span class="p">:</span> <span class="p">[[</span><span class="kt">String</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">n</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">row</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span><span class="o">!.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">graph</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 분할정복 함수 - (y, x) 위치에서 size 크기의 정사각형 영역 처리</span>
<span class="kd">func</span> <span class="nf">go</span><span class="p">(</span><span class="n">_</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">base</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">ret</span> <span class="o">=</span> <span class="s">""</span>

    <span class="k">for</span> <span class="n">row</span> <span class="k">in</span> <span class="n">y</span><span class="o">..&lt;</span><span class="n">y</span><span class="o">+</span><span class="n">size</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">col</span> <span class="k">in</span> <span class="n">x</span><span class="o">..&lt;</span><span class="n">x</span><span class="o">+</span><span class="n">size</span> <span class="p">{</span>
            <span class="c1">// 입력 조건이 2^k 이므로 0이하로 들어올 가능성이 없기 때문에 기저 사례 필요 x</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="k">return</span> <span class="n">graph</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="p">}</span>

            <span class="c1">// 하나라도 값이 다르다면 4분할하여 재귀적으로 검사</span>
            <span class="k">if</span> <span class="n">base</span> <span class="o">!=</span> <span class="n">graph</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">"("</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="nf">go</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="nf">go</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">size</span><span class="sr">/2, size/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="nf">go</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">size</span><span class="sr">/2, x, size/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="nf">go</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">size</span><span class="sr">/2, x+size/2, size/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">")"</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 모두 같은 값이면 해당 값 반환</span>
    <span class="k">return</span> <span class="n">base</span>
<span class="p">}</span>

<span class="c1">// (0, 0)부터 분할정복 시작</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">go</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="Baekjoon" /><summary type="html"><![CDATA[문제 쿼드트리 주어진 영상이 0으로만 이루어져 있다면 결과는 0이 되고 혹은 그 반대면 결과가 1이 된다. 만약 0과 1이 섞여 있으면 전체를 한번에 나타내지 못하고 4개의 영역으로 나누어 각 영역을 압축한 결과를 차례로 괄호 안에서 묶어서 표현한다. 풀이 분할 정복 알고리즘을 사용하여 해결할 수 있다. 분할 정복은 재귀적으로 큰 문제를 하위 문제로 쪼개어 상위 문제를 해결하는 방식이다. 2차원 배열을 같은 숫자로 구성된 4등분 단위로 압축 및 재귀적츠로 처리하여 괄호로 묶는다. Stack으로도 구현 가능하다. /* ┌───┬───┐ │ 1 │ 2 │ ├───┼───┤ │ 3 │ 4 │ └───┴───┘ */ let n = Int(readLine()!)! var graph: [[String]] = [] for _ in 0..&lt;n { let row = readLine()!.map { String($0) } graph.append(row) } // 분할정복 함수 - (y, x) 위치에서 size 크기의 정사각형 영역 처리 func go(_ y: Int, _ x: Int, _ size: Int) -&gt; String { let base = graph[y][x] var ret = "" for row in y..&lt;y+size { for col in x..&lt;x+size { // 입력 조건이 2^k 이므로 0이하로 들어올 가능성이 없기 때문에 기저 사례 필요 x if size == 1 { return graph[y][x] } // 하나라도 값이 다르다면 4분할하여 재귀적으로 검사 if base != graph[row][col] { ret += "(" ret += go(y, x, size/2) ret += go(y, x+size/2, size/2) ret += go(y+size/2, x, size/2) ret += go(y+size/2, x+size/2, size/2) ret += ")" return ret } } } // 모두 같은 값이면 해당 값 반환 return base } // (0, 0)부터 분할정복 시작 print(go(0, 0, n))]]></summary></entry><entry><title type="html">[Docker] code-server</title><link href="http://localhost:4000/Docker-code-server/" rel="alternate" type="text/html" title="[Docker] code-server" /><published>2025-05-19T00:00:00+00:00</published><updated>2025-05-19T00:00:00+00:00</updated><id>http://localhost:4000/%5BDocker%5D-code-server</id><content type="html" xml:base="http://localhost:4000/Docker-code-server/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Dockerfile</span>

FROM ubuntu:latest

<span class="c"># ----- 기본 패키지 설치 -----</span>
RUN apt-get update <span class="o">&amp;&amp;</span> <span class="se">\</span>
    apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\</span>
        curl <span class="nb">sudo </span>python3 python3-pip default-jdk <span class="se">\</span>
        git wget nano locales <span class="se">\</span>
        libpython3.10 libicu-dev libxml2-dev clang <span class="se">\</span>
        unzip gnupg2 libcurl4-openssl-dev pkg-config <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get clean

<span class="c"># ----- 로케일 설정 -----</span>
RUN locale-gen en_US.UTF-8
ENV <span class="nv">LANG</span><span class="o">=</span>en_US.UTF-8
ENV <span class="nv">LANGUAGE</span><span class="o">=</span>en_US:en
ENV <span class="nv">LC_ALL</span><span class="o">=</span>en_US.UTF-8

<span class="c"># ----- ARG로 외부에서 변수 받기 -----</span>
ARG USER
ARG PASSWORD

<span class="c"># ----- 사용자 생성 및 sudo 권한 부여 -----</span>
RUN useradd <span class="nt">-m</span> <span class="k">${</span><span class="nv">USER</span><span class="k">}</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">USER</span><span class="k">}</span><span class="s2">:</span><span class="k">${</span><span class="nv">PASSWORD</span><span class="k">}</span><span class="s2">"</span> | chpasswd <span class="o">&amp;&amp;</span> adduser <span class="k">${</span><span class="nv">USER</span><span class="k">}</span> <span class="nb">sudo</span>

<span class="c"># ----- code-server 설치 및 작업 디렉토리 생성 -----</span>
ENV <span class="nv">WORKINGDIR</span><span class="o">=</span><span class="s2">"/home/</span><span class="k">${</span><span class="nv">USER</span><span class="k">}</span><span class="s2">/vscode"</span>
RUN curl <span class="nt">-fsSL</span> https://code-server.dev/install.sh | sh <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="k">${</span><span class="nv">WORKINGDIR</span><span class="k">}</span> <span class="o">&amp;&amp;</span> <span class="nb">chown</span> <span class="nt">-R</span> <span class="k">${</span><span class="nv">USER</span><span class="k">}</span>:<span class="k">${</span><span class="nv">USER</span><span class="k">}</span> <span class="k">${</span><span class="nv">WORKINGDIR</span><span class="k">}</span>

<span class="c"># ----- 컨테이너 환경변수로도 유지 -----</span>
ENV <span class="nv">PASSWORD</span><span class="o">=</span><span class="k">${</span><span class="nv">PASSWORD</span><span class="k">}</span>
ENV <span class="nv">USER</span><span class="o">=</span><span class="k">${</span><span class="nv">USER</span><span class="k">}</span>

<span class="c"># ----- 사용자 전환 -----</span>
USER <span class="k">${</span><span class="nv">USER</span><span class="k">}</span>
WORKDIR <span class="k">${</span><span class="nv">WORKINGDIR</span><span class="k">}</span>

<span class="c"># ----- VSCode 확장 설치 -----</span>
RUN code-server <span class="nt">--install-extension</span> ms-python.python <span class="o">&amp;&amp;</span> <span class="se">\</span>
    code-server <span class="nt">--install-extension</span> ms-azuretools.vscode-docker <span class="o">&amp;&amp;</span> <span class="se">\</span>
    code-server <span class="nt">--install-extension</span> formulahendry.code-runner

<span class="c"># ----- 포트 오픈 -----</span>
EXPOSE 8080

<span class="c"># ----- code-server 실행 -----</span>
CMD <span class="o">[</span><span class="s2">"code-server"</span>, <span class="s2">"--bind-addr"</span>, <span class="s2">"0.0.0.0:8080"</span>, <span class="s2">"--auth"</span>, <span class="s2">"password"</span>, <span class="s2">"."</span><span class="o">]</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 터미널로 진입</span>
docker <span class="nb">exec</span> <span class="nt">-it</span> vscode-container bash

<span class="c"># 이동</span>
<span class="nb">cd</span> /home/ec2-user/.local/share/code-server/User

nano settings.json

<span class="o">{</span>
  <span class="s2">"code-runner.executorMap"</span>: <span class="o">{</span>
    <span class="s2">"python"</span>: <span class="s2">"python3 -u"</span>,
    <span class="s2">"swift"</span>: <span class="s2">"/home/ec2-user/.local/share/swiftly/bin/swift"</span>
  <span class="o">}</span>,
  <span class="s2">"code-runner.showExecutionMessage"</span>: <span class="nb">false</span>,
  <span class="s2">"code-runner.clearPreviousOutput"</span>: <span class="nb">true</span>
<span class="o">}</span>

<span class="c"># 저장</span>
ctrl + o
enter
ctrl x

<span class="c"># 나가고 재빌드</span>
<span class="nb">exit
</span>docker compose up <span class="nt">-d</span> <span class="nt">--build</span>
</code></pre></div></div>

<h1 id="swift-추가">swift 추가</h1>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 터미널로 진입</span>
docker <span class="nb">exec</span> <span class="nt">-it</span> vscode-container bash
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. 기존 swiftly 완전 삭제</span>
<span class="nb">rm</span> <span class="nt">-rf</span> ~/.local/share/swiftly
<span class="nb">rm</span> <span class="nt">-f</span> ~/swiftly

<span class="c"># 2. 필수 패키지 설치</span>
<span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> clang libicu-dev wget libpython3-dev

<span class="c"># 3. 최신 swiftly 설치</span>
curl <span class="nt">-O</span> <span class="s2">"https://download.swift.org/swiftly/linux/swiftly-</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-m</span><span class="si">)</span><span class="s2">.tar.gz"</span>
<span class="nb">tar </span>zxf <span class="s2">"swiftly-</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-m</span><span class="si">)</span><span class="s2">.tar.gz"</span>
<span class="nb">chmod</span> +x swiftly
./swiftly init <span class="nt">--quiet-shell-followup</span> <span class="nt">--assume-yes</span>

<span class="c"># 4. 환경 변수 적용</span>
<span class="nb">source</span> ~/.local/share/swiftly/env.sh
<span class="nb">echo</span> <span class="s1">'source ~/.local/share/swiftly/env.sh'</span> <span class="o">&gt;&gt;</span> ~/.bashrc

<span class="c"># 5. Swift 6.1.0 설치 (실제 toolchain 다운로드)</span>
~/.local/share/swiftly/bin/swiftly <span class="nb">install </span>6.1.0 <span class="nt">--assume-yes</span> <span class="nt">--verify</span>

<span class="c"># 6. swift 실행 확인</span>
find ~/.local/share/swiftly/toolchains <span class="nt">-name</span> swift <span class="nt">-type</span> f <span class="nt">-executable</span>
swift <span class="nt">--version</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="UIComponent" /><summary type="html"><![CDATA[# Dockerfile FROM ubuntu:latest # ----- 기본 패키지 설치 ----- RUN apt-get update &amp;&amp; \ apt-get install -y \ curl sudo python3 python3-pip default-jdk \ git wget nano locales \ libpython3.10 libicu-dev libxml2-dev clang \ unzip gnupg2 libcurl4-openssl-dev pkg-config \ &amp;&amp; apt-get clean # ----- 로케일 설정 ----- RUN locale-gen en_US.UTF-8 ENV LANG=en_US.UTF-8 ENV LANGUAGE=en_US:en ENV LC_ALL=en_US.UTF-8 # ----- ARG로 외부에서 변수 받기 ----- ARG USER ARG PASSWORD # ----- 사용자 생성 및 sudo 권한 부여 ----- RUN useradd -m ${USER} &amp;&amp; echo "${USER}:${PASSWORD}" | chpasswd &amp;&amp; adduser ${USER} sudo # ----- code-server 설치 및 작업 디렉토리 생성 ----- ENV WORKINGDIR="/home/${USER}/vscode" RUN curl -fsSL https://code-server.dev/install.sh | sh &amp;&amp; \ mkdir -p ${WORKINGDIR} &amp;&amp; chown -R ${USER}:${USER} ${WORKINGDIR} # ----- 컨테이너 환경변수로도 유지 ----- ENV PASSWORD=${PASSWORD} ENV USER=${USER} # ----- 사용자 전환 ----- USER ${USER} WORKDIR ${WORKINGDIR} # ----- VSCode 확장 설치 ----- RUN code-server --install-extension ms-python.python &amp;&amp; \ code-server --install-extension ms-azuretools.vscode-docker &amp;&amp; \ code-server --install-extension formulahendry.code-runner # ----- 포트 오픈 ----- EXPOSE 8080 # ----- code-server 실행 ----- CMD ["code-server", "--bind-addr", "0.0.0.0:8080", "--auth", "password", "."] # 컨테이너 터미널로 진입 docker exec -it vscode-container bash # 이동 cd /home/ec2-user/.local/share/code-server/User nano settings.json { "code-runner.executorMap": { "python": "python3 -u", "swift": "/home/ec2-user/.local/share/swiftly/bin/swift" }, "code-runner.showExecutionMessage": false, "code-runner.clearPreviousOutput": true } # 저장 ctrl + o enter ctrl x # 나가고 재빌드 exit docker compose up -d --build swift 추가 # 컨테이너 터미널로 진입 docker exec -it vscode-container bash # 1. 기존 swiftly 완전 삭제 rm -rf ~/.local/share/swiftly rm -f ~/swiftly # 2. 필수 패키지 설치 sudo apt-get update sudo apt-get install -y clang libicu-dev wget libpython3-dev # 3. 최신 swiftly 설치 curl -O "https://download.swift.org/swiftly/linux/swiftly-$(uname -m).tar.gz" tar zxf "swiftly-$(uname -m).tar.gz" chmod +x swiftly ./swiftly init --quiet-shell-followup --assume-yes # 4. 환경 변수 적용 source ~/.local/share/swiftly/env.sh echo 'source ~/.local/share/swiftly/env.sh' &gt;&gt; ~/.bashrc # 5. Swift 6.1.0 설치 (실제 toolchain 다운로드) ~/.local/share/swiftly/bin/swiftly install 6.1.0 --assume-yes --verify # 6. swift 실행 확인 find ~/.local/share/swiftly/toolchains -name swift -type f -executable swift --version]]></summary></entry><entry><title type="html">[TableView] UITextView vs UITextField</title><link href="http://localhost:4000/UIKit-UItextField-UITextView/" rel="alternate" type="text/html" title="[TableView] UITextView vs UITextField" /><published>2025-05-18T00:00:00+00:00</published><updated>2025-05-18T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-UItextField-UITextView</id><content type="html" xml:base="http://localhost:4000/UIKit-UItextField-UITextView/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="uitextview-uitextfield--차이">UITextView UITextField  차이</h2>
<p>TextField는 placeholder를 사용할 수 있으나 TextView는 안되는것을 알게 되어 두 컴포넌트의 차이에 대해 알아보고자 정리하게 되었다.</p>

<h1 id="uitextview">UITextView</h1>
<p><a href="https://developer.apple.com/documentation/uikit/uitextview/">공식문서</a>를 살펴보면</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A scrollable, multiline text region
</code></pre></div></div>
<p><strong>1줄 이상으로 이루어진 스크롤 가능한 텍스트 영역</strong>  <br />
placeholder는 제공하지 않기 때문에 직접 구현해야 한다.</p>

<h2 id="placeholder-구현-방법">placeholder 구현 방법</h2>
<p>UITextView는 UITextViewDeleagate 프로토콜을 채택하고 있다. <br />
그 중 textViewDidBeginEditing method를 사용해서 구현해보자.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// init 시 상태를 lazy로 지정</span>
<span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">textView</span><span class="p">:</span> <span class="kt">UITextView</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">tv</span> <span class="o">=</span> <span class="kt">UITextView</span><span class="p">()</span>
    <span class="n">tv</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"입력하세요.."</span>
    <span class="n">tv</span><span class="o">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">secondaryLabel</span>
    <span class="n">tv</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
    <span class="k">return</span> <span class="n">textView</span>
<span class="p">}()</span>
</code></pre></div></div>
<p>init 시 상태를 lazy로 지정해주면서 layout 세팅을 진행하였다.</p>

<h2 id="textviewdidbeginediting">textViewDidBeginEditing</h2>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tells the delegate when editing of the specified text view begins.
</code></pre></div></div>
<p><strong>Optional 설정으로 textView의 수정이 일어나면 실행되는 메서드</strong></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">UploadViewController</span><span class="p">:</span> <span class="kt">UITextViewDelegate</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">textViewDidBeginEditing</span><span class="p">(</span><span class="n">_</span> <span class="nv">textView</span><span class="p">:</span> <span class="kt">UITextView</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">textView</span><span class="o">.</span><span class="n">textColor</span> <span class="o">==</span> <span class="o">.</span><span class="n">secondaryLabel</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="n">textView</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="kc">nil</span>
        <span class="n">textView</span><span class="o">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">label</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>textColor가 .secondaryLabel라는 기본값으로 세팅되어 있으면 return 시키고, 아니라면 text를 비우고 Color도 검정색으로 바꾸어준다.</p>

<h1 id="uitextfield">UITextField</h1>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="UIComponent" /><summary type="html"><![CDATA[UITextView UITextField 차이 TextField는 placeholder를 사용할 수 있으나 TextView는 안되는것을 알게 되어 두 컴포넌트의 차이에 대해 알아보고자 정리하게 되었다. UITextView 공식문서를 살펴보면 A scrollable, multiline text region 1줄 이상으로 이루어진 스크롤 가능한 텍스트 영역 placeholder는 제공하지 않기 때문에 직접 구현해야 한다. placeholder 구현 방법 UITextView는 UITextViewDeleagate 프로토콜을 채택하고 있다. 그 중 textViewDidBeginEditing method를 사용해서 구현해보자. // init 시 상태를 lazy로 지정 private lazy var textView: UITextView = { let tv = UITextView() tv.text = "입력하세요.." tv.textColor = .secondaryLabel tv.delegate = self return textView }() init 시 상태를 lazy로 지정해주면서 layout 세팅을 진행하였다. textViewDidBeginEditing Tells the delegate when editing of the specified text view begins. Optional 설정으로 textView의 수정이 일어나면 실행되는 메서드 extension UploadViewController: UITextViewDelegate { func textViewDidBeginEditing(_ textView: UITextView) { guard textView.textColor == .secondaryLabel else { return } textView.text = nil textView.textColor = .label } } textColor가 .secondaryLabel라는 기본값으로 세팅되어 있으면 return 시키고, 아니라면 text를 비우고 Color도 검정색으로 바꾸어준다. UITextField]]></summary></entry><entry><title type="html">[TableView] 13. RxTableView</title><link href="http://localhost:4000/UIKit-tableView13/" rel="alternate" type="text/html" title="[TableView] 13. RxTableView" /><published>2025-05-18T00:00:00+00:00</published><updated>2025-05-18T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-tableView13</id><content type="html" xml:base="http://localhost:4000/UIKit-tableView13/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="TableView" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[TableView] 12. 테이블뷰 제네릭 CustomCombineDataSource</title><link href="http://localhost:4000/UIKit-tableView12/" rel="alternate" type="text/html" title="[TableView] 12. 테이블뷰 제네릭 CustomCombineDataSource" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-tableView12</id><content type="html" xml:base="http://localhost:4000/UIKit-tableView12/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="테이블뷰-제네릭-customcombinedatasource">테이블뷰 제네릭 CustomCombineDataSource</h2>
<p>이전 포스팅에서 tableview데이터소스를 combine과 제네릭으로 연결을 했다. <br />
데이터소스는 데이터와 연괸되어있고, 셀의 종류를 정하고, 리스트 개수가 몇개인지 정하는 역할이다 즉 데이터와 관련이 있다.</p>

<p>이전 포스팅에서 커스텀 DataSource를 만들어서 처리하였는데 문제가 있었다. 리스트를 보여줄 때 데이터 타입이 변경되면 받을 수 없고 DummyData타입만 받을 수 있었다. 어떠한 데이터가 오더라도 확장성이 있도록 호출하는 쪽에서 셀의 타입을 정하도록 구현해보자.</p>

<h3 id="customcombinedatasourceswift">CustomCombineDataSource.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">//</span>
 <span class="c1">//  CustomCombineDataSource.swift</span>
 <span class="c1">//  UITableViewTutorial</span>
 <span class="c1">//</span>
 <span class="c1">//  Created by 김동현 on 5/15/25.</span>
 <span class="c1">//</span>
 <span class="c1">// https://www.youtube.com/watch?v=vlJ392OMkoI&amp;list=PLgOlaPUIbynpuq9GKCwAedgWkkPm2Wo8v&amp;index=16</span>
 
 <span class="kd">import</span> <span class="kt">UIKit</span>
 
 <span class="cm">/*
 class CustomCombineDataSource&lt;T, G&gt;: NSObject, UITableViewDataSource {
     
     // 멤버 변수
     var dataList: [T] = []
     
     var testDataList: [G] = []
 */</span>
 
 <span class="kd">class</span> <span class="kt">CustomCombineDataSource</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span> <span class="p">{</span>
     
     <span class="c1">// 셀을 만드는 클로저</span>
     <span class="c1">// 1. let makeCell: (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell</span>
     <span class="c1">// 2. let makeCell: (UITableView, IndexPath, Item) -&gt; UITableViewCell // 위랑 같음</span>
     <span class="c1">// 3.</span>
     <span class="k">var</span> <span class="nv">makeCell</span><span class="p">:</span> <span class="p">((</span><span class="kt">UITableView</span><span class="p">,</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="kt">Item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// 옵셔널로도 가능</span>
     
     <span class="k">var</span> <span class="nv">dataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Item</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
     
     <span class="c1">// 2. 안쪽에서 터트리기 때문에 escaping 해주자</span>
     <span class="cm">/*
     init(makeCell: @escaping (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell) {
         self.makeCell = makeCell
         super.init()
     }
      */</span>
     
     <span class="c1">// 3. 옵셔널로 한다면 escaping 안해도 된다</span>
     <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">makeCell</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">_</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="n">_</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">Item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">self</span><span class="o">.</span><span class="n">makeCell</span> <span class="o">=</span> <span class="n">makeCell</span>
         <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점</span>
 
     <span class="c1">/// 변경된 데이터를 받아서 테이블뷰에 적용한다</span>
     <span class="c1">/// - Parameters:</span>
     <span class="c1">///   - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수</span>
     <span class="c1">///   - tableView: 리로드 대상 테이블뷰</span>
     <span class="kd">func</span> <span class="nf">pushDataList</span><span class="p">(</span><span class="n">_</span> <span class="nv">updatedDataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Item</span><span class="p">],</span> <span class="n">to</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">tableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="k">self</span>
         <span class="k">self</span><span class="o">.</span><span class="n">dataList</span> <span class="o">=</span> <span class="n">updatedDataList</span>
         <span class="n">tableView</span><span class="o">.</span><span class="nf">reloadData</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 </span>
     
     <span class="c1">/// 하나의 섹션에 몇개의 rows가 있냐</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
         <span class="k">return</span> <span class="n">dataList</span><span class="o">.</span><span class="n">count</span>
     <span class="p">}</span>
 
     <span class="c1">/// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라</span>
     <span class="c1">/// - indexPath: 셀의 위치를 나타내는 인덱스 경로</span>
     <span class="c1">/// - returns: 구성된 UITableViewCell 객체</span>
     <span class="c1">/// 어떤 셀을 보여줄지</span>
     <span class="c1">// 1. 테이블뷰</span>
     <span class="c1">// 2. indexPath 몇번째인지</span>
     <span class="c1">// 3. 셀에 대한 데이터 - 셀에 대한 제네릭 데이터</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
         
         <span class="c1">// 비어있으면 기본 UITableViewCell 반환</span>
         <span class="nf">makeCell</span><span class="p">?(</span><span class="n">tableView</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">dataList</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">])</span> <span class="p">??</span> <span class="kt">UITableViewCell</span><span class="p">()</span>
         
         <span class="c1">//        /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)</span>
         <span class="c1">//        /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell")</span>
         <span class="c1">//</span>
         <span class="c1">//        // [guard let] 방식</span>
         <span class="c1">//        guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {</span>
         <span class="c1">//            return UITableViewCell()</span>
         <span class="c1">//        }</span>
         <span class="c1">//</span>
         <span class="c1">//        if let dataList = dataList as? [DummyData] {</span>
         <span class="c1">//            let cellData: DummyData = dataList[indexPath.row]</span>
         <span class="c1">//</span>
         <span class="c1">//            /// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
         <span class="c1">//            cell.titleLabel.text = cellData.title</span>
         <span class="c1">//</span>
         <span class="c1">//            /// 셀의 서브 타이틀 설정</span>
         <span class="c1">//            cell.bodyLabel.text = cellData.body</span>
         <span class="c1">//</span>
         <span class="c1">//            cell.detailTextLabel?.numberOfLines = 0</span>
         <span class="c1">//        }</span>
         <span class="c1">//</span>
         <span class="c1">//        if let dataList = dataList as? [IndexData] {</span>
         <span class="c1">//            let cellData: IndexData = dataList[indexPath.row]</span>
         <span class="c1">//</span>
         <span class="c1">//            /// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
         <span class="c1">//            cell.titleLabel.text = cellData.title</span>
         <span class="c1">//</span>
         <span class="c1">//            /// 셀의 서브 타이틀 설정</span>
         <span class="c1">//            cell.bodyLabel.text = cellData.body</span>
         <span class="c1">//</span>
         <span class="c1">//            cell.detailTextLabel?.numberOfLines = 0</span>
         <span class="c1">//        }</span>
         <span class="c1">//</span>
         <span class="c1">//        return cell</span>
     <span class="p">}</span>
 <span class="p">}</span>
 
 
 
 
 
</code></pre></div></div>

<p>tableView()의 각 매개변수 tableView, indexPath, 그리고 셀에 대한 데이터 cellData을 조합을 하여 UITableViewCell 즉 셀을 만들자. 기존 tableView() 내부를 전부 주석처리를 하고 주석부분을 만드는 클로저를 두자. 함수 = 클로저 = 논리이다.  즉 논리 = 로직이다. 다시말해 로직을 클로저로 빼자.</p>

<h3 id="uitableviewcombineswift">UITableView+Combine.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  UITableView+Combine.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/15/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="c1">// MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자.</span>
<span class="c1">// public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable</span>
<span class="kd">extension</span> <span class="kt">UITableView</span> <span class="p">{</span>
    <span class="c1">// 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체</span>
    <span class="c1">// (Self.Output) -&gt; Void)</span>
    <span class="c1">// ([DummyData]) -&gt; Void</span>
    <span class="c1">// 데이터소스 바인딩    </span>
    <span class="kd">func</span> <span class="n">customItemsWithCell</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nv">makeCell</span><span class="p">:</span> <span class="p">((</span><span class="kt">UITableView</span><span class="p">,</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="kt">Item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">([</span><span class="kt">Item</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">dataSource</span> <span class="o">=</span> <span class="kt">CustomCombineDataSource</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">(</span><span class="n">makeCell</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span> <span class="p">(</span><span class="nv">updatedDateLisst</span><span class="p">:</span> <span class="p">[</span><span class="kt">Item</span><span class="p">])</span> <span class="k">in</span>
            <span class="n">dataSource</span><span class="o">.</span><span class="nf">pushDataList</span><span class="p">(</span><span class="n">updatedDateLisst</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <span class="c1">// 리로드</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="combinelistviewcontrollerswift">CombineListViewController.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  CombineListViewController.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/13/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">CombineListViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="c1">// Combine 메모리 처리를 위해 생성</span>
    <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="c1">// Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다.</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">dummies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">indexDatas</span><span class="p">:</span> <span class="p">[</span><span class="kt">IndexData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="o">!</span>

   
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="nf">configureTableView</span><span class="p">()</span>
        
        
        <span class="cm">/*
        - sink는 @Published가 수정된 스레드에서 실행된다
        - 그래서 Published변수 수정시 메인 스레드에서 수정해주자
        - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다
         */</span>
        
        <span class="c1">// MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다.</span>
        <span class="c1">// $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨</span>
        <span class="c1">// sink는 구독하는 것이다.</span>
        <span class="c1">// AnyCancellable 구독한다고 한다.</span>
        <span class="c1">// store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다.</span>
        <span class="cm">/*
         기존 방식
         $dummies
             .receive(on: DispatchQueue.main)
             // 데이터 변경시마다 동작
             .sink(receiveValue: { (changedDummies: [DummyData]) in
                 print("changedDummies: \(changedDummies.count)")
                 
                 // sink는 메인스레드에서 동작해서 Dispatch안해도된다
                 self.myTableView.reloadData()
             })
             .store(in: &amp;subscriptions)
         */</span>
        
        <span class="n">$dummies</span><span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">customItemsWithCell</span><span class="p">(</span>
                <span class="c1">// 셀에 대한 종류를 정해주기 위해 바깥으로 뺀 형태 -&gt; makeCell을 데이터 타입마다 다르게 정의할 수 있다</span>
                <span class="nv">makeCell</span><span class="p">:</span> <span class="p">{</span> <span class="n">myTableView</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">cellData</span> <span class="k">in</span>
                
                <span class="c1">// [guard let] 방식</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">myTableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">CodeCell</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()</span>
                <span class="p">}</span>
        
                <span class="n">cell</span><span class="o">.</span><span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">title</span>  <span class="c1">// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">bodyLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">body</span> <span class="c1">// 셀의 서브 타이틀 설정</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">detailTextLabel</span><span class="p">?</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="n">cell</span>
                
            <span class="p">}))</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        
        <span class="c1">// 2초 뒤에 더미데이터 10개 추가</span>
        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="nf">asyncAfter</span><span class="p">(</span><span class="nv">deadline</span><span class="p">:</span> <span class="o">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">execute</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="n">dummies</span> <span class="o">+=</span> <span class="kt">DummyData</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="c1">// self.indexDatas += IndexData.getDumies(10)</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="kd">fileprivate</span> <span class="kd">func</span> <span class="nf">configureTableView</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="c1">// CodeCell에서는 이 줄만 필요</span>
        <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">CodeCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span>
        <span class="c1">// self.myTableView.delegate = self</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="TableView" /><summary type="html"><![CDATA[테이블뷰 제네릭 CustomCombineDataSource 이전 포스팅에서 tableview데이터소스를 combine과 제네릭으로 연결을 했다. 데이터소스는 데이터와 연괸되어있고, 셀의 종류를 정하고, 리스트 개수가 몇개인지 정하는 역할이다 즉 데이터와 관련이 있다. 이전 포스팅에서 커스텀 DataSource를 만들어서 처리하였는데 문제가 있었다. 리스트를 보여줄 때 데이터 타입이 변경되면 받을 수 없고 DummyData타입만 받을 수 있었다. 어떠한 데이터가 오더라도 확장성이 있도록 호출하는 쪽에서 셀의 타입을 정하도록 구현해보자. CustomCombineDataSource.swift // // CustomCombineDataSource.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // // https://www.youtube.com/watch?v=vlJ392OMkoI&amp;list=PLgOlaPUIbynpuq9GKCwAedgWkkPm2Wo8v&amp;index=16 import UIKit /* class CustomCombineDataSource&lt;T, G&gt;: NSObject, UITableViewDataSource { // 멤버 변수 var dataList: [T] = [] var testDataList: [G] = [] */ class CustomCombineDataSource&lt;Item&gt;: NSObject, UITableViewDataSource { // 셀을 만드는 클로저 // 1. let makeCell: (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell // 2. let makeCell: (UITableView, IndexPath, Item) -&gt; UITableViewCell // 위랑 같음 // 3. var makeCell: ((UITableView, IndexPath, Item) -&gt; UITableViewCell)? = nil // 옵셔널로도 가능 var dataList: [Item] = [] // 2. 안쪽에서 터트리기 때문에 escaping 해주자 /* init(makeCell: @escaping (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell) { self.makeCell = makeCell super.init() } */ // 3. 옵셔널로 한다면 escaping 안해도 된다 init(_ makeCell: ((_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell)? = nil) { self.makeCell = makeCell super.init() } // MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점 /// 변경된 데이터를 받아서 테이블뷰에 적용한다 /// - Parameters: /// - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수 /// - tableView: 리로드 대상 테이블뷰 func pushDataList(_ updatedDataList: [Item], to tableView: UITableView) { tableView.dataSource = self self.dataList = updatedDataList tableView.reloadData() } // MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 /// 하나의 섹션에 몇개의 rows가 있냐 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return dataList.count } /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라 /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 /// - returns: 구성된 UITableViewCell 객체 /// 어떤 셀을 보여줄지 // 1. 테이블뷰 // 2. indexPath 몇번째인지 // 3. 셀에 대한 데이터 - 셀에 대한 제네릭 데이터 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { // 비어있으면 기본 UITableViewCell 반환 makeCell?(tableView, indexPath, dataList[indexPath.row]) ?? UITableViewCell() // /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함) // /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell") // // // [guard let] 방식 // guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else { // return UITableViewCell() // } // // if let dataList = dataList as? [DummyData] { // let cellData: DummyData = dataList[indexPath.row] // // /// 셀의 주 텍스트를 더미 데이터에서 가져오기 // cell.titleLabel.text = cellData.title // // /// 셀의 서브 타이틀 설정 // cell.bodyLabel.text = cellData.body // // cell.detailTextLabel?.numberOfLines = 0 // } // // if let dataList = dataList as? [IndexData] { // let cellData: IndexData = dataList[indexPath.row] // // /// 셀의 주 텍스트를 더미 데이터에서 가져오기 // cell.titleLabel.text = cellData.title // // /// 셀의 서브 타이틀 설정 // cell.bodyLabel.text = cellData.body // // cell.detailTextLabel?.numberOfLines = 0 // } // // return cell } } tableView()의 각 매개변수 tableView, indexPath, 그리고 셀에 대한 데이터 cellData을 조합을 하여 UITableViewCell 즉 셀을 만들자. 기존 tableView() 내부를 전부 주석처리를 하고 주석부분을 만드는 클로저를 두자. 함수 = 클로저 = 논리이다. 즉 논리 = 로직이다. 다시말해 로직을 클로저로 빼자. UITableView+Combine.swift // // UITableView+Combine.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // import UIKit import Combine // MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자. // public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable extension UITableView { // 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체 // (Self.Output) -&gt; Void) // ([DummyData]) -&gt; Void // 데이터소스 바인딩 func customItemsWithCell&lt;Item&gt;( makeCell: ((UITableView, IndexPath, Item) -&gt; UITableViewCell)? = nil ) -&gt; ([Item]) -&gt; Void { let dataSource = CustomCombineDataSource&lt;Item&gt;(makeCell) return { (updatedDateLisst: [Item]) in dataSource.pushDataList(updatedDateLisst, to: self) // 리로드 } } } CombineListViewController.swift // // CombineListViewController.swift // UITableViewTutorial // // Created by 김동현 on 5/13/25. // import UIKit import Combine class CombineListViewController: UIViewController { // Combine 메모리 처리를 위해 생성 var subscriptions = Set&lt;AnyCancellable&gt;() // Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다. @Published var dummies: [DummyData] = [] @Published var indexDatas: [IndexData] = [] @IBOutlet weak var myTableView: UITableView! override func viewDidLoad() { super.viewDidLoad() configureTableView() /* - sink는 @Published가 수정된 스레드에서 실행된다 - 그래서 Published변수 수정시 메인 스레드에서 수정해주자 - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다 */ // MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다. // $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨 // sink는 구독하는 것이다. // AnyCancellable 구독한다고 한다. // store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다. /* 기존 방식 $dummies .receive(on: DispatchQueue.main) // 데이터 변경시마다 동작 .sink(receiveValue: { (changedDummies: [DummyData]) in print("changedDummies: \(changedDummies.count)") // sink는 메인스레드에서 동작해서 Dispatch안해도된다 self.myTableView.reloadData() }) .store(in: &amp;subscriptions) */ $dummies.receive(on: DispatchQueue.main) .sink(receiveValue: self.myTableView.customItemsWithCell( // 셀에 대한 종류를 정해주기 위해 바깥으로 뺀 형태 -&gt; makeCell을 데이터 타입마다 다르게 정의할 수 있다 makeCell: { myTableView, indexPath, cellData in // [guard let] 방식 guard let cell = myTableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else { return UITableViewCell() } cell.titleLabel.text = cellData.title // 셀의 주 텍스트를 더미 데이터에서 가져오기 cell.bodyLabel.text = cellData.body // 셀의 서브 타이틀 설정 cell.detailTextLabel?.numberOfLines = 0 return cell })) .store(in: &amp;subscriptions) // 2초 뒤에 더미데이터 10개 추가 DispatchQueue.global().asyncAfter(deadline: .now() + 2, execute: { self.dummies += DummyData.getDumies(10) // self.indexDatas += IndexData.getDumies(10) }) } fileprivate func configureTableView() { // CodeCell에서는 이 줄만 필요 self.myTableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier) // self.myTableView.delegate = self } }]]></summary></entry><entry><title type="html">[TableView] 10. 테이블뷰 Combine CustomDataSource</title><link href="http://localhost:4000/UIKit-tableView10/" rel="alternate" type="text/html" title="[TableView] 10. 테이블뷰 Combine CustomDataSource" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-tableView10</id><content type="html" xml:base="http://localhost:4000/UIKit-tableView10/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="테이블뷰-콤바인-커스텀-데이터-소스">테이블뷰 콤바인 커스텀 데이터 소스</h2>

<p>지난 시간에 Combine을 통해 List를 보여주었는데 이번 포스트에서는 Combine에서 구독을 통해 들어오는 데이터 바로 DataSource로 연결하는 방법을 해보자. 클로저에 대한 개념을 알아야 이해하기 쉽다.</p>

<h3 id="customcombinedatasourceswift">CustomCombineDataSource.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">//</span>
 <span class="c1">//  CustomCombineDataSource.swift</span>
 <span class="c1">//  UITableViewTutorial</span>
 <span class="c1">//</span>
 <span class="c1">//  Created by 김동현 on 5/15/25.</span>
 <span class="c1">//</span>
 
 <span class="kd">import</span> <span class="kt">UIKit</span>
 
 <span class="kd">class</span> <span class="kt">CustomCombineDataSource</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span> <span class="p">{</span>
     
     <span class="c1">// 멤버 변수</span>
     <span class="k">var</span> <span class="nv">dataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
     
     <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점</span>
 
     <span class="c1">/// 변경된 데이터를 받아서 테이블뷰에 적용한다</span>
     <span class="c1">/// - Parameters:</span>
     <span class="c1">///   - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수</span>
     <span class="c1">///   - tableView: 리로드 대상 테이블뷰</span>
     <span class="kd">func</span> <span class="nf">pushDataList</span><span class="p">(</span><span class="n">_</span> <span class="nv">updatedDataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">],</span> <span class="n">to</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">tableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="k">self</span>
         <span class="k">self</span><span class="o">.</span><span class="n">dataList</span> <span class="o">=</span> <span class="n">updatedDataList</span>
         <span class="n">tableView</span><span class="o">.</span><span class="nf">reloadData</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 </span>
     
     <span class="c1">/// 하나의 섹션에 몇개의 rows가 있냐</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
         <span class="k">return</span> <span class="n">dataList</span><span class="o">.</span><span class="n">count</span>
     <span class="p">}</span>
 
     <span class="c1">/// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라</span>
     <span class="c1">/// - indexPath: 셀의 위치를 나타내는 인덱스 경로</span>
     <span class="c1">/// - returns: 구성된 UITableViewCell 객체</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
         <span class="c1">/// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)</span>
         <span class="c1">/// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell")</span>
 
         <span class="c1">// [guard let] 방식</span>
         <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">CodeCell</span> <span class="k">else</span> <span class="p">{</span>
             <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()</span>
         <span class="p">}</span>
 
         <span class="k">let</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">DummyData</span> <span class="o">=</span> <span class="n">dataList</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>
 
         <span class="c1">/// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
         <span class="n">cell</span><span class="o">.</span><span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">title</span>
 
         <span class="c1">/// 셀의 서브 타이틀 설정</span>
         <span class="n">cell</span><span class="o">.</span><span class="n">bodyLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">body</span>
 
         <span class="n">cell</span><span class="o">.</span><span class="n">detailTextLabel</span><span class="p">?</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="k">return</span> <span class="n">cell</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>커스텀 데이터소스를 만든다. 멤버변수로 데이터리스트를 보유하도록 하자. 지금은 DummyData이지만 다음 포스팅에서 제네릭으로 변경할 예정이다.  DataSource에서 변경이 된 데이터와 테이블뷰 리로드를 위한 테이블뷰 접근을 관리하기 위해 pushDataList()를 만들어주자. 그리고 기존 ViewController에서 관리하던 UITableViewDataSource 관련 프로토콜 로직을 CustomCombineDataSource로 그대로 옮겨준다.  왜냐하면 원래 dataSource의 주요 역할이 어떤 셀의 종류를 보여줄지, 리스트 개수가 몇개일지를 관여하기 때문이다. 즉 기존 ViewController의 비즈니스 로직을 CustomDataSource로 옮긴 것이다. 이제 CustomDataSource를 만들었으니 적용하기 위해 클로저를 만들어주자.</p>

<h3 id="uitableviewcombineswift">UITableView+Combine.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  UITableView+Combine.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/15/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="c1">// MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자.</span>
<span class="c1">// public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable</span>
<span class="kd">extension</span> <span class="kt">UITableView</span> <span class="p">{</span>
    <span class="c1">// 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체</span>
    <span class="c1">// (Self.Output) -&gt; Void)</span>
    <span class="c1">// ([DummyData]) -&gt; Void</span>
    <span class="c1">// 데이터소스 바인딩</span>
    <span class="kd">func</span> <span class="nf">customItems</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">([</span><span class="kt">DummyData</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">dataSource</span> <span class="o">=</span> <span class="kt">CustomCombineDataSource</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span> <span class="p">(</span><span class="nv">updatedDateLisst</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">])</span> <span class="k">in</span>
            <span class="n">dataSource</span><span class="o">.</span><span class="nf">pushDataList</span><span class="p">(</span><span class="n">updatedDateLisst</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <span class="c1">// 리로드</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>기존 ViewController에서 sink로 받는 것을 보면 제네릭 형태인데 Sink로 이벤트(Publisker)가 들어온 데이터를 매개변수로 가지고 반환이 없는 형태의 클로저이다. (Self.Output) -&gt; Void)</p>

<p>이 (Self.Output) -&gt; Void) 형태로 반환을 만족하는 함수를 만들어주자. 지금은 들어오는 형태가 [DummyData] 이므로 func customItems() -&gt; ([DummyData]) -&gt; Void로 해주면 된다.</p>

<p>SInk를 통해 들어오는게 [DummyData]로 들어오게 되고 return { input in } 에 input 부분으로 들어오게 된다.<br />
그럼 pushDataList를 통해 변경이 된 이벤트를 나자신에게 넣어준다.</p>

<h3 id="combinelistviewcontrollerswift">CombineListViewController.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  CombineListViewController.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/13/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">CombineListViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="c1">// Combine 메모리 처리를 위해 생성</span>
    <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="c1">// Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다.</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">dummies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="o">!</span>

   
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="nf">configureTableView</span><span class="p">()</span>
        
        
        <span class="cm">/*
        - sink는 @Published가 수정된 스레드에서 실행된다
        - 그래서 Published변수 수정시 메인 스레드에서 수정해주자
        - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다
         */</span>
        
        <span class="c1">// MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다.</span>
        <span class="c1">// $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨</span>
        <span class="c1">// sink는 구독하는 것이다.</span>
        <span class="c1">// AnyCancellable 구독한다고 한다.</span>
        <span class="c1">// store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다.</span>
        <span class="n">$dummies</span>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">customItems</span><span class="p">())</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        <span class="cm">/*
         기존 방식
         $dummies
             .receive(on: DispatchQueue.main)
             // 데이터 변경시마다 동작
             .sink(receiveValue: { (changedDummies: [DummyData]) in
                 print("changedDummies: \(changedDummies.count)")
                 
                 // sink는 메인스레드에서 동작해서 Dispatch안해도된다
                 self.myTableView.reloadData()
             })
             .store(in: &amp;subscriptions)
         */</span>
        
        <span class="c1">// 2초 뒤에 더미데이터 10개 추가</span>
        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="nf">asyncAfter</span><span class="p">(</span><span class="nv">deadline</span><span class="p">:</span> <span class="o">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">execute</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="n">dummies</span> <span class="o">+=</span> <span class="kt">DummyData</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="kd">fileprivate</span> <span class="kd">func</span> <span class="nf">configureTableView</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="c1">// CodeCell에서는 이 줄만 필요</span>
        <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">CodeCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span>
        <span class="c1">// self.myTableView.delegate = self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>결국 Combine 데이터 변경되었을 때 즉 Publisher가 들어올 때 바로 tableview의 dataSource도 설정하고, 바로 데이터를 꽂아줄 수 있다. 하지만 지금 customItems() 형태가 DummyData로 고정되어있기 때문에 서버에서 받을 수 있는 여러 타입을 모두 반영하기 위해 제네릭으로 변환하는 포스팅을 작성할 예정이다.</p>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="TableView" /><summary type="html"><![CDATA[테이블뷰 콤바인 커스텀 데이터 소스 지난 시간에 Combine을 통해 List를 보여주었는데 이번 포스트에서는 Combine에서 구독을 통해 들어오는 데이터 바로 DataSource로 연결하는 방법을 해보자. 클로저에 대한 개념을 알아야 이해하기 쉽다. CustomCombineDataSource.swift // // CustomCombineDataSource.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // import UIKit class CustomCombineDataSource: NSObject, UITableViewDataSource { // 멤버 변수 var dataList: [DummyData] = [] override init() { super.init() } // MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점 /// 변경된 데이터를 받아서 테이블뷰에 적용한다 /// - Parameters: /// - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수 /// - tableView: 리로드 대상 테이블뷰 func pushDataList(_ updatedDataList: [DummyData], to tableView: UITableView) { tableView.dataSource = self self.dataList = updatedDataList tableView.reloadData() } // MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 /// 하나의 섹션에 몇개의 rows가 있냐 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return dataList.count } /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라 /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 /// - returns: 구성된 UITableViewCell 객체 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함) /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell") // [guard let] 방식 guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else { return UITableViewCell() } let cellData: DummyData = dataList[indexPath.row] /// 셀의 주 텍스트를 더미 데이터에서 가져오기 cell.titleLabel.text = cellData.title /// 셀의 서브 타이틀 설정 cell.bodyLabel.text = cellData.body cell.detailTextLabel?.numberOfLines = 0 return cell } } 커스텀 데이터소스를 만든다. 멤버변수로 데이터리스트를 보유하도록 하자. 지금은 DummyData이지만 다음 포스팅에서 제네릭으로 변경할 예정이다. DataSource에서 변경이 된 데이터와 테이블뷰 리로드를 위한 테이블뷰 접근을 관리하기 위해 pushDataList()를 만들어주자. 그리고 기존 ViewController에서 관리하던 UITableViewDataSource 관련 프로토콜 로직을 CustomCombineDataSource로 그대로 옮겨준다. 왜냐하면 원래 dataSource의 주요 역할이 어떤 셀의 종류를 보여줄지, 리스트 개수가 몇개일지를 관여하기 때문이다. 즉 기존 ViewController의 비즈니스 로직을 CustomDataSource로 옮긴 것이다. 이제 CustomDataSource를 만들었으니 적용하기 위해 클로저를 만들어주자. UITableView+Combine.swift // // UITableView+Combine.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // import UIKit import Combine // MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자. // public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable extension UITableView { // 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체 // (Self.Output) -&gt; Void) // ([DummyData]) -&gt; Void // 데이터소스 바인딩 func customItems() -&gt; ([DummyData]) -&gt; Void { let dataSource = CustomCombineDataSource() return { (updatedDateLisst: [DummyData]) in dataSource.pushDataList(updatedDateLisst, to: self) // 리로드 } } } 기존 ViewController에서 sink로 받는 것을 보면 제네릭 형태인데 Sink로 이벤트(Publisker)가 들어온 데이터를 매개변수로 가지고 반환이 없는 형태의 클로저이다. (Self.Output) -&gt; Void) 이 (Self.Output) -&gt; Void) 형태로 반환을 만족하는 함수를 만들어주자. 지금은 들어오는 형태가 [DummyData] 이므로 func customItems() -&gt; ([DummyData]) -&gt; Void로 해주면 된다. SInk를 통해 들어오는게 [DummyData]로 들어오게 되고 return { input in } 에 input 부분으로 들어오게 된다. 그럼 pushDataList를 통해 변경이 된 이벤트를 나자신에게 넣어준다. CombineListViewController.swift // // CombineListViewController.swift // UITableViewTutorial // // Created by 김동현 on 5/13/25. // import UIKit import Combine class CombineListViewController: UIViewController { // Combine 메모리 처리를 위해 생성 var subscriptions = Set&lt;AnyCancellable&gt;() // Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다. @Published var dummies: [DummyData] = [] @IBOutlet weak var myTableView: UITableView! override func viewDidLoad() { super.viewDidLoad() configureTableView() /* - sink는 @Published가 수정된 스레드에서 실행된다 - 그래서 Published변수 수정시 메인 스레드에서 수정해주자 - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다 */ // MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다. // $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨 // sink는 구독하는 것이다. // AnyCancellable 구독한다고 한다. // store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다. $dummies .receive(on: DispatchQueue.main) .sink(receiveValue: self.myTableView.customItems()) .store(in: &amp;subscriptions) /* 기존 방식 $dummies .receive(on: DispatchQueue.main) // 데이터 변경시마다 동작 .sink(receiveValue: { (changedDummies: [DummyData]) in print("changedDummies: \(changedDummies.count)") // sink는 메인스레드에서 동작해서 Dispatch안해도된다 self.myTableView.reloadData() }) .store(in: &amp;subscriptions) */ // 2초 뒤에 더미데이터 10개 추가 DispatchQueue.global().asyncAfter(deadline: .now() + 2, execute: { self.dummies += DummyData.getDumies(10) }) } fileprivate func configureTableView() { // CodeCell에서는 이 줄만 필요 self.myTableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier) // self.myTableView.delegate = self } } 결국 Combine 데이터 변경되었을 때 즉 Publisher가 들어올 때 바로 tableview의 dataSource도 설정하고, 바로 데이터를 꽂아줄 수 있다. 하지만 지금 customItems() 형태가 DummyData로 고정되어있기 때문에 서버에서 받을 수 있는 여러 타입을 모두 반영하기 위해 제네릭으로 변환하는 포스팅을 작성할 예정이다.]]></summary></entry><entry><title type="html">[Swift] Closure</title><link href="http://localhost:4000/Swift-closure/" rel="alternate" type="text/html" title="[Swift] Closure" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>http://localhost:4000/%5BSwift%5D-closure</id><content type="html" xml:base="http://localhost:4000/Swift-closure/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="클로저">클로저</h2>

<p>클로저 표현식</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">{(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">returnType</span> <span class="k">in</span>
    <span class="n">실행구문</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>클로저 종류</p>
<ul>
  <li>Named Closure = 함수</li>
  <li>Unnamed Closure</li>
</ul>

<h2 id="클로저는-argument-label을-사용하지-않는다"><strong>클로저는 Argument Label을 사용하지 않는다.</strong></h2>

<ul>
  <li>클로저는 둘다 포함하지만 보통 Unnamed Closure를 말한다.</li>
  <li>클로저도 익명이긴 하지만 함수이기 때문에, 함수형 프로그래밍이 가능하다.</li>
  <li>Swift의 함수와 클로저는 <strong>1급 객체(First-Class Citizen)</strong>로 동작한다.</li>
</ul>

<p>1급 객체</p>
<ul>
  <li>프로그래밍 언어에서 값처럼 다룰 수 있는 객체를 의미한다.</li>
  <li>1등 시민처럼, 많은 권한을 부여 받은 것</li>
</ul>

<p>권한</p>
<ul>
  <li>변수 또는 상수에 <code class="language-plaintext highlighter-rouge">함수/클로저</code>를 담을 수 있다.</li>
  <li>인자(파라미터)로 <code class="language-plaintext highlighter-rouge">함수/클로저</code>를 전달할 수 있다.</li>
  <li>반환값(리턴벨류)으로 <code class="language-plaintext highlighter-rouge">함수/클로저</code>를 전달할 수 있다.</li>
</ul>

<p>클로저와 함수 차이</p>
<ul>
  <li>클로저는 상위 스코프 변수 캡처 가능</li>
  <li>함수는 캡처 기본 제공 x</li>
</ul>

<p>용도</p>
<ul>
  <li>클로저 - 일회성 로직 전달(ex. 콜백)</li>
  <li>함수 - 명시적 로직 분리</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">closuredoSomething</span> <span class="o">=</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span> <span class="p">}</span>



<span class="kd">func</span> <span class="nf">doSomething2</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"hello world </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">closuredoSomething2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"hello world </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">closuredoSomething22</span><span class="p">:</span> <span class="p">(</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doSomething3</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">name</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">closuredoSomethihg3</span><span class="p">:</span> <span class="p">(</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doSomething4</span><span class="p">(</span><span class="nv">closure</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="p">{</span>
    <span class="nf">closure</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">closuredoSomethihg4</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"test"</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">Main</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// doSomething()</span>
        <span class="c1">// closuredoSomething()</span>
        <span class="nf">doSomething2</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"인덱스"</span><span class="p">)</span>
        <span class="nf">closuredoSomething2</span><span class="p">(</span><span class="s">"인덱스2"</span><span class="p">)</span>
        
        <span class="nf">doSomething4</span><span class="p">(</span><span class="nv">closure</span><span class="p">:</span> <span class="n">closuredoSomethihg4</span><span class="p">)</span>
        
        <span class="c1">// MARK: - 마지막 매개변수가 클로저이면 후행 클로저를 사용할 수 있다.</span>
        <span class="n">doSomething4</span> <span class="p">{</span>
            <span class="nf">closuredoSomethihg4</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>## reference</p>

<p>- https://babbab2.tistory.com/81</p>]]></content><author><name>Dong Hyeon</name></author><category term="Swift" /><summary type="html"><![CDATA[클로저 클로저 표현식 {(parameters) -&gt; returnType in 실행구문 } 클로저 종류 Named Closure = 함수 Unnamed Closure 클로저는 Argument Label을 사용하지 않는다. 클로저는 둘다 포함하지만 보통 Unnamed Closure를 말한다. 클로저도 익명이긴 하지만 함수이기 때문에, 함수형 프로그래밍이 가능하다. Swift의 함수와 클로저는 1급 객체(First-Class Citizen)로 동작한다. 1급 객체 프로그래밍 언어에서 값처럼 다룰 수 있는 객체를 의미한다. 1등 시민처럼, 많은 권한을 부여 받은 것 권한 변수 또는 상수에 함수/클로저를 담을 수 있다. 인자(파라미터)로 함수/클로저를 전달할 수 있다. 반환값(리턴벨류)으로 함수/클로저를 전달할 수 있다. 클로저와 함수 차이 클로저는 상위 스코프 변수 캡처 가능 함수는 캡처 기본 제공 x 용도 클로저 - 일회성 로직 전달(ex. 콜백) 함수 - 명시적 로직 분리 func doSomething() { print("hello world") } let closuredoSomething = { print("hello world") } func doSomething2(name: String) { print("hello world \(name)") } let closuredoSomething2 = { (name: String) -&gt; Void in print("hello world \(name)") } let closuredoSomething22: (String) -&gt; Void = { name in print("hello world") } func doSomething3(name: String) -&gt; String { return name } let closuredoSomethihg3: (String) -&gt; String = { name in return name } func doSomething4(closure: () -&gt; ()) { closure() } let closuredoSomethihg4: () -&gt; () = { print("test") } @main struct Main { static func main() { // doSomething() // closuredoSomething() doSomething2(name: "인덱스") closuredoSomething2("인덱스2") doSomething4(closure: closuredoSomethihg4) // MARK: - 마지막 매개변수가 클로저이면 후행 클로저를 사용할 수 있다. doSomething4 { closuredoSomethihg4() } } } ## reference - https://babbab2.tistory.com/81]]></summary></entry><entry><title type="html">[TableView] 11. 테이블뷰 제네릭 CustomCombineDataSource</title><link href="http://localhost:4000/UIKit-tableView11/" rel="alternate" type="text/html" title="[TableView] 11. 테이블뷰 제네릭 CustomCombineDataSource" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-tableView11</id><content type="html" xml:base="http://localhost:4000/UIKit-tableView11/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="테이블뷰-제네릭-customcombinedatasource">테이블뷰 제네릭 CustomCombineDataSource</h2>

<p>제네릭</p>
<ul>
  <li>어떠한 자료형을 받을 수 있다.</li>
  <li>IndexData를 만들어서 해당 타입도 받을 수 있도록 해보자.</li>
</ul>

<h3 id="indexdata구조체-추가">IndexData구조체 추가</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  DummyData.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/8/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">Foundation</span>
<span class="kd">import</span> <span class="kt">Fakery</span>

<span class="kd">struct</span> <span class="kt">DummySection</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">uuid</span><span class="p">:</span> <span class="kt">UUID</span>
    <span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">rows</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">]</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">uuid</span> <span class="o">=</span> <span class="kt">UUID</span><span class="p">()</span>
        <span class="k">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">"섹션 타이틀입니다: </span><span class="se">\(</span><span class="n">uuid</span><span class="se">)</span><span class="s">"</span>
        <span class="k">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s">"섹션 바디입니다: </span><span class="se">\(</span><span class="n">uuid</span><span class="se">)</span><span class="s">"</span>
        <span class="k">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="kt">DummyData</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">getDummies</span><span class="p">(</span><span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">DummySection</span><span class="p">]</span> <span class="p">{</span>
        <span class="nf">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="kt">DummySection</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">DummyData</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">uuid</span><span class="p">:</span> <span class="kt">UUID</span>
    <span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">String</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">uuid</span> <span class="o">=</span> <span class="kt">UUID</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">faker</span> <span class="o">=</span> <span class="kt">Faker</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="s">"ko"</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">firstName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">firstName</span><span class="p">()</span>  <span class="c1">//=&gt; "Emilie"</span>
        <span class="k">let</span> <span class="nv">lastName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">lastName</span><span class="p">()</span>    <span class="c1">//=&gt; "Hansen"</span>
        
        <span class="k">let</span> <span class="nv">body</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">lorem</span><span class="o">.</span><span class="nf">paragraphs</span><span class="p">(</span><span class="nv">amount</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
        
        <span class="k">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">"타이틀입니다: </span><span class="se">\(</span><span class="n">lastName</span><span class="se">)</span><span class="s"> </span><span class="se">\(</span><span class="n">firstName</span><span class="se">)</span><span class="s">"</span>
        <span class="k">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s">"바디입니다: </span><span class="se">\(</span><span class="n">body</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">getDumies</span><span class="p">(</span><span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">]</span> <span class="p">{</span>
        <span class="nf">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="kt">DummyData</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">IndexData</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">uuid</span><span class="p">:</span> <span class="kt">UUID</span>
    <span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">String</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">uuid</span> <span class="o">=</span> <span class="kt">UUID</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">faker</span> <span class="o">=</span> <span class="kt">Faker</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="s">"ko"</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">firstName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">firstName</span><span class="p">()</span>  <span class="c1">//=&gt; "Emilie"</span>
        <span class="k">let</span> <span class="nv">lastName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">lastName</span><span class="p">()</span>    <span class="c1">//=&gt; "Hansen"</span>
        
        <span class="k">let</span> <span class="nv">body</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">lorem</span><span class="o">.</span><span class="nf">paragraphs</span><span class="p">(</span><span class="nv">amount</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
        
        <span class="k">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">"타이틀입니다: </span><span class="se">\(</span><span class="n">lastName</span><span class="se">)</span><span class="s"> </span><span class="se">\(</span><span class="n">firstName</span><span class="se">)</span><span class="s">"</span>
        <span class="k">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s">"바디입니다: </span><span class="se">\(</span><span class="n">body</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">getDumies</span><span class="p">(</span><span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">IndexData</span><span class="p">]</span> <span class="p">{</span>
        <span class="nf">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="kt">IndexData</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="customcombinedatasourceswift">CustomCombineDataSource.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">//</span>
 <span class="c1">//  CustomCombineDataSource.swift</span>
 <span class="c1">//  UITableViewTutorial</span>
 <span class="c1">//</span>
 <span class="c1">//  Created by 김동현 on 5/15/25.</span>
 <span class="c1">//</span>
 
 <span class="kd">import</span> <span class="kt">UIKit</span>
 
 <span class="cm">/*
 class CustomCombineDataSource&lt;T, G&gt;: NSObject, UITableViewDataSource {
     
     // 멤버 변수
     var dataList: [T] = []
     
     var testDataList: [G] = []
 */</span>
 
 <span class="kd">class</span> <span class="kt">CustomCombineDataSource</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span> <span class="p">{</span>
     
     <span class="c1">// 멤버 변수</span>
     <span class="k">var</span> <span class="nv">dataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Item</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
     
     <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점</span>
 
     <span class="c1">/// 변경된 데이터를 받아서 테이블뷰에 적용한다</span>
     <span class="c1">/// - Parameters:</span>
     <span class="c1">///   - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수</span>
     <span class="c1">///   - tableView: 리로드 대상 테이블뷰</span>
     <span class="kd">func</span> <span class="nf">pushDataList</span><span class="p">(</span><span class="n">_</span> <span class="nv">updatedDataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Item</span><span class="p">],</span> <span class="n">to</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">tableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="k">self</span>
         <span class="k">self</span><span class="o">.</span><span class="n">dataList</span> <span class="o">=</span> <span class="n">updatedDataList</span>
         <span class="n">tableView</span><span class="o">.</span><span class="nf">reloadData</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 </span>
     
     <span class="c1">/// 하나의 섹션에 몇개의 rows가 있냐</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
         <span class="k">return</span> <span class="n">dataList</span><span class="o">.</span><span class="n">count</span>
     <span class="p">}</span>
 
     <span class="c1">// 어떤 셀을 보여줄 지</span>
     <span class="c1">/// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라</span>
     <span class="c1">/// - indexPath: 셀의 위치를 나타내는 인덱스 경로 - 몇번째인지</span>
     <span class="c1">/// - returns: 구성된 UITableViewCell 객체</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
         <span class="c1">/// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)</span>
         <span class="c1">/// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell")</span>
 
         <span class="c1">// [guard let] 방식</span>
         <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">CodeCell</span> <span class="k">else</span> <span class="p">{</span>
             <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()</span>
         <span class="p">}</span>
         
         <span class="k">if</span> <span class="k">let</span> <span class="nv">dataList</span> <span class="o">=</span> <span class="n">dataList</span> <span class="k">as?</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">]</span> <span class="p">{</span>
             <span class="k">let</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">DummyData</span> <span class="o">=</span> <span class="n">dataList</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>
 
             <span class="c1">/// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
             <span class="n">cell</span><span class="o">.</span><span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">title</span>
 
             <span class="c1">/// 셀의 서브 타이틀 설정</span>
             <span class="n">cell</span><span class="o">.</span><span class="n">bodyLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">body</span>
 
             <span class="n">cell</span><span class="o">.</span><span class="n">detailTextLabel</span><span class="p">?</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="p">}</span>
         
         <span class="k">if</span> <span class="k">let</span> <span class="nv">dataList</span> <span class="o">=</span> <span class="n">dataList</span> <span class="k">as?</span> <span class="p">[</span><span class="kt">IndexData</span><span class="p">]</span> <span class="p">{</span>
             <span class="k">let</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">IndexData</span> <span class="o">=</span> <span class="n">dataList</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>
 
             <span class="c1">/// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
             <span class="n">cell</span><span class="o">.</span><span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">title</span>
 
             <span class="c1">/// 셀의 서브 타이틀 설정</span>
             <span class="n">cell</span><span class="o">.</span><span class="n">bodyLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">body</span>
 
             <span class="n">cell</span><span class="o">.</span><span class="n">detailTextLabel</span><span class="p">?</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="p">}</span>
         
         <span class="k">return</span> <span class="n">cell</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>셀의 종류가 추가될때마다 항상 if let dataList를 하면 불편하다고 생각된다.</p>

<h3 id="uitableviewcombineswift">UITableView+Combine.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  UITableView+Combine.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/15/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="c1">// MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자.</span>
<span class="c1">// public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable</span>
<span class="kd">extension</span> <span class="kt">UITableView</span> <span class="p">{</span>
    <span class="c1">// 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체</span>
    <span class="c1">// (Self.Output) -&gt; Void)</span>
    <span class="c1">// ([DummyData]) -&gt; Void</span>
    <span class="c1">// 데이터소스 바인딩</span>
    <span class="kd">func</span> <span class="n">customItems</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">([</span><span class="kt">Item</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">dataSource</span> <span class="o">=</span> <span class="kt">CustomCombineDataSource</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span> <span class="p">(</span><span class="nv">updatedDateLisst</span><span class="p">:</span> <span class="p">[</span><span class="kt">Item</span><span class="p">])</span> <span class="k">in</span>
            <span class="n">dataSource</span><span class="o">.</span><span class="nf">pushDataList</span><span class="p">(</span><span class="n">updatedDateLisst</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <span class="c1">// 리로드</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="combinelistviewcontrollerswift">CombineListViewController.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  CombineListViewController.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/13/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">CombineListViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="c1">// Combine 메모리 처리를 위해 생성</span>
    <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="c1">// Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다.</span>
    <span class="c1">// @Published var dummies: [DummyData] = []</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">indexDatas</span><span class="p">:</span> <span class="p">[</span><span class="kt">IndexData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="o">!</span>

   
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="nf">configureTableView</span><span class="p">()</span>
        
        
        <span class="cm">/*
        - sink는 @Published가 수정된 스레드에서 실행된다
        - 그래서 Published변수 수정시 메인 스레드에서 수정해주자
        - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다
         */</span>
        
        <span class="c1">// MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다.</span>
        <span class="c1">// $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨</span>
        <span class="c1">// sink는 구독하는 것이다.</span>
        <span class="c1">// AnyCancellable 구독한다고 한다.</span>
        <span class="c1">// store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다.</span>
        <span class="n">$indexDatas</span>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">customItems</span><span class="p">())</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        <span class="cm">/*
         기존 방식
         $dummies
             .receive(on: DispatchQueue.main)
             // 데이터 변경시마다 동작
             .sink(receiveValue: { (changedDummies: [DummyData]) in
                 print("changedDummies: \(changedDummies.count)")
                 
                 // sink는 메인스레드에서 동작해서 Dispatch안해도된다
                 self.myTableView.reloadData()
             })
             .store(in: &amp;subscriptions)
         */</span>
        
        <span class="c1">// 2초 뒤에 더미데이터 10개 추가</span>
        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="nf">asyncAfter</span><span class="p">(</span><span class="nv">deadline</span><span class="p">:</span> <span class="o">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">execute</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1">// self.dummies += DummyData.getDumies(10)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">indexDatas</span> <span class="o">+=</span> <span class="kt">IndexData</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="kd">fileprivate</span> <span class="kd">func</span> <span class="nf">configureTableView</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="c1">// CodeCell에서는 이 줄만 필요</span>
        <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">CodeCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span>
        <span class="c1">// self.myTableView.delegate = self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드에서 CustomCombineDataSource.swift에서 셀이 추가될 때마다 항상 if let dataList를 하면 불편하다고 생각되기 때문에 이를 해결하기 위해 다음 포스팅을 작성하겠다.</p>

<h2 id="정리">정리</h2>
<p>데이터소스는 데이터와 관련되어 있고, 셀의 종류를 정하고 어떤 데이터인지에 따라 어떤 셀을 보여줄지 정하고, 리스트 갯수가 몇개인지를 관여한다.</p>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="TableView" /><summary type="html"><![CDATA[테이블뷰 제네릭 CustomCombineDataSource 제네릭 어떠한 자료형을 받을 수 있다. IndexData를 만들어서 해당 타입도 받을 수 있도록 해보자. IndexData구조체 추가 // // DummyData.swift // UITableViewTutorial // // Created by 김동현 on 5/8/25. // import Foundation import Fakery struct DummySection { let uuid: UUID let title: String let body: String let rows: [DummyData] init() { self.uuid = UUID() self.title = "섹션 타이틀입니다: \(uuid)" self.body = "섹션 바디입니다: \(uuid)" self.rows = DummyData.getDumies(10) } static func getDummies(_ count: Int = 100) -&gt; [DummySection] { return (1...count).map { _ in DummySection() } } } struct DummyData { let uuid: UUID let title: String let body: String init() { self.uuid = UUID() let faker = Faker(locale: "ko") let firstName = faker.name.firstName() //=&gt; "Emilie" let lastName = faker.name.lastName() //=&gt; "Hansen" let body = faker.lorem.paragraphs(amount: 10) self.title = "타이틀입니다: \(lastName) \(firstName)" self.body = "바디입니다: \(body)" } static func getDumies(_ count: Int = 100) -&gt; [DummyData] { return (1...count).map { _ in DummyData() } } } struct IndexData { let uuid: UUID let title: String let body: String init() { self.uuid = UUID() let faker = Faker(locale: "ko") let firstName = faker.name.firstName() //=&gt; "Emilie" let lastName = faker.name.lastName() //=&gt; "Hansen" let body = faker.lorem.paragraphs(amount: 10) self.title = "타이틀입니다: \(lastName) \(firstName)" self.body = "바디입니다: \(body)" } static func getDumies(_ count: Int = 100) -&gt; [IndexData] { return (1...count).map { _ in IndexData() } } } CustomCombineDataSource.swift // // CustomCombineDataSource.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // import UIKit /* class CustomCombineDataSource&lt;T, G&gt;: NSObject, UITableViewDataSource { // 멤버 변수 var dataList: [T] = [] var testDataList: [G] = [] */ class CustomCombineDataSource&lt;Item&gt;: NSObject, UITableViewDataSource { // 멤버 변수 var dataList: [Item] = [] override init() { super.init() } // MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점 /// 변경된 데이터를 받아서 테이블뷰에 적용한다 /// - Parameters: /// - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수 /// - tableView: 리로드 대상 테이블뷰 func pushDataList(_ updatedDataList: [Item], to tableView: UITableView) { tableView.dataSource = self self.dataList = updatedDataList tableView.reloadData() } // MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 /// 하나의 섹션에 몇개의 rows가 있냐 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return dataList.count } // 어떤 셀을 보여줄 지 /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라 /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 - 몇번째인지 /// - returns: 구성된 UITableViewCell 객체 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함) /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell") // [guard let] 방식 guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else { return UITableViewCell() } if let dataList = dataList as? [DummyData] { let cellData: DummyData = dataList[indexPath.row] /// 셀의 주 텍스트를 더미 데이터에서 가져오기 cell.titleLabel.text = cellData.title /// 셀의 서브 타이틀 설정 cell.bodyLabel.text = cellData.body cell.detailTextLabel?.numberOfLines = 0 } if let dataList = dataList as? [IndexData] { let cellData: IndexData = dataList[indexPath.row] /// 셀의 주 텍스트를 더미 데이터에서 가져오기 cell.titleLabel.text = cellData.title /// 셀의 서브 타이틀 설정 cell.bodyLabel.text = cellData.body cell.detailTextLabel?.numberOfLines = 0 } return cell } } 셀의 종류가 추가될때마다 항상 if let dataList를 하면 불편하다고 생각된다. UITableView+Combine.swift // // UITableView+Combine.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // import UIKit import Combine // MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자. // public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable extension UITableView { // 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체 // (Self.Output) -&gt; Void) // ([DummyData]) -&gt; Void // 데이터소스 바인딩 func customItems&lt;Item&gt;() -&gt; ([Item]) -&gt; Void { let dataSource = CustomCombineDataSource&lt;Item&gt;() return { (updatedDateLisst: [Item]) in dataSource.pushDataList(updatedDateLisst, to: self) // 리로드 } } } CombineListViewController.swift // // CombineListViewController.swift // UITableViewTutorial // // Created by 김동현 on 5/13/25. // import UIKit import Combine class CombineListViewController: UIViewController { // Combine 메모리 처리를 위해 생성 var subscriptions = Set&lt;AnyCancellable&gt;() // Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다. // @Published var dummies: [DummyData] = [] @Published var indexDatas: [IndexData] = [] @IBOutlet weak var myTableView: UITableView! override func viewDidLoad() { super.viewDidLoad() configureTableView() /* - sink는 @Published가 수정된 스레드에서 실행된다 - 그래서 Published변수 수정시 메인 스레드에서 수정해주자 - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다 */ // MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다. // $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨 // sink는 구독하는 것이다. // AnyCancellable 구독한다고 한다. // store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다. $indexDatas .receive(on: DispatchQueue.main) .sink(receiveValue: self.myTableView.customItems()) .store(in: &amp;subscriptions) /* 기존 방식 $dummies .receive(on: DispatchQueue.main) // 데이터 변경시마다 동작 .sink(receiveValue: { (changedDummies: [DummyData]) in print("changedDummies: \(changedDummies.count)") // sink는 메인스레드에서 동작해서 Dispatch안해도된다 self.myTableView.reloadData() }) .store(in: &amp;subscriptions) */ // 2초 뒤에 더미데이터 10개 추가 DispatchQueue.global().asyncAfter(deadline: .now() + 2, execute: { // self.dummies += DummyData.getDumies(10) self.indexDatas += IndexData.getDumies(10) }) } fileprivate func configureTableView() { // CodeCell에서는 이 줄만 필요 self.myTableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier) // self.myTableView.delegate = self } } 위 코드에서 CustomCombineDataSource.swift에서 셀이 추가될 때마다 항상 if let dataList를 하면 불편하다고 생각되기 때문에 이를 해결하기 위해 다음 포스팅을 작성하겠다. 정리 데이터소스는 데이터와 관련되어 있고, 셀의 종류를 정하고 어떤 데이터인지에 따라 어떤 셀을 보여줄지 정하고, 리스트 갯수가 몇개인지를 관여한다.]]></summary></entry><entry><title type="html">[Recommendation System] 1. 추천시스템 소개</title><link href="http://localhost:4000/Recommendation-System-Section1/" rel="alternate" type="text/html" title="[Recommendation System] 1. 추천시스템 소개" /><published>2025-05-14T00:00:00+00:00</published><updated>2025-05-14T00:00:00+00:00</updated><id>http://localhost:4000/%5BRecommendation%20System%5D-Section1</id><content type="html" xml:base="http://localhost:4000/Recommendation-System-Section1/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h1 id="추천-시스템이란">추천 시스템이란</h1>
<p>추천 시스템이란 사용자의 과거 행동 데이터를 바탕으로 사용자에게 필요한 정보나 제품을 제시하는 시스템이다.</p>

<h1 id="추천-시스템의-여러-기술">추천 시스템의 여러 기술</h1>
<ul>
  <li>협업 필터링(Collaborative Filtering)</li>
  <li>내용 기반 필터링(Content-Based Filtering)</li>
  <li>지식 기반 필터링(Knowledge-Based Filtering)</li>
  <li>딥러닝(Deep Learning)</li>
  <li>하이브리드 필터링(협업필터링 &amp; 딥러닝)</li>
</ul>

<h1 id="11-협업-필터링-collaborative-filtering">1.1 협업 필터링 (Collaborative Filtering)</h1>
<p>구매 및 소비한 제품에 대한 소비자의 평가 패턴이 비슷한 집단 속에서 서로 접하지 않은 제품을 추천하는 기술이다.<br />
한계 - 소비자의 평가정보를 구하기 어렵다 ex)신규/휴먼 고객<br />
해결책 - 구매가 아니라 클릭, 체류시간으로 간접적인 데이터로 협업 필터링 가능</p>

<h1 id="12-내용-기반-필터링content-based-filtering">1.2 내용 기반 필터링(Content-Based Filtering)</h1>
<p>제품의 내용을 분석해서 추천하는 기술이다.</p>

<h1 id="14-지식-기반-필터링knowledge-based-filtering">1.4 지식 기반 필터링(Knowledge-Based Filtering)</h1>
<p>특정 분야 전문가의 도움을 받아서 그 분야에 대한 전체적인 지식 구조를 만들어서 활용하는 방법이다.</p>

<h1 id="15-딥러닝deep-learning">1.5 딥러닝(Deep Learning)</h1>
<p>AI 알고리즘 중 현재 가장 많이 사용되는 딥러닝 방법이다.</p>

<h1 id="16-하이브리드-필터링협업필터링--딥러닝">1.6 하이브리드 필터링(협업필터링 &amp; 딥러닝)</h1>
<p>두가지 이상의 알고리즘 혼합을 통한 하이브리드 형태이다.</p>]]></content><author><name>Dong Hyeon</name></author><category term="Recommendation System" /><summary type="html"><![CDATA[추천 시스템이란 추천 시스템이란 사용자의 과거 행동 데이터를 바탕으로 사용자에게 필요한 정보나 제품을 제시하는 시스템이다. 추천 시스템의 여러 기술 협업 필터링(Collaborative Filtering) 내용 기반 필터링(Content-Based Filtering) 지식 기반 필터링(Knowledge-Based Filtering) 딥러닝(Deep Learning) 하이브리드 필터링(협업필터링 &amp; 딥러닝) 1.1 협업 필터링 (Collaborative Filtering) 구매 및 소비한 제품에 대한 소비자의 평가 패턴이 비슷한 집단 속에서 서로 접하지 않은 제품을 추천하는 기술이다. 한계 - 소비자의 평가정보를 구하기 어렵다 ex)신규/휴먼 고객 해결책 - 구매가 아니라 클릭, 체류시간으로 간접적인 데이터로 협업 필터링 가능 1.2 내용 기반 필터링(Content-Based Filtering) 제품의 내용을 분석해서 추천하는 기술이다. 1.4 지식 기반 필터링(Knowledge-Based Filtering) 특정 분야 전문가의 도움을 받아서 그 분야에 대한 전체적인 지식 구조를 만들어서 활용하는 방법이다. 1.5 딥러닝(Deep Learning) AI 알고리즘 중 현재 가장 많이 사용되는 딥러닝 방법이다. 1.6 하이브리드 필터링(협업필터링 &amp; 딥러닝) 두가지 이상의 알고리즘 혼합을 통한 하이브리드 형태이다.]]></summary></entry><entry><title type="html">[Docker] Docker?</title><link href="http://localhost:4000/Docker-docker1/" rel="alternate" type="text/html" title="[Docker] Docker?" /><published>2025-05-14T00:00:00+00:00</published><updated>2025-05-14T00:00:00+00:00</updated><id>http://localhost:4000/%5BDocker%5D-docker1</id><content type="html" xml:base="http://localhost:4000/Docker-docker1/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="docker">Docker</h2>
<p>이식성 - 명령어 한 줄로 어떤 컴퓨터에서든 동일한 환경설정이 가능해 에러를 피할 수 있다.</p>]]></content><author><name>Dong Hyeon</name></author><category term="Docker" /><summary type="html"><![CDATA[Docker 이식성 - 명령어 한 줄로 어떤 컴퓨터에서든 동일한 환경설정이 가능해 에러를 피할 수 있다.]]></summary></entry></feed>