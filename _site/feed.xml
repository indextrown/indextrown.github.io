<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-08-12T08:06:13+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">DongHyeon Kim’s Blog</title><subtitle>Swift와 크롤링 기술을 통해 안전한 세상을 만들고 싶습니다.</subtitle><author><name>Dong Hyeon</name></author><entry><title type="html">[AutoLayout] 2. 다른 뷰에 뷰를 연결하는법</title><link href="http://localhost:4000/AutoLayout-autolayout2/" rel="alternate" type="text/html" title="[AutoLayout] 2. 다른 뷰에 뷰를 연결하는법" /><published>2025-08-12T00:00:00+00:00</published><updated>2025-08-12T00:00:00+00:00</updated><id>http://localhost:4000/%5BAutoLayout%5D-autolayout2</id><content type="html" xml:base="http://localhost:4000/AutoLayout-autolayout2/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<table>
  <tr>
    <td><img src="/assets/img/2025-08-12-%5BAutoLayout%5D-autolayout2/image-20250812160116357.png" alt="커스텀셀1" width="100%" /></td>
    <td><img src="/assets/img/2025-08-08-%5BAutoLayout%5D-autolayout1/image-20250812160511084.png" alt="커스텀셀" width="100%" /></td>
  </tr>
  <tr>
    <td style="text-align:center;">Leading</td>
    <td style="text-align:center;">Option + Leading</td>
  </tr>
  <tr>
    <td style="text-align:center; font-size:14px; color:#666;">
    green view에서 yellow view로 드래그 해서 Leading을 해주면<br />yellow view leading과 동일한 효과를 얻을 수 있다.
    </td>
    <td style="text-align:center; font-size:14px; color:#666;">
    green view에서 yellow view로 드래그 할 때 option을 누르면서 Leading을 해주면<br /> 현재 green위치에서 yellow leading 사이의 여백을 더해줄 수 있다.
    </td>
  </tr>
</table>

<p><br /><br /><br /><br /></p>

<table>
  <tr>
    <td><img src="/assets/img/2025-08-12-%5BAutoLayout%5D-autolayout2/image-20250812161107136.png" alt="커스텀셀1" width="100%" /></td>
    <td><img src="/assets/img/2025-08-12-%5BAutoLayout%5D-autolayout2/image-20250812161522955.png" alt="커스텀셀" width="100%" /></td>
  </tr>
  <tr>
    <td style="text-align:center;">Top Anchor 1번방식</td>
    <td style="text-align:center;">Top Anchor 2번방식</td>
  </tr>
  <tr>
    <td style="text-align:center; font-size:14px; color:#666;">
    green에서 Top Anchor를 설정하면 작살이 위로 날라가서 제일 가까운 top에 꽃힌다.
    </td>
    <td style="text-align:center; font-size:14px; color:#666;">
    만약 1번방식 대신 드래그로 하는방법은 green의 top을 yellow의 바텀으로 거는 설정이 없기 때문에
    yellow의 바텀으로 일단 걸고 우측 인스펙터에서 green Bottom -&gt; green Top으로 옮기고 constant를 주면 된다.
    </td>
  </tr>
</table>]]></content><author><name>Dong Hyeon</name></author><category term="AutoLayout" /><summary type="html"><![CDATA[Leading Option + Leading green view에서 yellow view로 드래그 해서 Leading을 해주면yellow view leading과 동일한 효과를 얻을 수 있다. green view에서 yellow view로 드래그 할 때 option을 누르면서 Leading을 해주면 현재 green위치에서 yellow leading 사이의 여백을 더해줄 수 있다. Top Anchor 1번방식 Top Anchor 2번방식 green에서 Top Anchor를 설정하면 작살이 위로 날라가서 제일 가까운 top에 꽃힌다. 만약 1번방식 대신 드래그로 하는방법은 green의 top을 yellow의 바텀으로 거는 설정이 없기 때문에 yellow의 바텀으로 일단 걸고 우측 인스펙터에서 green Bottom -&gt; green Top으로 옮기고 constant를 주면 된다.]]></summary></entry><entry><title type="html">[AutoLayout] 3. 컨테이너</title><link href="http://localhost:4000/AutoLayout-autolayout3/" rel="alternate" type="text/html" title="[AutoLayout] 3. 컨테이너" /><published>2025-08-12T00:00:00+00:00</published><updated>2025-08-12T00:00:00+00:00</updated><id>http://localhost:4000/%5BAutoLayout%5D-autolayout3</id><content type="html" xml:base="http://localhost:4000/AutoLayout-autolayout3/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<h2 id="view-vs-label">View vs label</h2>
<ul>
  <li>일반적인 view는 크기와 위치를 지정해줘야 한다.</li>
  <li>label은 자체적으로 크기를 가지기 때문에 크기는 정해주지 않아고 위치만 정해준다.</li>
  <li>크기를 대신해줄 수 있는 것은 <strong>constraints</strong>이다.</li>
</ul>

<table>
  <tr>
    <td><img src="/assets/img/2025-08-12-%5BAutoLayout%5D-autolayout3/image-20250812164741262.png" alt="커스텀셀1" width="90%" /></td>
    <td><img src="/assets/img/2025-08-12-%5BAutoLayout%5D-autolayout3/image-20250812165643354.png" alt="커스텀셀" width="100%" /></td>
  </tr>
  <tr>
    <td style="text-align:center;">Yellow의 위치와 크기 고정</td>
    <td style="text-align:center;">Yellow의 위치만 고정(크기x)</td>
  </tr>
  <tr>
    <td style="text-align:center; font-size:14px; color:#666;">
    컨테이너 뷰(Yellow)의 크기와 위치를 모두 고정하는 방식<br />
    width와 height를 직접 지정하여 레이아웃을 확정한다.
    </td>
    <td style="text-align:center; font-size:14px; color:#666;">
      크기는 직접 지정하지 않고 내부 Yellow 컨테이너의 subview들의 constraints로 대체하는 방식.      
      예를 들어, <code>yellow</code>의 subview(top)와 label의 top, bottom을 서로 연결하면  
      label의 높이가 곧 yellow의 높이가 된다.<br /> 
      width는 subview 또는 label에서 yellow로 <b>leading</b> 제약을 주어 결정할 수 있다.
    </td>
  </tr>
</table>

<h2 id="정리">정리</h2>
<p>크기를 대신해서 할 수 있는게 constraints이다.   <br />
yellow container의 크기를 해당 컨테이너 내부의 constraints로 대체할 수 있다.   <br />
가능한 이유는 yellow의 subview의 top이 존재하고 label의 top과 subView의 바텀이 연결되어 있다. 추가적으로 label의 bottom을 yellow의 bottom으로 연결해주면 높이는 대체가 된다.<br />
width는 label이나 subView에서 yellow로 왼쪽으로 작살을 던져주면 해결된다.</p>

<p>(subView의 top이 yellow의 top에 연결되어 있고 subView가 가운데 정렬이기 때문에 subView에서 왼쪽으로 anchor를 놓든 subView의 leading을 따르는 label의 왼쪽으로 anchor를 놓든 width를 결정할 수 있다.)</p>]]></content><author><name>Dong Hyeon</name></author><category term="AutoLayout" /><summary type="html"><![CDATA[View vs label 일반적인 view는 크기와 위치를 지정해줘야 한다. label은 자체적으로 크기를 가지기 때문에 크기는 정해주지 않아고 위치만 정해준다. 크기를 대신해줄 수 있는 것은 constraints이다. Yellow의 위치와 크기 고정 Yellow의 위치만 고정(크기x) 컨테이너 뷰(Yellow)의 크기와 위치를 모두 고정하는 방식 width와 height를 직접 지정하여 레이아웃을 확정한다. 크기는 직접 지정하지 않고 내부 Yellow 컨테이너의 subview들의 constraints로 대체하는 방식. 예를 들어, yellow의 subview(top)와 label의 top, bottom을 서로 연결하면 label의 높이가 곧 yellow의 높이가 된다. width는 subview 또는 label에서 yellow로 leading 제약을 주어 결정할 수 있다. 정리 크기를 대신해서 할 수 있는게 constraints이다. yellow container의 크기를 해당 컨테이너 내부의 constraints로 대체할 수 있다. 가능한 이유는 yellow의 subview의 top이 존재하고 label의 top과 subView의 바텀이 연결되어 있다. 추가적으로 label의 bottom을 yellow의 bottom으로 연결해주면 높이는 대체가 된다. width는 label이나 subView에서 yellow로 왼쪽으로 작살을 던져주면 해결된다. (subView의 top이 yellow의 top에 연결되어 있고 subView가 가운데 정렬이기 때문에 subView에서 왼쪽으로 anchor를 놓든 subView의 leading을 따르는 label의 왼쪽으로 anchor를 놓든 width를 결정할 수 있다.)]]></summary></entry><entry><title type="html">[AutoLayout] 0. 오토레이아웃 개념</title><link href="http://localhost:4000/AutoLayout-autolayout0/" rel="alternate" type="text/html" title="[AutoLayout] 0. 오토레이아웃 개념" /><published>2025-08-08T00:00:00+00:00</published><updated>2025-08-08T00:00:00+00:00</updated><id>http://localhost:4000/%5BAutoLayout%5D-autolayout0</id><content type="html" xml:base="http://localhost:4000/AutoLayout-autolayout0/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<p><img src="/assets/img/2025-08-08-%5BAutoLayout%5D-autolayout0/image-20250808170826492.png" alt="이미지" width="70%" /><br />
ViewController에서 View는 화면을 그리는 부분이다.  <br />
UI를 만들기 위한 그래픽 환경을 InterfaceBuilder라고 한다.<br />
<br /><br /><br /><br /></p>

<p><img src="/assets/img/2025-08-08-%5BAutoLayout%5D-autolayout0/image-20250808174834409.png" alt="이미지" width="70%" /><br />
현재 SafeArea위에 View를 올렸다. View 자체는 크기가 없기 때문에 크기 지정을 해주자.  <br />
오토 레이아웃에서는 <strong>크기와 위치가</strong> 중요하다. <strong>크기</strong>를 지정하고 <strong>위치</strong>를 지정해주는게 핵심이다.  <br />
사진에서는 위치는 좌측과 상단만 anchor를 걸고 크기는 width, height를 고정값으로 지정하였다.  <br />
<br /><br /><br /><br /></p>

<h2 id="tip">Tip</h2>
<p>만약 <strong>좌우로 앵커를 모두 설정</strong>한다면, <code class="language-plaintext highlighter-rouge">width</code> 고정값은 제거하자.  <br />
좌우 앵커와 width 고정값이 동시에 존재하면,  <br />
기기 화면 크기에 따라 <strong>레이아웃 충돌 에러</strong>가 발생할 수 있다.</p>

<p>width 고정값을 제거하면 좌우 앵커가 서로 당기는 힘을 주어,  <br />
기기 화면 크기에 맞춰 <strong>자동으로 너비가 결정</strong>된다.  <br />
이는 기종별 화면 크기를 오토레이아웃이 인식하기 때문에 가능하다.</p>

<h2 id="정리">정리</h2>
<ul>
  <li>오토레이아웃은 항상 크기와 위치가 필요하다.</li>
  <li>크기를 만들고 위치를 지정하자.</li>
  <li>anchor를 한 방향에서 서로 걸게 되면 서로 당기는 성질이 있어서 별도로 크기를 지정하지 않아도 핸드폰이 자체적으로 크기를 결정할 수 있다.</li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="AutoLayout" /><summary type="html"><![CDATA[ViewController에서 View는 화면을 그리는 부분이다. UI를 만들기 위한 그래픽 환경을 InterfaceBuilder라고 한다. 현재 SafeArea위에 View를 올렸다. View 자체는 크기가 없기 때문에 크기 지정을 해주자. 오토 레이아웃에서는 크기와 위치가 중요하다. 크기를 지정하고 위치를 지정해주는게 핵심이다. 사진에서는 위치는 좌측과 상단만 anchor를 걸고 크기는 width, height를 고정값으로 지정하였다. Tip 만약 좌우로 앵커를 모두 설정한다면, width 고정값은 제거하자. 좌우 앵커와 width 고정값이 동시에 존재하면, 기기 화면 크기에 따라 레이아웃 충돌 에러가 발생할 수 있다. width 고정값을 제거하면 좌우 앵커가 서로 당기는 힘을 주어, 기기 화면 크기에 맞춰 자동으로 너비가 결정된다. 이는 기종별 화면 크기를 오토레이아웃이 인식하기 때문에 가능하다. 정리 오토레이아웃은 항상 크기와 위치가 필요하다. 크기를 만들고 위치를 지정하자. anchor를 한 방향에서 서로 걸게 되면 서로 당기는 성질이 있어서 별도로 크기를 지정하지 않아도 핸드폰이 자체적으로 크기를 결정할 수 있다.]]></summary></entry><entry><title type="html">[AutoLayout] 1. Constraint</title><link href="http://localhost:4000/AutoLayout-autolayout1/" rel="alternate" type="text/html" title="[AutoLayout] 1. Constraint" /><published>2025-08-08T00:00:00+00:00</published><updated>2025-08-08T00:00:00+00:00</updated><id>http://localhost:4000/%5BAutoLayout%5D-autolayout1</id><content type="html" xml:base="http://localhost:4000/AutoLayout-autolayout1/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<ul>
  <li>오토레이아웃에서는 크기와 위치가 중요하다. 기본 개념은 크기를 지정하고 위치를 지정해준다.</li>
</ul>

<table>
  <tr>
    <td><img src="/assets/img/2025-08-08-%5BAutoLayout%5D-autolayout1/image-20250812152018585.png" alt="커스텀셀1" width="100%" /></td>
    <td><img src="/assets/img/2025-08-08-%5BAutoLayout%5D-autolayout1/image-20250812152323796.png" alt="커스텀셀" width="100%" /></td>
    <td><img src="/assets/img/2025-08-08-%5BAutoLayout%5D-autolayout1/image-20250812153048794.png" alt="커스텀셀" width="100%" /></td>
    <td><img src="/assets/img/2025-08-08-%5BAutoLayout%5D-autolayout1/image-20250812153505739.png" alt="커스텀셀" width="100%" /></td>
  </tr>
  <tr>
    <td style="text-align:center;">크기를 지정하고<br />위치를 지정</td>
    <td style="text-align:center;">상단 위치만 지정하고<br />수평 정렬</td>
    <td style="text-align:center;">상단 위치만 지정하고<br />좌우 앵커 지정</td>
    <td style="text-align:center;">상단 위치만 지정하고<br />좌측 앵커와 가운데 정렬, width 제거</td>
  </tr>
  <tr>
    <td style="text-align:center; font-size:14px; color:#666;">
    크기와 위치를 모두 지정해<br />레이아웃 고정.
    </td>
    <td style="text-align:center; font-size:14px; color:#666;">
    가운데 정렬로 기기별 가로 위치 일관성 확보.
    </td>
    <td style="text-align:center; font-size:14px; color:#666;">
      기기마다 크기가 달라서 문제가 발생할 수 있다.<br />이때는 width를 없애주자.
    </td>
    <td style="text-align:center; font-size:14px; color:#666;">
      좌측 앵커만 수정해도 좌우 여백을 조절할 수 있다.
    </td>
  </tr>
</table>]]></content><author><name>Dong Hyeon</name></author><category term="AutoLayout" /><summary type="html"><![CDATA[오토레이아웃에서는 크기와 위치가 중요하다. 기본 개념은 크기를 지정하고 위치를 지정해준다. 크기를 지정하고위치를 지정 상단 위치만 지정하고수평 정렬 상단 위치만 지정하고좌우 앵커 지정 상단 위치만 지정하고좌측 앵커와 가운데 정렬, width 제거 크기와 위치를 모두 지정해레이아웃 고정. 가운데 정렬로 기기별 가로 위치 일관성 확보. 기기마다 크기가 달라서 문제가 발생할 수 있다.이때는 width를 없애주자. 좌측 앵커만 수정해도 좌우 여백을 조절할 수 있다.]]></summary></entry><entry><title type="html">[AutoLayout] 0. 오토레이아웃 요약</title><link href="http://localhost:4000/AutoLayout-autolayoutTable/" rel="alternate" type="text/html" title="[AutoLayout] 0. 오토레이아웃 요약" /><published>2025-08-07T00:00:00+00:00</published><updated>2025-08-07T00:00:00+00:00</updated><id>http://localhost:4000/%5BAutoLayout%5D-autolayoutTable</id><content type="html" xml:base="http://localhost:4000/AutoLayout-autolayoutTable/"><![CDATA[<table>
  <thead>
    <tr>
      <th>내용</th>
      <th>Summary</th>
      <th>날짜</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0. 강의링크</td>
      <td><a href="https://www.youtube.com/playlist?list=PLgOlaPUlbynHT9_2KaWGuoEl1CeKESt9">유튜브 재생목록 바로가기</a></td>
      <td>2025년 3월 17일</td>
    </tr>
    <tr>
      <td>1. 오토레이아웃 기본 개념</td>
      <td>- <a href="http://127.0.0.1:4000/AutoLayout-autolayout0/">0. 오토레이아웃 개념</a><br />- 오토레이아웃은 항상 <strong>크기와 위치</strong>가 필요하다.<br />- <strong>크기</strong>를 만들고 <strong>위치</strong>를 지정하자.<br />- anchor를 한 방향에서 서로 걸게 되면 서로 당기는 성질이 있어서 별도로 크기를 지정하지 않아도 핸드폰이 자체적으로 크기를 결정할 수 있다.</td>
      <td>2025년 3월 18일</td>
    </tr>
    <tr>
      <td>2. 컨스트레인트 기본</td>
      <td>- <strong>safeArea</strong>란 노치에 상관없이 안전하게 뷰를 보여줄 수 있는 부분을 의미한다.<br />- align이 된 상태에서 한쪽에 constraint를 걸면 반대쪽도 자동으로 걸어진다.</td>
      <td>2025년 3월 18일</td>
    </tr>
    <tr>
      <td>3. 멀티뷰 연결</td>
      <td>- control 누르면서 뷰를 다른 뷰에 드래그하여 제약 조건을 지정할 수 있다.<br />- 이때 <strong>option</strong>을 누르면 현재 위치로 제약이 된다.</td>
      <td>2025년 3월 18일</td>
    </tr>
    <tr>
      <td>4. 컨테이너 개념</td>
      <td>- label의 크기는 안 넣어도 된다.<br />- <strong>horizontal = 수평정렬 = x축 가운데정렬</strong>이다.<br />- UIView 크기를 하드코딩하지 않고 constraints로 지정할 수 있다.</td>
      <td>2025년 3월 18일</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Dong Hyeon</name></author><category term="AutoLayout" /><summary type="html"><![CDATA[내용 Summary 날짜 0. 강의링크 유튜브 재생목록 바로가기 2025년 3월 17일 1. 오토레이아웃 기본 개념 - 0. 오토레이아웃 개념- 오토레이아웃은 항상 크기와 위치가 필요하다.- 크기를 만들고 위치를 지정하자.- anchor를 한 방향에서 서로 걸게 되면 서로 당기는 성질이 있어서 별도로 크기를 지정하지 않아도 핸드폰이 자체적으로 크기를 결정할 수 있다. 2025년 3월 18일 2. 컨스트레인트 기본 - safeArea란 노치에 상관없이 안전하게 뷰를 보여줄 수 있는 부분을 의미한다.- align이 된 상태에서 한쪽에 constraint를 걸면 반대쪽도 자동으로 걸어진다. 2025년 3월 18일 3. 멀티뷰 연결 - control 누르면서 뷰를 다른 뷰에 드래그하여 제약 조건을 지정할 수 있다.- 이때 option을 누르면 현재 위치로 제약이 된다. 2025년 3월 18일 4. 컨테이너 개념 - label의 크기는 안 넣어도 된다.- horizontal = 수평정렬 = x축 가운데정렬이다.- UIView 크기를 하드코딩하지 않고 constraints로 지정할 수 있다. 2025년 3월 18일]]></summary></entry><entry><title type="html">[RxDataSource] 3. CustomDatasource 개선하기</title><link href="http://localhost:4000/RxDataSource-RxDataSource-3/" rel="alternate" type="text/html" title="[RxDataSource] 3. CustomDatasource 개선하기" /><published>2025-08-03T00:00:00+00:00</published><updated>2025-08-03T00:00:00+00:00</updated><id>http://localhost:4000/%5BRxDataSource%5D-RxDataSource-3</id><content type="html" xml:base="http://localhost:4000/RxDataSource-RxDataSource-3/"><![CDATA[<!-- https://www.youtube.com/watch?v=sBybUm8yVbI&list=PLgOlaPUIbynpuq9GKCwAedgWkkPm2Wo8v&index=18 -->

<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<p>지난 포스트에서 커스텀 델리게이트를 만들어 보았다. 이번에는 기존 코드를 개선하여 셀 구성 로직을 VC에서 정의할 수 있도록 매개변수로 빼서 위임해보자.</p>

<h2 id="지난-코드">지난 코드</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">ReuseIdentifiable</span> <span class="p">{</span>
    <span class="c1">/// 프로토콜에서 로직을 정의할 수 없어서 가져올 수 있도록 설정</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">ReuseIdentifiable</span> <span class="p">{</span>
    <span class="c1">/// 로직에 대한 정의는 Extension에서 간능</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">UITableViewCell</span><span class="p">:</span> <span class="kt">ReuseIdentifiable</span> <span class="p">{}</span>

<span class="c1">// MARK: - Model</span>
<span class="kd">struct</span> <span class="kt">Todo</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">isDone</span><span class="p">:</span> <span class="kt">Bool</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">getDumies</span><span class="p">(</span><span class="n">_</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Todo</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">faker</span> <span class="o">=</span> <span class="kt">Faker</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="s">"ko"</span><span class="p">)</span>
        <span class="nf">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">id</span> <span class="k">in</span>
            <span class="k">let</span> <span class="nv">firstName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">firstName</span><span class="p">()</span>
            <span class="k">let</span> <span class="nv">lastName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">lastName</span><span class="p">()</span>
            <span class="k">let</span> <span class="nv">title</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">lastName</span><span class="se">)</span><span class="s"> </span><span class="se">\(</span><span class="n">firstName</span><span class="se">)</span><span class="s">"</span>
            <span class="k">return</span> <span class="kt">Todo</span><span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="n">id</span><span class="p">,</span> <span class="nv">title</span><span class="p">:</span> <span class="n">title</span><span class="p">,</span> <span class="nv">isDone</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TodoCell</span><span class="p">:</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
    
    <span class="c1">// 디버깅용</span>
    <span class="k">var</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">Todo</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    
    <span class="c1">// (uuid, 변경된상태)</span>
    <span class="k">var</span> <span class="nv">isDoneChange</span><span class="p">:</span> <span class="p">((</span><span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">newValue</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span>
    
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">isDoneSwitch</span><span class="p">:</span> <span class="kt">UISwitch</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">sw</span> <span class="o">=</span> <span class="kt">UISwitch</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sw</span>
    <span class="p">}()</span>
    
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">titleLabel</span><span class="p">:</span> <span class="kt">UILabel</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">label</span>
    <span class="p">}()</span>
    
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">idLabel</span><span class="p">:</span> <span class="kt">UILabel</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">label</span>
    <span class="p">}()</span>
    
    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">vStack</span><span class="p">:</span> <span class="kt">UIStackView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">st</span> <span class="o">=</span> <span class="kt">UIStackView</span><span class="p">(</span><span class="nv">arrangedSubviews</span><span class="p">:</span> <span class="p">[</span><span class="n">titleLabel</span><span class="p">,</span> <span class="n">idLabel</span><span class="p">])</span>
        <span class="n">st</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="o">.</span><span class="n">vertical</span>
        <span class="k">return</span> <span class="n">st</span>
    <span class="p">}()</span>
    
    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">hStack</span><span class="p">:</span> <span class="kt">UIStackView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">st</span> <span class="o">=</span> <span class="kt">UIStackView</span><span class="p">(</span><span class="nv">arrangedSubviews</span><span class="p">:</span> <span class="p">[</span><span class="n">vStack</span><span class="p">,</span> <span class="n">isDoneSwitch</span><span class="p">])</span>
        <span class="n">st</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="o">.</span><span class="n">horizontal</span>
        <span class="k">return</span> <span class="n">st</span>
    <span class="p">}()</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">prepareForReuse</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">prepareForReuse</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"prepareForReuse() - cellData.id: </span><span class="se">\(</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="p">??</span> <span class="mi">0</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 원래는 awakefromnib을 타지만 코드로 UI를 진행한다면 awakefromnib을 타지 않는다.</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">.</span><span class="kt">CellStyle</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="c1">/// 부모의 로직을 싱행시키는 의미</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="n">style</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="n">reuseIdentifier</span><span class="p">)</span>
        <span class="nf">makeUI</span><span class="p">()</span>
        <span class="nf">constraints</span><span class="p">()</span>
        
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="nf">addTarget</span><span class="p">(</span><span class="k">self</span><span class="p">,</span>
                               <span class="nv">action</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">handleIsDOne</span><span class="p">),</span>
                               <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">valueChanged</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="nv">coder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">fatalError</span><span class="p">(</span><span class="s">"init(coder:) has not been implemented"</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeUI</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">hStack</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="n">contentView</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">constraints</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">NSLayoutConstraint</span><span class="o">.</span><span class="nf">activate</span><span class="p">([</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">topAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="mi">10</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="mi">10</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">),</span>
        <span class="p">])</span>
    <span class="p">}</span>
    
    <span class="kd">@objc</span> <span class="kd">func</span> <span class="nf">handleIsDOne</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UISwitch</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- id: </span><span class="se">\(</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="p">??</span> <span class="mi">0</span><span class="se">)</span><span class="s">, sendar: </span><span class="se">\(</span><span class="n">sender</span><span class="o">.</span><span class="n">isOn</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="nf">isDoneChange</span><span class="p">?(</span><span class="n">id</span><span class="p">,</span> <span class="n">sender</span><span class="o">.</span><span class="n">isOn</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">TodoCell</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">configure</span><span class="p">(</span><span class="n">with</span> <span class="nv">todo</span><span class="p">:</span> <span class="kt">Todo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">cellData</span> <span class="o">=</span> <span class="n">todo</span>
        <span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">title</span>
        <span class="n">idLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"ID: </span><span class="se">\(</span><span class="n">todo</span><span class="o">.</span><span class="n">id</span><span class="se">)</span><span class="s">"</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">isOn</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">isDone</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - 구현 목적: VC에 부담을 주지말자</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TodosDataSource</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span><span class="p">,</span> <span class="kt">UITableViewDelegate</span> <span class="p">{</span>
    
    <span class="k">var</span> <span class="nv">todoList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Todo</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">var</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">todoList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Todo</span><span class="p">],</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">todoList</span> <span class="o">=</span> <span class="n">todoList</span>
        <span class="k">self</span><span class="o">.</span><span class="n">tableView</span> <span class="o">=</span> <span class="n">tableView</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - Register</span>
    <span class="kd">func</span> <span class="n">register</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">cellType</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tableView</span><span class="p">?</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="n">cellType</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - UITableView Datasource Methods</span>
    <span class="c1">/// 하나의 섹션에 몇개의 rows가 있냐</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">todoList</span><span class="o">.</span><span class="n">count</span>
    <span class="p">}</span>
    
    <span class="c1">// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라</span>
    <span class="c1">/// - indexPath: 셀의 위치를 나타내는 인덱스 경로</span>
    <span class="c1">/// - returns: 구성된 UITableViewCell 객체e</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
        
        
        <span class="c1">// MARK: - 로직 -&gt; 함수로 만들어서 매개변수로 활용해보자</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span><span class="p">:</span> <span class="kt">TodoCell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">TodoCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">TodoCell</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="nv">cellData</span> <span class="o">=</span> <span class="n">todoList</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>
        <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">cellData</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cell</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TodosVC</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">tv</span> <span class="o">=</span> <span class="kt">UITableView</span><span class="p">()</span>
        <span class="c1">// MARK: - 이 부분도 TodosDataSource에 위임</span>
        <span class="c1">// tv.register(TodoCell.self, forCellReuseIdentifier: TodoCell.reuseIdentifier)</span>
        <span class="k">return</span> <span class="n">tv</span>
    <span class="p">}()</span>
    
    <span class="k">var</span> <span class="nv">todoList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Todo</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">var</span> <span class="nv">todosDataSource</span><span class="p">:</span> <span class="kt">TodosDataSource</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">white</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">makeUI</span><span class="p">()</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">constraints</span><span class="p">()</span>
        <span class="k">self</span><span class="o">.</span><span class="n">todoList</span> <span class="o">=</span> <span class="kt">Todo</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">()</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">setCustomDataSource</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">setCustomDataSource</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 1️⃣ dataSource 생성</span>
        <span class="k">let</span> <span class="nv">dataSource</span> <span class="o">=</span> <span class="kt">TodosDataSource</span><span class="p">(</span><span class="nv">todoList</span><span class="p">:</span> <span class="n">todoList</span><span class="p">,</span> <span class="nv">tableView</span><span class="p">:</span> <span class="n">myTableView</span><span class="p">)</span>
        
        <span class="c1">// 2️⃣ register 호출 (이 시점에 tableView는 이미 존재함)</span>
        <span class="n">dataSource</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="nv">cellType</span><span class="p">:</span> <span class="kt">TodoCell</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        
        <span class="c1">// 3️⃣ 연결</span>
        <span class="k">self</span><span class="o">.</span><span class="n">todosDataSource</span> <span class="o">=</span> <span class="n">dataSource</span>
        <span class="n">myTableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeUI</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">myTableView</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="n">view</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">constraints</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">NSLayoutConstraint</span><span class="o">.</span><span class="nf">activate</span><span class="p">([</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">safeAreaLayoutGuide</span><span class="o">.</span><span class="n">topAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="개선-코드">개선 코드</h2>

<h3 id="custom-delegate">Custom Delegate</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="c1">// MARK: - 구현 목적: VC에 부담을 주지말자</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TodosDataSource2</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span><span class="p">,</span> <span class="kt">UITableViewDelegate</span> <span class="p">{</span>
    
    <span class="k">var</span> <span class="nv">todoList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Todo</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">var</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    
    <span class="c1">// MARK: - 로직을 밖으로 뺄 수 있다 즉 VC에서 클로저로 사용 가능하다.</span>
    <span class="c1">// configureCell 클로저: 셀 구성 로직을 VC에서 정의할 수 있게 위임함</span>
    <span class="c1">// 매개변수 tableView, indexPath는 외부에서 받아오고</span>
    <span class="c1">// cellData(todo)는 내부 todoList에서 가져와 주입</span>
    <span class="k">var</span> <span class="nv">configureCell</span><span class="p">:</span> <span class="p">((</span><span class="kt">UITableView</span><span class="p">,</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="kt">Todo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span><span class="p">)?</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">todoList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Todo</span><span class="p">],</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">todoList</span> <span class="o">=</span> <span class="n">todoList</span>
        <span class="k">self</span><span class="o">.</span><span class="n">tableView</span> <span class="o">=</span> <span class="n">tableView</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - Register</span>
    <span class="kd">func</span> <span class="n">register</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">cellType</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tableView</span><span class="p">?</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="n">cellType</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - UITableView Datasource Methods</span>
    <span class="c1">/// 하나의 섹션에 몇개의 rows가 있냐</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">todoList</span><span class="o">.</span><span class="n">count</span>
    <span class="p">}</span>
    
    <span class="c1">// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라</span>
    <span class="c1">/// - indexPath: 셀의 위치를 나타내는 인덱스 경로</span>
    <span class="c1">/// - returns: 구성된 UITableViewCell 객체e</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="nv">cellData</span> <span class="o">=</span> <span class="n">todoList</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>
        <span class="k">return</span> <span class="nf">configureCell</span><span class="p">?(</span><span class="n">tableView</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">cellData</span><span class="p">)</span> <span class="p">??</span> <span class="kt">UITableViewCell</span><span class="p">()</span>
        
        <span class="c1">// MARK: - 로직 -&gt; 함수로 만들어서 매개변수로 활용해보자</span>
        <span class="cm">/*
        guard let cell: TodoCell = tableView.dequeueReusableCell(withIdentifier: TodoCell.reuseIdentifier, for: indexPath) as? TodoCell else {
            return UITableViewCell()
        }
        
        cell.configure(with: cellData)
        return cell
         */</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="viewcontroller">ViewController</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">TodosVC2</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">tv</span> <span class="o">=</span> <span class="kt">UITableView</span><span class="p">()</span>
        <span class="c1">// MARK: - 이 부분도 TodosDataSource에 위임</span>
        <span class="c1">// tv.register(TodoCell.self, forCellReuseIdentifier: TodoCell.reuseIdentifier)</span>
        <span class="k">return</span> <span class="n">tv</span>
    <span class="p">}()</span>
    
    <span class="k">var</span> <span class="nv">todoList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Todo</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">var</span> <span class="nv">todosDataSource</span><span class="p">:</span> <span class="kt">TodosDataSource2</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">white</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">makeUI</span><span class="p">()</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">constraints</span><span class="p">()</span>
        
        <span class="k">self</span><span class="o">.</span><span class="n">todoList</span> <span class="o">=</span> <span class="kt">Todo</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">()</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">setCustomDataSource</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">setCustomDataSource</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 1️⃣ dataSource 생성</span>
        <span class="n">todosDataSource</span> <span class="o">=</span> <span class="kt">TodosDataSource2</span><span class="p">(</span><span class="nv">todoList</span><span class="p">:</span> <span class="n">todoList</span><span class="p">,</span> <span class="nv">tableView</span><span class="p">:</span> <span class="n">myTableView</span><span class="p">)</span>
        
        <span class="c1">// MARK: - 여기에 클로저 추가</span>
        <span class="k">self</span><span class="o">.</span><span class="n">todosDataSource</span><span class="p">?</span><span class="o">.</span><span class="n">configureCell</span> <span class="o">=</span> <span class="p">{</span> <span class="n">mytableView</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">cellData</span> <span class="k">in</span>
            
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span><span class="p">:</span> <span class="kt">TodoCell</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">TodoCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">TodoCell</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()</span> <span class="p">}</span>
            
            <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">cellData</span><span class="p">)</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">isDoneChange</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">id</span><span class="p">,</span> <span class="n">isDone</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">foundIndex</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">todoList</span><span class="o">.</span><span class="nf">firstIndex</span><span class="p">(</span> <span class="nv">where</span><span class="p">:</span> <span class="p">{</span><span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span><span class="p">}</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">self</span><span class="o">.</span><span class="n">todosDataSource</span><span class="p">?</span><span class="o">.</span><span class="n">todoList</span><span class="p">[</span><span class="n">foundIndex</span><span class="p">]</span><span class="o">.</span><span class="n">isDone</span> <span class="o">=</span> <span class="n">isDone</span>
                    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
                        <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">reloadRows</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="p">[</span><span class="kt">IndexPath</span><span class="p">(</span><span class="nv">row</span><span class="p">:</span> <span class="n">foundIndex</span><span class="p">,</span> <span class="nv">section</span><span class="p">:</span> <span class="mi">0</span><span class="p">)],</span> <span class="nv">with</span><span class="p">:</span> <span class="o">.</span><span class="n">fade</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="k">return</span> <span class="n">cell</span>
        <span class="p">}</span>
        
        <span class="c1">// 2️⃣ register 호출 (이 시점에 tableView는 이미 존재함)</span>
        <span class="n">todosDataSource</span><span class="p">?</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="nv">cellType</span><span class="p">:</span> <span class="kt">TodoCell</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        
        <span class="c1">// 3️⃣ 연결</span>
        <span class="n">myTableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">todosDataSource</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeUI</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">myTableView</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="n">view</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">constraints</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">NSLayoutConstraint</span><span class="o">.</span><span class="nf">activate</span><span class="p">([</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">safeAreaLayoutGuide</span><span class="o">.</span><span class="n">topAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="ReactiveX" /><category term="RxDataSource" /><summary type="html"><![CDATA[지난 포스트에서 커스텀 델리게이트를 만들어 보았다. 이번에는 기존 코드를 개선하여 셀 구성 로직을 VC에서 정의할 수 있도록 매개변수로 빼서 위임해보자. 지난 코드 protocol ReuseIdentifiable { /// 프로토콜에서 로직을 정의할 수 없어서 가져올 수 있도록 설정 static var reuseIdentifier: String { get } } extension ReuseIdentifiable { /// 로직에 대한 정의는 Extension에서 간능 static var reuseIdentifier: String { return String(describing: Self.self) } } extension UITableViewCell: ReuseIdentifiable {} // MARK: - Model struct Todo { let id: Int let title: String var isDone: Bool static func getDumies(_ count: Int = 10) -&gt; [Todo] { let faker = Faker(locale: "ko") return (1...count).map { id in let firstName = faker.name.firstName() let lastName = faker.name.lastName() let title = "\(lastName) \(firstName)" return Todo(id: id, title: title, isDone: false) } } } final class TodoCell: UITableViewCell { // 디버깅용 var cellData: Todo? = nil // (uuid, 변경된상태) var isDoneChange: ((Int, _ newValue: Bool) -&gt; Void)? = nil lazy var isDoneSwitch: UISwitch = { let sw = UISwitch() return sw }() lazy var titleLabel: UILabel = { let label = UILabel() return label }() lazy var idLabel: UILabel = { let label = UILabel() return label }() private lazy var vStack: UIStackView = { let st = UIStackView(arrangedSubviews: [titleLabel, idLabel]) st.axis = .vertical return st }() private lazy var hStack: UIStackView = { let st = UIStackView(arrangedSubviews: [vStack, isDoneSwitch]) st.axis = .horizontal return st }() override func prepareForReuse() { super.prepareForReuse() print(#fileID, #function, #line, "prepareForReuse() - cellData.id: \(cellData?.id ?? 0)") } // 원래는 awakefromnib을 타지만 코드로 UI를 진행한다면 awakefromnib을 타지 않는다. override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) { /// 부모의 로직을 싱행시키는 의미 super.init(style: style, reuseIdentifier: reuseIdentifier) makeUI() constraints() isDoneSwitch.addTarget(self, action: #selector(handleIsDOne), for: .valueChanged) } required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") } private func makeUI() { [hStack].forEach { contentView.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } } private func constraints() { NSLayoutConstraint.activate([ hStack.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 10), hStack.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 10), hStack.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -10), hStack.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -10), ]) } @objc func handleIsDOne(_ sender: UISwitch) { print(#fileID, #function, #line, "- id: \(cellData?.id ?? 0), sendar: \(sender.isOn)") guard let id = self.cellData?.id else { return } isDoneChange?(id, sender.isOn) } } extension TodoCell { func configure(with todo: Todo) { self.cellData = todo titleLabel.text = todo.title idLabel.text = "ID: \(todo.id)" isDoneSwitch.isOn = todo.isDone } } // MARK: - 구현 목적: VC에 부담을 주지말자 final class TodosDataSource: NSObject, UITableViewDataSource, UITableViewDelegate { var todoList: [Todo] = [] var tableView: UITableView? = nil init(todoList: [Todo], tableView: UITableView) { self.todoList = todoList self.tableView = tableView } // MARK: - Register func register&lt;T: UITableViewCell&gt;(cellType: T.Type) { tableView?.register(cellType, forCellReuseIdentifier: T.reuseIdentifier) } // MARK: - UITableView Datasource Methods /// 하나의 섹션에 몇개의 rows가 있냐 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return todoList.count } // 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라 /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 /// - returns: 구성된 UITableViewCell 객체e func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { // MARK: - 로직 -&gt; 함수로 만들어서 매개변수로 활용해보자 guard let cell: TodoCell = tableView.dequeueReusableCell(withIdentifier: TodoCell.reuseIdentifier, for: indexPath) as? TodoCell else { return UITableViewCell() } let cellData = todoList[indexPath.row] cell.configure(with: cellData) return cell } } final class TodosVC: UIViewController { private lazy var myTableView: UITableView = { let tv = UITableView() // MARK: - 이 부분도 TodosDataSource에 위임 // tv.register(TodoCell.self, forCellReuseIdentifier: TodoCell.reuseIdentifier) return tv }() var todoList: [Todo] = [] var todosDataSource: TodosDataSource? = nil override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white self.makeUI() self.constraints() self.todoList = Todo.getDumies() self.setCustomDataSource() } private func setCustomDataSource() { // 1️⃣ dataSource 생성 let dataSource = TodosDataSource(todoList: todoList, tableView: myTableView) // 2️⃣ register 호출 (이 시점에 tableView는 이미 존재함) dataSource.register(cellType: TodoCell.self) // 3️⃣ 연결 self.todosDataSource = dataSource myTableView.dataSource = dataSource } private func makeUI() { [myTableView].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } } private func constraints() { NSLayoutConstraint.activate([ myTableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor), myTableView.leadingAnchor.constraint(equalTo: view.leadingAnchor), myTableView.trailingAnchor.constraint(equalTo: view.trailingAnchor), myTableView.bottomAnchor.constraint(equalTo: view.bottomAnchor) ]) } } 개선 코드 Custom Delegate import UIKit // MARK: - 구현 목적: VC에 부담을 주지말자 final class TodosDataSource2: NSObject, UITableViewDataSource, UITableViewDelegate { var todoList: [Todo] = [] var tableView: UITableView? = nil // MARK: - 로직을 밖으로 뺄 수 있다 즉 VC에서 클로저로 사용 가능하다. // configureCell 클로저: 셀 구성 로직을 VC에서 정의할 수 있게 위임함 // 매개변수 tableView, indexPath는 외부에서 받아오고 // cellData(todo)는 내부 todoList에서 가져와 주입 var configureCell: ((UITableView, IndexPath, Todo) -&gt; UITableViewCell)? init(todoList: [Todo], tableView: UITableView) { self.todoList = todoList self.tableView = tableView } // MARK: - Register func register&lt;T: UITableViewCell&gt;(cellType: T.Type) { tableView?.register(cellType, forCellReuseIdentifier: T.reuseIdentifier) } // MARK: - UITableView Datasource Methods /// 하나의 섹션에 몇개의 rows가 있냐 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return todoList.count } // 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라 /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 /// - returns: 구성된 UITableViewCell 객체e func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cellData = todoList[indexPath.row] return configureCell?(tableView, indexPath, cellData) ?? UITableViewCell() // MARK: - 로직 -&gt; 함수로 만들어서 매개변수로 활용해보자 /* guard let cell: TodoCell = tableView.dequeueReusableCell(withIdentifier: TodoCell.reuseIdentifier, for: indexPath) as? TodoCell else { return UITableViewCell() } cell.configure(with: cellData) return cell */ } } ViewController import UIKit final class TodosVC2: UIViewController { private lazy var myTableView: UITableView = { let tv = UITableView() // MARK: - 이 부분도 TodosDataSource에 위임 // tv.register(TodoCell.self, forCellReuseIdentifier: TodoCell.reuseIdentifier) return tv }() var todoList: [Todo] = [] var todosDataSource: TodosDataSource2? = nil override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white self.makeUI() self.constraints() self.todoList = Todo.getDumies() self.setCustomDataSource() } private func setCustomDataSource() { // 1️⃣ dataSource 생성 todosDataSource = TodosDataSource2(todoList: todoList, tableView: myTableView) // MARK: - 여기에 클로저 추가 self.todosDataSource?.configureCell = { mytableView, indexPath, cellData in guard let cell: TodoCell = self.myTableView.dequeueReusableCell(withIdentifier: TodoCell.reuseIdentifier, for: indexPath) as? TodoCell else { return UITableViewCell() } cell.configure(with: cellData) cell.isDoneChange = { [weak self] id, isDone in guard let self = self else { return } if let foundIndex = self.todoList.firstIndex( where: {$0.id == id} ) { self.todosDataSource?.todoList[foundIndex].isDone = isDone DispatchQueue.main.async { self.myTableView.reloadRows(at: [IndexPath(row: foundIndex, section: 0)], with: .fade) } } } return cell } // 2️⃣ register 호출 (이 시점에 tableView는 이미 존재함) todosDataSource?.register(cellType: TodoCell.self) // 3️⃣ 연결 myTableView.dataSource = todosDataSource } private func makeUI() { [myTableView].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } } private func constraints() { NSLayoutConstraint.activate([ myTableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor), myTableView.leadingAnchor.constraint(equalTo: view.leadingAnchor), myTableView.trailingAnchor.constraint(equalTo: view.trailingAnchor), myTableView.bottomAnchor.constraint(equalTo: view.bottomAnchor) ]) } }]]></summary></entry><entry><title type="html">[Combine] 예제 3 &amp;amp; UIKit Validation</title><link href="http://localhost:4000/Combine-example-3/" rel="alternate" type="text/html" title="[Combine] 예제 3 &amp;amp; UIKit Validation" /><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>http://localhost:4000/%5BCombine%5D-example%203</id><content type="html" xml:base="http://localhost:4000/Combine-example-3/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<table>
  <tr>
    <td><img src="/assets/img/2025-07-19-%5BCombine%5D-example%203/image-20250719142349430.png" alt="커스텀셀1" width="100%" /></td>
    <td><img src="/assets/img/2025-07-19-%5BCombine%5D-example%203/image-20250719142401972.png" alt="커스텀셀" width="100%" /></td>
      <!-- <td><img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView5/image-20250511181826302.png" alt="커스텀셀" width="100%"></td> -->
  </tr>
  <tr>
    <td style="text-align:center;">Main.storyboard</td>
    <td style="text-align:center;">ValidationViewController.swift/storyboard</td>
    <!-- <td style="text-align:center;">Code 커스텀 셀</td> -->
  </tr>
</table>

<h4 id="1-mainstoryboard에-연결된-viewcontrollerswift">1. Main.storyboard에 연결된 ViewController.swift</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">CombineCocoa</span>

<span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="c1">// Combine의 구독을 저장하는 Set</span>
    <span class="c1">// VC가 해제되면 subscriptions 프로퍼티도 함께 메모리에서 해제되고, 그 안에 저장된 구독들도 함께 해제되어 메모리 누수를 방지한다</span>
    <span class="c1">// 구독 찌꺼기 담는 통: VC가 메모리에서 해제되면 VC에서 사용된 구독 찌꺼기가 담긴다</span>
    <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">navToNumbersBtn</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">navToNumberSwiftUIBtn</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">navToValidationUIKitBtn</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
       
        <span class="n">navToNumbersBtn</span>
            <span class="o">.</span><span class="n">tapPublisher</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- "</span><span class="p">)</span>

                <span class="k">let</span> <span class="nv">numbersVC</span> <span class="o">=</span> <span class="kt">NumbersViewController</span><span class="o">.</span><span class="nf">instantiate</span><span class="p">(</span><span class="s">"Numbers"</span><span class="p">)</span>
                <span class="k">self</span><span class="o">.</span><span class="n">navigationController</span><span class="p">?</span><span class="o">.</span><span class="nf">pushViewController</span><span class="p">(</span><span class="n">numbersVC</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
                
            <span class="p">})</span>
            <span class="c1">// 구독에 대한 찌꺼기가 담긴다</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        <span class="n">navToNumberSwiftUIBtn</span>
            <span class="o">.</span><span class="n">tapPublisher</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- "</span><span class="p">)</span>

                <span class="k">let</span> <span class="nv">numbersVC</span> <span class="o">=</span> <span class="kt">NumbersView</span><span class="p">()</span><span class="o">.</span><span class="nf">getContainerVC</span><span class="p">()</span>
                <span class="k">self</span><span class="o">.</span><span class="n">navigationController</span><span class="p">?</span><span class="o">.</span><span class="nf">pushViewController</span><span class="p">(</span><span class="n">numbersVC</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
                
                <span class="cm">/*
                let testVC = TestView().getContainerVC()
                self.navigationController?.pushViewController(testVC, animated: true)
                 */</span>
                
            <span class="p">})</span>
            <span class="c1">// 구독에 대한 찌꺼기가 담긴다</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        <span class="n">navToValidationUIKitBtn</span>
            <span class="o">.</span><span class="n">tapPublisher</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">let</span> <span class="nv">vc</span> <span class="o">=</span> <span class="kt">ValidationExampleViewController</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="s">"ValidationExampleViewController"</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
                <span class="k">self</span><span class="o">.</span><span class="n">navigationController</span><span class="p">?</span><span class="o">.</span><span class="nf">pushViewController</span><span class="p">(</span><span class="n">vc</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="c1">// 구독에 대한 찌꺼기가 담긴다</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="2-validationviewcontrollerstoryboard에-연결된-validationviewcontrollerswift">2. ValidationViewController.storyboard에 연결된 ValidationViewController.swift</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">class</span> <span class="kt">ValidationExampleViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">userNameTF</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">userNameValidationLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">passwordTF</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">passwordValidationLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
     
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">loginButton</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="3-validationvc를-편하게-만드는-헬퍼메스드-구현">3. ValidationVC를 편하게 만드는 헬퍼메스드 구현</h4>

<h4 id="validationexampleviewcontrollerswift">ValidationExampleViewController.swift</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">class</span> <span class="kt">ValidationExampleViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">userNameTF</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">userNameValidationLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">passwordTF</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">passwordValidationLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
     
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">loginButton</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - Helper Method</span>
    <span class="c1">// validationExampleVC를 생성하지 않고 만들어주는 역할 - 타입메서드</span>
    <span class="kd">class</span> <span class="kd">func</span> <span class="nf">getInstance</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">ValidationExampleViewController</span> <span class="p">{</span> <span class="c1">// MARK: - 상속을 고료하지 않는 경우면 static func</span>
        <span class="kt">ValidationExampleViewController</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="s">"ValidationExampleViewController"</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - 조금 더 제네릭하게 한다면</span>
<span class="kd">extension</span> <span class="kt">UIViewController</span> <span class="p">{</span><span class="c1">/// nib 파일 이름이 클래스명과 동일할 때 해당 ViewController 인스턴스를 생성합니다.</span>
    <span class="c1">///</span>
    <span class="c1">/// - Returns: nibName과 동일한 이름의 UIViewController 인스턴스</span>
    <span class="c1">/// - Example:</span>
    <span class="c1">/// ```swift</span>
    <span class="c1">/// let vc = MyViewController.instantiateFromNib()</span>
    <span class="c1">/// ```</span>
    <span class="c1">///Self: 호출하는 타입 자신 (예: MyViewController)</span>
    <span class="c1">/// String(describing: Self.self): "MyViewController" → nib 파일 이름과 일치</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">instantiateFromNib</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Self</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="k">self</span><span class="p">),</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="viewcontroller">ViewController</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">navToValidationUIKitBtn</span>
    <span class="o">.</span><span class="n">tapPublisher</span>
    <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span>
        
        <span class="c1">// 원래 방식</span>
        <span class="c1">// let vc = ValidationExampleViewController(nibName: "ValidationExampleViewController", bundle: nil)</span>
        
        <span class="c1">// Helper Method 방식</span>
        <span class="c1">// let vc = ValidationExampleViewController.getInstance()</span>
        
        <span class="c1">// Helper Method2 방식</span>
        <span class="k">let</span> <span class="nv">vc</span> <span class="o">=</span> <span class="kt">ValidationExampleViewController</span><span class="o">.</span><span class="nf">instantiateFromNib</span><span class="p">()</span>
        <span class="k">self</span><span class="o">.</span><span class="n">navigationController</span><span class="p">?</span><span class="o">.</span><span class="nf">pushViewController</span><span class="p">(</span><span class="n">vc</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="c1">// 구독에 대한 찌꺼기가 담긴다</span>
    <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="3-viewcontrollerswift에서-버튼-추가시마다-outlet-연결을-해야하는데-불편하다">3. ViewController.swift에서 버튼 추가시마다 Outlet 연결을 해야하는데 불편하다</h4>
<ul>
  <li>매번 Outlet 연결 및 tapPublisher연결을 편리하게 만드는법으로 수정해보자</li>
</ul>

<ol>
  <li>기존 Main.storyboard에서 Stack내부의 버튼을 지운다</li>
  <li>크기아 없어도 상관없다. 아이템을 넣어서 크기를 만들거다</li>
  <li>stackView를 View로 감쌌는데 스택뷰를 밖으로 빼고 view를 지운다</li>
  <li>StackView를 Frame Layout에 드래그하고 exuql width 설정해준다</li>
  <li>Inspector에서 multiplier를 1로 해준다</li>
  <li>stackView를 ViewController로 가져온다</li>
</ol>

<p><img src="/assets/img/2025-07-19-%5BCombine%5D-example%203/image-20250719153121655.png" alt="이미지" width="100%" /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">CombineCocoa</span>

<span class="kd">enum</span> <span class="kt">ExampleType</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">CaseIterable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">numbersUIKit</span>    <span class="c1">// rawValue: 0</span>
    <span class="k">case</span> <span class="n">numbersSwiftUI</span>  <span class="c1">// 1</span>
    <span class="k">case</span> <span class="n">validationUIKit</span> <span class="c1">// 2</span>
    
    <span class="kd">func</span> <span class="nf">makeButton</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UIButton</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">button</span> <span class="o">=</span> <span class="kt">UIButton</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">system</span><span class="p">)</span>
        <span class="n">button</span><span class="o">.</span><span class="n">configuration</span> <span class="o">=</span> <span class="o">.</span><span class="nf">filled</span><span class="p">()</span>
        <span class="n">button</span><span class="o">.</span><span class="nf">setTitle</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="k">self</span><span class="p">),</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">button</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rawValue</span>
        <span class="k">return</span> <span class="n">button</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">makeVC</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UIViewController</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">numbersUIKit</span><span class="p">:</span>
            <span class="kt">NumbersViewController</span><span class="o">.</span><span class="nf">instantiate</span><span class="p">(</span><span class="s">"Numbers"</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">numbersSwiftUI</span><span class="p">:</span>
            <span class="kt">NumbersView</span><span class="p">()</span><span class="o">.</span><span class="nf">getContainerVC</span><span class="p">()</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">validationUIKit</span><span class="p">:</span>
            <span class="kt">ValidationExampleViewController</span><span class="o">.</span><span class="nf">instantiateFromNib</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="c1">// Combine의 구독을 저장하는 Set</span>
    <span class="c1">// VC가 해제되면 subscriptions 프로퍼티도 함께 메모리에서 해제되고, 그 안에 저장된 구독들도 함께 해제되어 메모리 누수를 방지한다</span>
    <span class="c1">// 구독 찌꺼기 담는 통: VC가 메모리에서 해제되면 VC에서 사용된 구독 찌꺼기가 담긴다</span>
    <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">buttonContainerStackView</span><span class="p">:</span> <span class="kt">UIStackView</span><span class="o">!</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        
        <span class="k">let</span> <span class="nv">exampleTypes</span><span class="p">:</span> <span class="p">[</span><span class="kt">ExampleType</span><span class="p">]</span> <span class="o">=</span> <span class="kt">ExampleType</span><span class="o">.</span><span class="n">allCases</span>
        
        <span class="n">exampleTypes</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">aType</span> <span class="k">in</span>
            <span class="k">let</span> <span class="nv">button</span> <span class="o">=</span> <span class="n">aType</span><span class="o">.</span><span class="nf">makeButton</span><span class="p">()</span>
            <span class="n">button</span>
                <span class="o">.</span><span class="n">tapPublisher</span>
                <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="k">in</span> <span class="c1">// 클로저 내에서 self를 사용하니까 강한참조를 뺴기 위해 캡처리스트로 약하게 해준다</span>
                    <span class="c1">// 각 타입마다 뷰컨트롤러 종류가 다르다(storyboard, swiftUI, xib)</span>
                    <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
                    <span class="k">let</span> <span class="nv">vc</span> <span class="o">=</span> <span class="n">aType</span><span class="o">.</span><span class="nf">makeVC</span><span class="p">()</span>
                    <span class="k">self</span><span class="o">.</span><span class="n">navigationController</span><span class="p">?</span><span class="o">.</span><span class="nf">pushViewController</span><span class="p">(</span><span class="n">vc</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
                <span class="p">})</span>
                <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
            
            <span class="n">buttonContainerStackView</span><span class="o">.</span><span class="nf">addArrangedSubview</span><span class="p">(</span><span class="n">button</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/img/2025-07-19-%5BCombine%5D-example%203/image-20250719153211663.png" alt="이미지" width="85%" /></p>]]></content><author><name>Dong Hyeon</name></author><category term="Combine" /><summary type="html"><![CDATA[Main.storyboard ValidationViewController.swift/storyboard 1. Main.storyboard에 연결된 ViewController.swift import UIKit import Combine import CombineCocoa class ViewController: UIViewController { // Combine의 구독을 저장하는 Set // VC가 해제되면 subscriptions 프로퍼티도 함께 메모리에서 해제되고, 그 안에 저장된 구독들도 함께 해제되어 메모리 누수를 방지한다 // 구독 찌꺼기 담는 통: VC가 메모리에서 해제되면 VC에서 사용된 구독 찌꺼기가 담긴다 var subscriptions = Set&lt;AnyCancellable&gt;() @IBOutlet weak var navToNumbersBtn: UIButton! @IBOutlet weak var navToNumberSwiftUIBtn: UIButton! @IBOutlet weak var navToValidationUIKitBtn: UIButton! override func viewDidLoad() { super.viewDidLoad() navToNumbersBtn .tapPublisher .sink(receiveValue: { print(#fileID, #function, #line, "- ") let numbersVC = NumbersViewController.instantiate("Numbers") self.navigationController?.pushViewController(numbersVC, animated: true) }) // 구독에 대한 찌꺼기가 담긴다 .store(in: &amp;subscriptions) navToNumberSwiftUIBtn .tapPublisher .sink(receiveValue: { print(#fileID, #function, #line, "- ") let numbersVC = NumbersView().getContainerVC() self.navigationController?.pushViewController(numbersVC, animated: true) /* let testVC = TestView().getContainerVC() self.navigationController?.pushViewController(testVC, animated: true) */ }) // 구독에 대한 찌꺼기가 담긴다 .store(in: &amp;subscriptions) navToValidationUIKitBtn .tapPublisher .sink(receiveValue: { let vc = ValidationExampleViewController(nibName: "ValidationExampleViewController", bundle: nil) self.navigationController?.pushViewController(vc, animated: true) }) // 구독에 대한 찌꺼기가 담긴다 .store(in: &amp;subscriptions) } } 2. ValidationViewController.storyboard에 연결된 ValidationViewController.swift import UIKit class ValidationExampleViewController: UIViewController { @IBOutlet weak var userNameTF: UITextField! @IBOutlet weak var userNameValidationLabel: UILabel! @IBOutlet weak var passwordTF: UITextField! @IBOutlet weak var passwordValidationLabel: UILabel! @IBOutlet weak var loginButton: UIButton! override func viewDidLoad() { super.viewDidLoad() } } 3. ValidationVC를 편하게 만드는 헬퍼메스드 구현 ValidationExampleViewController.swift import UIKit class ValidationExampleViewController: UIViewController { @IBOutlet weak var userNameTF: UITextField! @IBOutlet weak var userNameValidationLabel: UILabel! @IBOutlet weak var passwordTF: UITextField! @IBOutlet weak var passwordValidationLabel: UILabel! @IBOutlet weak var loginButton: UIButton! override func viewDidLoad() { super.viewDidLoad() } // MARK: - Helper Method // validationExampleVC를 생성하지 않고 만들어주는 역할 - 타입메서드 class func getInstance() -&gt; ValidationExampleViewController { // MARK: - 상속을 고료하지 않는 경우면 static func ValidationExampleViewController(nibName: "ValidationExampleViewController", bundle: nil) } } // MARK: - 조금 더 제네릭하게 한다면 extension UIViewController {/// nib 파일 이름이 클래스명과 동일할 때 해당 ViewController 인스턴스를 생성합니다. /// /// - Returns: nibName과 동일한 이름의 UIViewController 인스턴스 /// - Example: /// ```swift /// let vc = MyViewController.instantiateFromNib() /// ``` ///Self: 호출하는 타입 자신 (예: MyViewController) /// String(describing: Self.self): "MyViewController" → nib 파일 이름과 일치 static func instantiateFromNib() -&gt; Self { return Self(nibName: String(describing: Self.self), bundle: nil) } } ViewController navToValidationUIKitBtn .tapPublisher .sink(receiveValue: { // 원래 방식 // let vc = ValidationExampleViewController(nibName: "ValidationExampleViewController", bundle: nil) // Helper Method 방식 // let vc = ValidationExampleViewController.getInstance() // Helper Method2 방식 let vc = ValidationExampleViewController.instantiateFromNib() self.navigationController?.pushViewController(vc, animated: true) }) // 구독에 대한 찌꺼기가 담긴다 .store(in: &amp;subscriptions) 3. ViewController.swift에서 버튼 추가시마다 Outlet 연결을 해야하는데 불편하다 매번 Outlet 연결 및 tapPublisher연결을 편리하게 만드는법으로 수정해보자 기존 Main.storyboard에서 Stack내부의 버튼을 지운다 크기아 없어도 상관없다. 아이템을 넣어서 크기를 만들거다 stackView를 View로 감쌌는데 스택뷰를 밖으로 빼고 view를 지운다 StackView를 Frame Layout에 드래그하고 exuql width 설정해준다 Inspector에서 multiplier를 1로 해준다 stackView를 ViewController로 가져온다 import UIKit import Combine import CombineCocoa enum ExampleType: Int, CaseIterable { case numbersUIKit // rawValue: 0 case numbersSwiftUI // 1 case validationUIKit // 2 func makeButton() -&gt; UIButton { let button = UIButton(type: .system) button.configuration = .filled() button.setTitle(String(describing: self), for: .normal) button.tag = self.rawValue return button } func makeVC() -&gt; UIViewController { switch self { case .numbersUIKit: NumbersViewController.instantiate("Numbers") case .numbersSwiftUI: NumbersView().getContainerVC() case .validationUIKit: ValidationExampleViewController.instantiateFromNib() } } } class ViewController: UIViewController { // Combine의 구독을 저장하는 Set // VC가 해제되면 subscriptions 프로퍼티도 함께 메모리에서 해제되고, 그 안에 저장된 구독들도 함께 해제되어 메모리 누수를 방지한다 // 구독 찌꺼기 담는 통: VC가 메모리에서 해제되면 VC에서 사용된 구독 찌꺼기가 담긴다 var subscriptions = Set&lt;AnyCancellable&gt;() @IBOutlet weak var buttonContainerStackView: UIStackView! override func viewDidLoad() { super.viewDidLoad() let exampleTypes: [ExampleType] = ExampleType.allCases exampleTypes.forEach { aType in let button = aType.makeButton() button .tapPublisher .sink(receiveValue: { [weak self] in // 클로저 내에서 self를 사용하니까 강한참조를 뺴기 위해 캡처리스트로 약하게 해준다 // 각 타입마다 뷰컨트롤러 종류가 다르다(storyboard, swiftUI, xib) guard let self = self else { return } let vc = aType.makeVC() self.navigationController?.pushViewController(vc, animated: true) }) .store(in: &amp;subscriptions) buttonContainerStackView.addArrangedSubview(button) } } }]]></summary></entry><entry><title type="html">[Combine] 예제 2 &amp;amp; MVVM[SwiftUI/UIKit]</title><link href="http://localhost:4000/Combine-example-2/" rel="alternate" type="text/html" title="[Combine] 예제 2 &amp;amp; MVVM[SwiftUI/UIKit]" /><published>2025-07-18T00:00:00+00:00</published><updated>2025-07-18T00:00:00+00:00</updated><id>http://localhost:4000/%5BCombine%5D-example%202</id><content type="html" xml:base="http://localhost:4000/Combine-example-2/"><![CDATA[<!-- https://www.youtube.com/watch?v=sBybUm8yVbI&list=PLgOlaPUIbynpuq9GKCwAedgWkkPm2Wo8v&index=18 -->

<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h4 id="1-swiftui-mvvm--combine">1. SwiftUI MVVM + Combine</h4>
<h4 id="numbersviewswift">NumbersView.swift</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="cm">/*
 @StateObject
 - 객체를 직접 생성 및 소유한다
 - 뷰가 다시 그려져도 객체는 재생성되지않는다
 - 해당 뷰에서 객체롤 초기화 및 관리를 위해 사용
 - 상태 유지에 효율적
 - 루트뷰에서 주로 사용
 - 객체를 초기화하고 SwiftUI 뷰 상태에 저장하는데 사용하는 속성 래퍼
 - 뷰가 존재하는 한 객체가 저장되고 뷰와 함께 삭제됨을 의미한다
 - 일반적으로 @StateObject를 사용하는 것은 하나의 뷰가 아닌 여러 뷰에 필요한 클래스 객체에 실용적이다
 
 @ObservedObject
 - 상태 변경시 뷰를 다시 생성
 - 객체를 외부에서 주입받음
 - 뷰가 다시 그려지면 객체도 다시 주입됨
 - 상위 뷰에서 객체를 전달받아 사용시
 - 객체가 자주 재생성됨
 - 서브뷰 또는 전달받는뷰
 
 공통점
 - observable 객체를 구독하는 property wrapper
 - 구독중인 observable 객체가 변경되면 뷰에 업데이트 시켜주는 기능
 
 차이점
 - 둘다 observableObject를 구독하여 값이 변경되면 뷰에 반영하는 property wrapper
 - 상태 변경시 @ObservedObject는 뷰를 다시 생성하지만 @StateObject는 다시 생성하지않고 동일 뷰가 사용(효율)
 - 기본적으로 @StateObject를 사용하되, 해당 프로퍼티를 subView에 주입해야 한다면 @ObservedObject로 선언하여 사용할 것
 - subView에 @StateObject를 주입하면 해당 @StateObject의 수명 주기가 두 곳에서 관리가 되므로 의존성을 줄이기 위해 @ObservedObject를 사용
 
 - https://hackernoon.com/lang/ko/Swiftuis-5-주요-속성-래퍼-및-이를-효과적으로-사용하는-방법
 - https://ios-development.tistory.com/1160
 */</span>

<span class="kd">struct</span> <span class="kt">NumbersView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    
    <span class="kd">@StateObject</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">NumbersVM</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">trailing</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">TextField</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="nv">text</span><span class="p">:</span> <span class="n">$viewModel</span><span class="o">.</span><span class="n">number1</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">textFieldStyle</span><span class="p">(</span><span class="kt">RoundedBorderTextFieldStyle</span><span class="p">())</span>
            <span class="kt">TextField</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="nv">text</span><span class="p">:</span> <span class="n">$viewModel</span><span class="o">.</span><span class="n">number2</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">textFieldStyle</span><span class="p">(</span><span class="kt">RoundedBorderTextFieldStyle</span><span class="p">())</span>
            <span class="kt">TextField</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="nv">text</span><span class="p">:</span> <span class="n">$viewModel</span><span class="o">.</span><span class="n">number3</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">textFieldStyle</span><span class="p">(</span><span class="kt">RoundedBorderTextFieldStyle</span><span class="p">())</span>
            <span class="kt">TextField</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="nv">text</span><span class="p">:</span> <span class="n">$viewModel</span><span class="o">.</span><span class="n">number4</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">textFieldStyle</span><span class="p">(</span><span class="kt">RoundedBorderTextFieldStyle</span><span class="p">())</span>
            <span class="kt">Divider</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">resultValue</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">fontWeight</span><span class="p">(</span><span class="o">.</span><span class="n">bold</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">foregroundStyle</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">padding</span><span class="p">(</span><span class="o">.</span><span class="n">horizontal</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">,</span> <span class="nv">maxHeight</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">yellow</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#Preview {</span>
    <span class="kt">NumbersView</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="numbersviewmodelswift">NumbersViewModel.swift</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">UIKit</span>

<span class="cm">/*
 
 비즈니스 로직
 - 데이터 상태를 VM이 가지고 있다
 - 즉 완성된 데이터를 VM이 가지고 있다
 
 2가지 상태의 데이터
 - 뷰모델로 들어오는 Input
 - 뷰모델로 나가는 Output == 비즈니스 로직을 타서 완성된 데이터가 뷰모델에서 나가는 것
 
 https://hackernoon.com/lang/ko/Swiftuis-5-주요-속성-래퍼-및-이를-효과적으로-사용하는-방법
 
 */</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">NumbersVM</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
    
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="c1">// MARK: - Input: 뷰모델로 들어오는 데이터</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number1</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number2</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number3</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number4</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    
    <span class="c1">// MARK: - Output: 뷰모델로 나가는 데이터</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">resultValue</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- "</span><span class="p">)</span>
        
        <span class="kt">Publishers</span>
            <span class="o">.</span><span class="kt">CombineLatest4</span><span class="p">(</span><span class="n">$number1</span><span class="p">,</span>
                            <span class="n">$number2</span><span class="p">,</span>
                            <span class="n">$number3</span><span class="p">,</span>
                            <span class="n">$number4</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">testValue1</span><span class="p">,</span> <span class="n">testValue2</span><span class="p">,</span> <span class="n">testValue3</span><span class="p">,</span> <span class="n">testValue4</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
                <span class="k">return</span>  <span class="n">testValue1</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue2</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue3</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue4</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
            <span class="c1">// resultValue에 직접 꽂을건데 객체이므로 자기자신의 속성으로</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">resultValue</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
            <span class="cm">/*
             assign대신 이렇게 해도됨
            .sink { value in
                self.resultValue = value
            }
             */</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h4 id="2-numbersviewmodel-리팩토링">2. NumbersViewModel 리팩토링</h4>
<ul>
  <li>로직을 따로 뺴자</li>
  <li>1번과 2번방식을 추천</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  NumbersVM.swift</span>
<span class="c1">//  CombineTutorial-example</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 7/18/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">UIKit</span>

<span class="cm">/*
 
 비즈니스 로직
 - 데이터 상태를 VM이 가지고 있다
 - 즉 완성된 데이터를 VM이 가지고 있다
 
 2가지 상태의 데이터
 - 뷰모델로 들어오는 Input
 - 뷰모델로 나가는 Output == 비즈니스 로직을 타서 완성된 데이터가 뷰모델에서 나가는 것
 
 https://hackernoon.com/lang/ko/Swiftuis-5-주요-속성-래퍼-및-이를-효과적으로-사용하는-방법
 
 */</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">NumbersVM</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
    
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">resultPublisher</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="o">=</span>
        <span class="kt">Publishers</span>
            <span class="o">.</span><span class="kt">CombineLatest4</span><span class="p">(</span><span class="n">$number1</span><span class="p">,</span>
                            <span class="n">$number2</span><span class="p">,</span>
                            <span class="n">$number3</span><span class="p">,</span>
                            <span class="n">$number4</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">testValue1</span><span class="p">,</span> <span class="n">testValue2</span><span class="p">,</span> <span class="n">testValue3</span><span class="p">,</span> <span class="n">testValue4</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
                <span class="k">return</span>  <span class="n">testValue1</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue2</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue3</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue4</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
            <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">resultPublisher2</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kt">Publishers</span>
            <span class="o">.</span><span class="kt">CombineLatest4</span><span class="p">(</span><span class="n">$number1</span><span class="p">,</span>
                           <span class="n">$number2</span><span class="p">,</span>
                           <span class="n">$number3</span><span class="p">,</span>
                           <span class="n">$number4</span><span class="p">)</span>
           <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">testValue1</span><span class="p">,</span> <span class="n">testValue2</span><span class="p">,</span> <span class="n">testValue3</span><span class="p">,</span> <span class="n">testValue4</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
               <span class="k">return</span>  <span class="n">testValue1</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                       <span class="n">testValue2</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                       <span class="n">testValue3</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                       <span class="n">testValue4</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span>
           <span class="p">}</span>
           <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
           <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>
        
    
    <span class="c1">// MARK: - Input: 뷰모델로 들어오는 데이터</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number1</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number2</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number3</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number4</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    
    <span class="c1">// MARK: - Output: 뷰모델로 나가는 데이터</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">resultValue</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- "</span><span class="p">)</span>
        
        <span class="c1">// 1번 방식</span>
        <span class="nf">setupBinding</span><span class="p">()</span>
        
        <span class="c1">// 2번 방식</span>
        <span class="n">resultPublisher</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">resultValue</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        <span class="c1">// 3번 방식</span>
        <span class="n">resultPublisher2</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">resultValue</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">setupBinding</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">Publishers</span>
            <span class="o">.</span><span class="kt">CombineLatest4</span><span class="p">(</span><span class="n">$number1</span><span class="p">,</span>
                            <span class="n">$number2</span><span class="p">,</span>
                            <span class="n">$number3</span><span class="p">,</span>
                            <span class="n">$number4</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">testValue1</span><span class="p">,</span> <span class="n">testValue2</span><span class="p">,</span> <span class="n">testValue3</span><span class="p">,</span> <span class="n">testValue4</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
                <span class="k">return</span>  <span class="n">testValue1</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue2</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue3</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue4</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
            <span class="c1">// resultValue에 직접 꽂을건데 객체이므로 자기자신의 속성으로</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">resultValue</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
            <span class="cm">/*
             assign대신 이렇게 해도됨
            .sink { value in
                self.resultValue = value
            }
             */</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h4 id="2-uikit-mvvm--combine">2. UIKit MVVM + Combine</h4>
<h4 id="기존-numbersviewcontrollerswift">기존 NumbersViewController.swift</h4>
<ul>
  <li>기존 코드는 ViewController에 로직이 들어있으니 mvvm으로 만들어보자.<br />
```swift<br />
import UIKit<br />
import Combine<br />
import CombineCocoa</li>
</ul>

<p>final class NumbersViewController: UIViewController {<br />
    @IBOutlet weak var number1: UITextField!<br />
    @IBOutlet weak var number2: UITextField!<br />
    @IBOutlet weak var number3: UITextField!<br />
    @IBOutlet weak var result: UILabel!<br />
    var subscriptions = Set<AnyCancellable>()
    private var viewModel: NumbersVM = NumbersVM()</AnyCancellable></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override func viewDidLoad() {
    super.viewDidLoad()
    
    // MARK: - ViewModel에 Input 넣어주기
    
    
    Publishers
        .CombineLatest3(number1.textPublisher,
                       number2.textPublisher,
                       number3.textPublisher)
        .map { testValue1, testValue2, testValue3 -&gt; Int in
            return  testValue1.getNumber() +
                    testValue2.getNumber() +
                    testValue3.getNumber()
        }
        /*
        .sink { value in
            print(#fileID, #function, #line, "- value: \(value)")
        }
         */
        .map { String($0) }
        .assign(to: \.text, on: result)
        .store(in: &amp;subscriptions)
} } ```
</code></pre></div></div>

<h4 id="numbersviewcontrollerswift">NumbersViewController.swift</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">CombineCocoa</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">NumbersViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">number1</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">number2</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">number3</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">NumbersVM</span> <span class="o">=</span> <span class="kt">NumbersVM</span><span class="p">()</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        
        <span class="c1">// MARK: - ViewModel에 Input 넣어주기</span>
        <span class="n">number1</span><span class="o">.</span><span class="n">textPublisher</span>
            <span class="o">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">number1</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span> <span class="c1">// viewModel이 가지고 있는 number1 속성에 꽂는다</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        <span class="n">number2</span><span class="o">.</span><span class="n">textPublisher</span>
            <span class="o">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">number2</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        <span class="n">number3</span><span class="o">.</span><span class="n">textPublisher</span>
            <span class="o">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">number3</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        <span class="c1">// MARK: - ViewModel에서 나오는 데이터 바인딩하기</span>
        <span class="n">viewModel</span><span class="o">.</span><span class="n">$resultValue</span>
            <span class="o">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">result</span><span class="p">)</span> <span class="c1">// result.text에 resultValue를 해줘라</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        
<span class="c1">//        Publishers</span>
<span class="c1">//            .CombineLatest3(number1.textPublisher,</span>
<span class="c1">//                           number2.textPublisher,</span>
<span class="c1">//                           number3.textPublisher)</span>
<span class="c1">//            .map { testValue1, testValue2, testValue3 -&gt; Int in</span>
<span class="c1">//                return  testValue1.getNumber() +</span>
<span class="c1">//                        testValue2.getNumber() +</span>
<span class="c1">//                        testValue3.getNumber()</span>
<span class="c1">//            }</span>
<span class="c1">//            /*</span>
<span class="c1">//            .sink { value in</span>
<span class="c1">//                print(#fileID, #function, #line, "- value: \(value)")</span>
<span class="c1">//            }</span>
<span class="c1">//             */</span>
<span class="c1">//            .map { String($0) }</span>
<span class="c1">//            .assign(to: \.text, on: result)</span>
<span class="c1">//            .store(in: &amp;subscriptions)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="numbersvmswift">NumbersVM.swift</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">UIKit</span>

<span class="cm">/*
 
 비즈니스 로직
 - 데이터 상태를 VM이 가지고 있다
 - 즉 완성된 데이터를 VM이 가지고 있다
 
 2가지 상태의 데이터
 - 뷰모델로 들어오는 Input
 - 뷰모델로 나가는 Output == 비즈니스 로직을 타서 완성된 데이터가 뷰모델에서 나가는 것
 
 https://hackernoon.com/lang/ko/Swiftuis-5-주요-속성-래퍼-및-이를-효과적으로-사용하는-방법
 
 */</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">NumbersVM</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
    
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">resultPublisher</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="o">=</span>
        <span class="kt">Publishers</span>
            <span class="o">.</span><span class="kt">CombineLatest4</span><span class="p">(</span><span class="n">$number1</span><span class="p">,</span>
                            <span class="n">$number2</span><span class="p">,</span>
                            <span class="n">$number3</span><span class="p">,</span>
                            <span class="n">$number4</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">testValue1</span><span class="p">,</span> <span class="n">testValue2</span><span class="p">,</span> <span class="n">testValue3</span><span class="p">,</span> <span class="n">testValue4</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
                <span class="k">return</span>  <span class="n">testValue1</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue2</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue3</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue4</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
            <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">resultPublisher2</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kt">Publishers</span>
            <span class="o">.</span><span class="kt">CombineLatest4</span><span class="p">(</span><span class="n">$number1</span><span class="p">,</span>
                           <span class="n">$number2</span><span class="p">,</span>
                           <span class="n">$number3</span><span class="p">,</span>
                           <span class="n">$number4</span><span class="p">)</span>
           <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">testValue1</span><span class="p">,</span> <span class="n">testValue2</span><span class="p">,</span> <span class="n">testValue3</span><span class="p">,</span> <span class="n">testValue4</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
               <span class="k">return</span>  <span class="n">testValue1</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                       <span class="n">testValue2</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                       <span class="n">testValue3</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                       <span class="n">testValue4</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span>
           <span class="p">}</span>
           <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
           <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>
        
    
    <span class="c1">// MARK: - Input: 뷰모델로 들어오는 데이터</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number1</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number2</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number3</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">number4</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    
    <span class="c1">// MARK: - Output: 뷰모델로 나가는 데이터</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">resultValue</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- "</span><span class="p">)</span>
        
        <span class="c1">// 1번 방식</span>
        <span class="nf">setupBinding</span><span class="p">()</span>
        
        <span class="c1">// 2번 방식</span>
        <span class="cm">/*
        resultPublisher
            .assign(to: \.resultValue, on: self)
            .store(in: &amp;subscriptions)
         */</span>
        
        <span class="c1">// 3번 방식</span>
        <span class="cm">/*
        resultPublisher2
            .assign(to: \.resultValue, on: self)
            .store(in: &amp;subscriptions)
         */</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">setupBinding</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">Publishers</span>
            <span class="o">.</span><span class="kt">CombineLatest4</span><span class="p">(</span><span class="n">$number1</span><span class="p">,</span>
                            <span class="n">$number2</span><span class="p">,</span>
                            <span class="n">$number3</span><span class="p">,</span>
                            <span class="n">$number4</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">testValue1</span><span class="p">,</span> <span class="n">testValue2</span><span class="p">,</span> <span class="n">testValue3</span><span class="p">,</span> <span class="n">testValue4</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
                <span class="k">return</span>  <span class="n">testValue1</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue2</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue3</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span> <span class="o">+</span>
                        <span class="n">testValue4</span><span class="o">.</span><span class="nf">getNumber</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
            <span class="c1">// resultValue에 직접 꽂을건데 객체이므로 자기자신의 속성으로</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">resultValue</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
            <span class="cm">/*
             assign대신 이렇게 해도됨
            .sink { value in
                self.resultValue = value
            }
             */</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="Combine" /><summary type="html"><![CDATA[1. SwiftUI MVVM + Combine NumbersView.swift import SwiftUI /* @StateObject - 객체를 직접 생성 및 소유한다 - 뷰가 다시 그려져도 객체는 재생성되지않는다 - 해당 뷰에서 객체롤 초기화 및 관리를 위해 사용 - 상태 유지에 효율적 - 루트뷰에서 주로 사용 - 객체를 초기화하고 SwiftUI 뷰 상태에 저장하는데 사용하는 속성 래퍼 - 뷰가 존재하는 한 객체가 저장되고 뷰와 함께 삭제됨을 의미한다 - 일반적으로 @StateObject를 사용하는 것은 하나의 뷰가 아닌 여러 뷰에 필요한 클래스 객체에 실용적이다 @ObservedObject - 상태 변경시 뷰를 다시 생성 - 객체를 외부에서 주입받음 - 뷰가 다시 그려지면 객체도 다시 주입됨 - 상위 뷰에서 객체를 전달받아 사용시 - 객체가 자주 재생성됨 - 서브뷰 또는 전달받는뷰 공통점 - observable 객체를 구독하는 property wrapper - 구독중인 observable 객체가 변경되면 뷰에 업데이트 시켜주는 기능 차이점 - 둘다 observableObject를 구독하여 값이 변경되면 뷰에 반영하는 property wrapper - 상태 변경시 @ObservedObject는 뷰를 다시 생성하지만 @StateObject는 다시 생성하지않고 동일 뷰가 사용(효율) - 기본적으로 @StateObject를 사용하되, 해당 프로퍼티를 subView에 주입해야 한다면 @ObservedObject로 선언하여 사용할 것 - subView에 @StateObject를 주입하면 해당 @StateObject의 수명 주기가 두 곳에서 관리가 되므로 의존성을 줄이기 위해 @ObservedObject를 사용 - https://hackernoon.com/lang/ko/Swiftuis-5-주요-속성-래퍼-및-이를-효과적으로-사용하는-방법 - https://ios-development.tistory.com/1160 */ struct NumbersView: View { @StateObject private var viewModel = NumbersVM() var body: some View { VStack(alignment: .trailing) { TextField("", text: $viewModel.number1) .textFieldStyle(RoundedBorderTextFieldStyle()) TextField("", text: $viewModel.number2) .textFieldStyle(RoundedBorderTextFieldStyle()) TextField("", text: $viewModel.number3) .textFieldStyle(RoundedBorderTextFieldStyle()) TextField("", text: $viewModel.number4) .textFieldStyle(RoundedBorderTextFieldStyle()) Divider() Text(viewModel.resultValue) .fontWeight(.bold) .foregroundStyle(.white) } .padding(.horizontal, 100) .frame(maxWidth: .infinity, maxHeight: .infinity) .background(.yellow) } } #Preview { NumbersView() } NumbersViewModel.swift import Combine import UIKit /* 비즈니스 로직 - 데이터 상태를 VM이 가지고 있다 - 즉 완성된 데이터를 VM이 가지고 있다 2가지 상태의 데이터 - 뷰모델로 들어오는 Input - 뷰모델로 나가는 Output == 비즈니스 로직을 타서 완성된 데이터가 뷰모델에서 나가는 것 https://hackernoon.com/lang/ko/Swiftuis-5-주요-속성-래퍼-및-이를-효과적으로-사용하는-방법 */ final class NumbersVM: ObservableObject { private var subscriptions = Set&lt;AnyCancellable&gt;() // MARK: - Input: 뷰모델로 들어오는 데이터 @Published var number1: String = "" @Published var number2: String = "" @Published var number3: String = "" @Published var number4: String = "" // MARK: - Output: 뷰모델로 나가는 데이터 @Published var resultValue: String = "" init() { print(#fileID, #function, #line, "- ") Publishers .CombineLatest4($number1, $number2, $number3, $number4) .map { testValue1, testValue2, testValue3, testValue4 -&gt; Int in return testValue1.getNumber() + testValue2.getNumber() + testValue3.getNumber() + testValue4.getNumber() } .map { String($0) } // resultValue에 직접 꽂을건데 객체이므로 자기자신의 속성으로 .assign(to: \.resultValue, on: self) /* assign대신 이렇게 해도됨 .sink { value in self.resultValue = value } */ .store(in: &amp;subscriptions) } } 2. NumbersViewModel 리팩토링 로직을 따로 뺴자 1번과 2번방식을 추천 // // NumbersVM.swift // CombineTutorial-example // // Created by 김동현 on 7/18/25. // import Combine import UIKit /* 비즈니스 로직 - 데이터 상태를 VM이 가지고 있다 - 즉 완성된 데이터를 VM이 가지고 있다 2가지 상태의 데이터 - 뷰모델로 들어오는 Input - 뷰모델로 나가는 Output == 비즈니스 로직을 타서 완성된 데이터가 뷰모델에서 나가는 것 https://hackernoon.com/lang/ko/Swiftuis-5-주요-속성-래퍼-및-이를-효과적으로-사용하는-방법 */ final class NumbersVM: ObservableObject { private var subscriptions = Set&lt;AnyCancellable&gt;() private lazy var resultPublisher: AnyPublisher&lt;String, Never&gt; = Publishers .CombineLatest4($number1, $number2, $number3, $number4) .map { testValue1, testValue2, testValue3, testValue4 -&gt; Int in return testValue1.getNumber() + testValue2.getNumber() + testValue3.getNumber() + testValue4.getNumber() } .map { String($0) } .eraseToAnyPublisher() private var resultPublisher2: AnyPublisher&lt;String, Never&gt; { Publishers .CombineLatest4($number1, $number2, $number3, $number4) .map { testValue1, testValue2, testValue3, testValue4 -&gt; Int in return testValue1.getNumber() + testValue2.getNumber() + testValue3.getNumber() + testValue4.getNumber() } .map { String($0) } .eraseToAnyPublisher() } // MARK: - Input: 뷰모델로 들어오는 데이터 @Published var number1: String = "" @Published var number2: String = "" @Published var number3: String = "" @Published var number4: String = "" // MARK: - Output: 뷰모델로 나가는 데이터 @Published var resultValue: String = "" init() { print(#fileID, #function, #line, "- ") // 1번 방식 setupBinding() // 2번 방식 resultPublisher .assign(to: \.resultValue, on: self) .store(in: &amp;subscriptions) // 3번 방식 resultPublisher2 .assign(to: \.resultValue, on: self) .store(in: &amp;subscriptions) } private func setupBinding() { Publishers .CombineLatest4($number1, $number2, $number3, $number4) .map { testValue1, testValue2, testValue3, testValue4 -&gt; Int in return testValue1.getNumber() + testValue2.getNumber() + testValue3.getNumber() + testValue4.getNumber() } .map { String($0) } // resultValue에 직접 꽂을건데 객체이므로 자기자신의 속성으로 .assign(to: \.resultValue, on: self) /* assign대신 이렇게 해도됨 .sink { value in self.resultValue = value } */ .store(in: &amp;subscriptions) } } 2. UIKit MVVM + Combine 기존 NumbersViewController.swift 기존 코드는 ViewController에 로직이 들어있으니 mvvm으로 만들어보자. ```swift import UIKit import Combine import CombineCocoa final class NumbersViewController: UIViewController { @IBOutlet weak var number1: UITextField! @IBOutlet weak var number2: UITextField! @IBOutlet weak var number3: UITextField! @IBOutlet weak var result: UILabel! var subscriptions = Set() private var viewModel: NumbersVM = NumbersVM() override func viewDidLoad() { super.viewDidLoad() // MARK: - ViewModel에 Input 넣어주기 Publishers .CombineLatest3(number1.textPublisher, number2.textPublisher, number3.textPublisher) .map { testValue1, testValue2, testValue3 -&gt; Int in return testValue1.getNumber() + testValue2.getNumber() + testValue3.getNumber() } /* .sink { value in print(#fileID, #function, #line, "- value: \(value)") } */ .map { String($0) } .assign(to: \.text, on: result) .store(in: &amp;subscriptions) } } ``` NumbersViewController.swift import UIKit import Combine import CombineCocoa final class NumbersViewController: UIViewController { @IBOutlet weak var number1: UITextField! @IBOutlet weak var number2: UITextField! @IBOutlet weak var number3: UITextField! @IBOutlet weak var result: UILabel! var subscriptions = Set&lt;AnyCancellable&gt;() private var viewModel: NumbersVM = NumbersVM() override func viewDidLoad() { super.viewDidLoad() // MARK: - ViewModel에 Input 넣어주기 number1.textPublisher .compactMap { $0 } .assign(to: \.number1, on: viewModel) // viewModel이 가지고 있는 number1 속성에 꽂는다 .store(in: &amp;subscriptions) number2.textPublisher .compactMap { $0 } .assign(to: \.number2, on: viewModel) .store(in: &amp;subscriptions) number3.textPublisher .compactMap { $0 } .assign(to: \.number3, on: viewModel) .store(in: &amp;subscriptions) // MARK: - ViewModel에서 나오는 데이터 바인딩하기 viewModel.$resultValue .compactMap { $0 } .map { String($0) } .assign(to: \.text, on: result) // result.text에 resultValue를 해줘라 .store(in: &amp;subscriptions) // Publishers // .CombineLatest3(number1.textPublisher, // number2.textPublisher, // number3.textPublisher) // .map { testValue1, testValue2, testValue3 -&gt; Int in // return testValue1.getNumber() + // testValue2.getNumber() + // testValue3.getNumber() // } // /* // .sink { value in // print(#fileID, #function, #line, "- value: \(value)") // } // */ // .map { String($0) } // .assign(to: \.text, on: result) // .store(in: &amp;subscriptions) } } NumbersVM.swift import Combine import UIKit /* 비즈니스 로직 - 데이터 상태를 VM이 가지고 있다 - 즉 완성된 데이터를 VM이 가지고 있다 2가지 상태의 데이터 - 뷰모델로 들어오는 Input - 뷰모델로 나가는 Output == 비즈니스 로직을 타서 완성된 데이터가 뷰모델에서 나가는 것 https://hackernoon.com/lang/ko/Swiftuis-5-주요-속성-래퍼-및-이를-효과적으로-사용하는-방법 */ final class NumbersVM: ObservableObject { private var subscriptions = Set&lt;AnyCancellable&gt;() private lazy var resultPublisher: AnyPublisher&lt;String, Never&gt; = Publishers .CombineLatest4($number1, $number2, $number3, $number4) .map { testValue1, testValue2, testValue3, testValue4 -&gt; Int in return testValue1.getNumber() + testValue2.getNumber() + testValue3.getNumber() + testValue4.getNumber() } .map { String($0) } .eraseToAnyPublisher() private var resultPublisher2: AnyPublisher&lt;String, Never&gt; { Publishers .CombineLatest4($number1, $number2, $number3, $number4) .map { testValue1, testValue2, testValue3, testValue4 -&gt; Int in return testValue1.getNumber() + testValue2.getNumber() + testValue3.getNumber() + testValue4.getNumber() } .map { String($0) } .eraseToAnyPublisher() } // MARK: - Input: 뷰모델로 들어오는 데이터 @Published var number1: String = "" @Published var number2: String = "" @Published var number3: String = "" @Published var number4: String = "" // MARK: - Output: 뷰모델로 나가는 데이터 @Published var resultValue: String = "" init() { print(#fileID, #function, #line, "- ") // 1번 방식 setupBinding() // 2번 방식 /* resultPublisher .assign(to: \.resultValue, on: self) .store(in: &amp;subscriptions) */ // 3번 방식 /* resultPublisher2 .assign(to: \.resultValue, on: self) .store(in: &amp;subscriptions) */ } private func setupBinding() { Publishers .CombineLatest4($number1, $number2, $number3, $number4) .map { testValue1, testValue2, testValue3, testValue4 -&gt; Int in return testValue1.getNumber() + testValue2.getNumber() + testValue3.getNumber() + testValue4.getNumber() } .map { String($0) } // resultValue에 직접 꽂을건데 객체이므로 자기자신의 속성으로 .assign(to: \.resultValue, on: self) /* assign대신 이렇게 해도됨 .sink { value in self.resultValue = value } */ .store(in: &amp;subscriptions) } }]]></summary></entry><entry><title type="html">[Data Structure] 1. 자료구조와 알고리즘</title><link href="http://localhost:4000/Data-Structure-study1/" rel="alternate" type="text/html" title="[Data Structure] 1. 자료구조와 알고리즘" /><published>2025-07-16T00:00:00+00:00</published><updated>2025-07-16T00:00:00+00:00</updated><id>http://localhost:4000/%5BData%20Structure%5D-study1</id><content type="html" xml:base="http://localhost:4000/Data-Structure-study1/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<h2 id="자료구조data-structure">자료구조(Data Structure)</h2>
<!-- 데이터를 효율적으로 저장하고 관리하는 방식을 말한다.  
대량의 데이터를 효율적으로 관리할 수 있는 데이터 구조를 의미한다.  
삽입, 수정, 삭제, 검색, 정렬, 병합, 순회 등 기본 연산을 지원하고   
데이터를 표현하고 조작하는 데 핵심적인 역할을 한다.  
자료구조는 크기 선형 자료구조와 비선형 자료구조로 나누어진다. 
선형 자료구조(데이터를 일렬로 나열하는 구조)
- 배열, 연결리스트, 스택, 큐

비션형 자료구조(데이터를 계층적 또는 복잡한 관계로 연결하는 구조)
- 트리, 그래프
-->
<p>자료구조는 데이터를 효율적으로 저장하고 관리하는 방식입니다.  <br />
대량의 데이터를 다룰 때 삽입, 삭제, 검색, 정렬, 순회 같은 기본 연산을 효율적으로 처리하도록 도와줍니다.  <br />
자료구조는 크게 두 가지로 나누어집니다:</p>
<ul>
  <li>선형 자료구조: 배열, 연결 리스트, 스택, 큐처럼 데이터를 순서대로 나열하는 구조</li>
  <li>비선형 자료구조: 트리, 그래프처럼 계층적이거나 복잡한 관계를 표현하는 구조</li>
</ul>

<h2 id="자료구조-특징">자료구조 특징</h2>
<!-- 1. 효율성
- 자료구조 사용의 목적은 효율적인 데이터관리 및 사용이다. 문제에 알맞은 자료구조를 사용하면 효율성이 증가한다.
2. 추상화
- 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념, 기능을 간추려 내는 것이다.
3. 재사용성
- 자료구조를 설계할 때 특정 프로그램에서만 동작하게 설계하지 않는다. 다양한 프로그램에서 동작할 수 있도록 범용성 있게 설계해 다른 프로젝트에서도 사용 가능하다. -->
<ol>
  <li>효율성  <br />
문제에 적절한 자료구조를 사용하면 속도와 자원 효율이 향상됩니다.</li>
  <li>추상화  <br />
복잡한 내부 구조는 숨기고 핵심적인 기능만을 표현함으로써 사용자는 사용법에 집중할 수 있습니다.</li>
  <li>재사용성  <br />
범용적으로 설계된 자료구조는 여러 프로젝트에서 재사용이 가능하여 유지보수에도 유리합니다.</li>
</ol>

<h2 id="알고리즘algorithms">알고리즘(Algorithms)</h2>
<!-- 특정 문제를 해결하기 위한 단계적인 절차이다.  
컴퓨터 과학에서 알고리즘은 입력 데이터를 받아 원하는 결과를 출력하는 절차이며,   
효율적인 알고리즘은 실행 시간과 자원 사용을 최소화한다. -->
<p>알고리즘은 문제를 해결하기 위한 단계적인 절차입니다.  <br />
입력을 받아 원하는 출력을 만들어내는 과정을 의미하며,  <br />
좋은 알고리즘은 빠르게 실행되면서도 적은 자원을 사용합니다.</p>

<h2 id="자료형data-type">자료형(Data Type)</h2>
<!-- 데이터의 종류를 의미한다.  
정수, 실수, 문자열 등이 기초적인 자료형이다.  
복잡한 자료형을 만들때는 연산자가 아닌 함수로 작성한다. -->
<p>자료형은 데이터의 종류와 형식을 정의한 것입니다.  <br />
예를 들어, 정수형(Int), 실수형(Float), 문자열(String) 등은 기초 자료형(Primitive Type)에 해당합니다.  <br />
이 외에도 여러 데이터를 묶은 구조체, 클래스 같은 복합 자료형(Composite Type)도 존재합니다.</p>

<h2 id="추상-자료형abstruct-data-types-adt">추상 자료형(Abstruct Data Types, ADT)</h2>
<!-- 데이터의 논리적 구조와 연산을 정의하면서 구현 세부사항은 숨기는 개념이다.  
사용자는 기능에만 집중할 수 있고, 내부 구현은 몰라도 된다.  
장보 은닉과 모듈화를 통해 코드의 재사용성과 유지보수성을 높일 수 있다.  
스택, 큐, 리스트, 트리와 같은 자료형을 의미한디.  
실제적인 구현으로부터 군리되어 정의된 자료형으로 자료형을 추상적(수학적)으로 정의함을 의미한다. -->
<p>추상 자료형은 데이터의 구조와 이를 처리하는 연산만 정의하고, 구체적인 구현은 숨기는 개념입니다.  <br />
사용자는 내부 구현을 몰라도 되고, 기능(인터페이스)만 알면 됩니다.</p>

<p>대표적인 ADT 예시: 스택, 큐, 리스트, 트리<br />
정보 은닉과 모듈화를 통해 재사용성과 유지보수성이 뛰어납니다.  <br />
수학적으로 정의된 개념으로, 실제 구현(배열, 연결 리스트 등)과는 분리되어 있습니다.  <br />
➡️ 즉, ADT는 ‘무엇을 할 수 있는가’에 집중하고, 구현 방식은 자유롭게 선택할 수 있는 설계 방식입니다.</p>

<h2 id="추상화abstraction">추상화(Abstraction)</h2>
<!-- 시스템의 간략화된 기술 또는 명세로서 시스템의 핵심적인 구조나 동작에만 집중하는 것이다.  
좋은 추상화는 사용자에게 중요한 정보는 강조되고 중요하지 않는 구현 세부 사항은 제거된다. -->
<p>추상화는 불필요한 세부 사항을 숨기고, 핵심 기능에 집중하는 것입니다.  <br />
복잡한 시스템을 단순하게 바라보게 해 주며, 유지보수성과 이해도를 높입니다.</p>

<h2 id="프로그램">프로그램</h2>
<p>프로그램 = 자료구조 + 알고리즘  <br />
소프트웨어는 결국 데이터를 어떻게 <strong>구조화(자료구조)</strong>하고,<br />
그 데이터를 어떻게 처리할지(알고리즘) 결정하는 것이 핵심입니다.</p>

<!-- ## 알고리즘 수행시간 측정방법
단순한 방법은 알고리즘을 프로그래밍 언어로 작성 및 실행시켜서 수행시간을 측정하는 방식이다.   
하지만 하드웨어나 프로그래밍 언어에 따라 수행 시간이 다르고 실험되지 않는 입력에 대해서는 수행시간을 주장할 수 없다.

## 알고리즘 복잡도 분석방법
알고리즘 분석에서 좋다는 의미는 크게 2가지의 측면을 고려할 수 있다.  
알고리즘의 수행시간과 기억공간의 양이다.  
알고리즘 수행시간 분석을 시간복잡도(time complexity)라고 하고   
알고리즘이 사용하는 기억 공간 분석을 공간복잡도(space complexity)라고 한다.  
알고리즘 복잡도는 시간복잡도를 사용한다. 이유는 알고리즘이 차지하는 공간보다는 수행 시간에 더 관심이 있기 때문이다.    -->

<h2 id="시간복잡도">시간복잡도</h2>
<!-- 알고리즘의 절대적인 수행 시간을 나타내는 것이 아니라 알고리즘을 이루고 있는 연산들이 몇번이나 수행되는지를 숫자로 표시한다.  
연산에는 산술연산, 대입연산, 비교연산, 이동연산 등이 있다.   
즉 연산의 개수를 계산하여 알고리즘을 비교할 수 있다. -->
<p>시간 복잡도는 알고리즘이 실행될 때 주요 연산이 얼마나 반복되는지를 정량적으로 나타낸 값입니다.  <br />
연산에는 산술, 대입, 비교, 이동 연산 등이 포함되며,  <br />
이를 통해 알고리즘 간 성능 비교가 가능합니다.</p>

<h2 id="순환recursion">순환(Recursion)</h2>
<p>어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법입니다.  <br />
주어진 문제를 더 작은 동일한 문제들로 분해하여 해결하는 분할 정복이 있습니다.  <br />
순환 호출시에는 호출이 일어날 때마다 호출하는 함수의 상태를 기억해야 하므로 여분의 기억장소가 필요합니다.<br />
순환은 이해하기 쉽지만 비효율적인 경우가 많습니다.</p>

<h2 id="활성-레코드activation-record">활성 레코드(Activation Record)</h2>
<p>프로그래밍 언어에서 하나의 함수가 자기 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일합니다.  <br />
복귀주소가 시스템 스택에 저장되고 호출되는 함수를 위한 매개변수(parameter)와 지역변수를 스택으로부터 할당받는데 이러한 공간을 활성 레코드라고 합니다. 호출된 함수가 자기 자신이라면 자기 자신의 시작 위치로 점프하게 됩니다. 호출된 함수가 끝나게 되면 시스템 스택에서 복귀주소를 추출하여 호출한 함수로 되돌아갑니다.</p>

<h2 id="꼬리-순환tail-recursion">꼬리 순환(Tail Recursion)</h2>
<p>순환 호출이 끝에서 이루어지는 순환을 꼬리 순환이라고 하는데 이를 반복 알고리즘으로 쉽게 바꾸어 쓸 수 있습니다.</p>
<ul>
  <li>반복이 빠른 예시
    <ul>
      <li>팩토리얼(순환, 반복 둘다 시간복잡도는 O(n)이지만 순환에서는 여분의 기억공간이 필요하고 함수를 호출하기 위해 함수의 매개변수들을 스택에 저장하는 사전 작업이 필요하다.)</li>
    </ul>
  </li>
  <li>순환이 빠른 예시
    <ul>
      <li>거듭제곱(logn)</li>
    </ul>
  </li>
</ul>

<h2 id="reference">Reference</h2>
<ul>
  <li>https://bnzn2426.tistory.com/115</li>
  <li>https://developer-haru.tistory.com/70</li>
  <li>https://wikidocs.net/224929</li>
  <li>https://velog.io/@ghldjfldj/자료구조-자료구조란</li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="Data Structure" /><summary type="html"><![CDATA[자료구조(Data Structure) 자료구조는 데이터를 효율적으로 저장하고 관리하는 방식입니다. 대량의 데이터를 다룰 때 삽입, 삭제, 검색, 정렬, 순회 같은 기본 연산을 효율적으로 처리하도록 도와줍니다. 자료구조는 크게 두 가지로 나누어집니다: 선형 자료구조: 배열, 연결 리스트, 스택, 큐처럼 데이터를 순서대로 나열하는 구조 비선형 자료구조: 트리, 그래프처럼 계층적이거나 복잡한 관계를 표현하는 구조 자료구조 특징 효율성 문제에 적절한 자료구조를 사용하면 속도와 자원 효율이 향상됩니다. 추상화 복잡한 내부 구조는 숨기고 핵심적인 기능만을 표현함으로써 사용자는 사용법에 집중할 수 있습니다. 재사용성 범용적으로 설계된 자료구조는 여러 프로젝트에서 재사용이 가능하여 유지보수에도 유리합니다. 알고리즘(Algorithms) 알고리즘은 문제를 해결하기 위한 단계적인 절차입니다. 입력을 받아 원하는 출력을 만들어내는 과정을 의미하며, 좋은 알고리즘은 빠르게 실행되면서도 적은 자원을 사용합니다. 자료형(Data Type) 자료형은 데이터의 종류와 형식을 정의한 것입니다. 예를 들어, 정수형(Int), 실수형(Float), 문자열(String) 등은 기초 자료형(Primitive Type)에 해당합니다. 이 외에도 여러 데이터를 묶은 구조체, 클래스 같은 복합 자료형(Composite Type)도 존재합니다. 추상 자료형(Abstruct Data Types, ADT) 추상 자료형은 데이터의 구조와 이를 처리하는 연산만 정의하고, 구체적인 구현은 숨기는 개념입니다. 사용자는 내부 구현을 몰라도 되고, 기능(인터페이스)만 알면 됩니다. 대표적인 ADT 예시: 스택, 큐, 리스트, 트리 정보 은닉과 모듈화를 통해 재사용성과 유지보수성이 뛰어납니다. 수학적으로 정의된 개념으로, 실제 구현(배열, 연결 리스트 등)과는 분리되어 있습니다. ➡️ 즉, ADT는 ‘무엇을 할 수 있는가’에 집중하고, 구현 방식은 자유롭게 선택할 수 있는 설계 방식입니다. 추상화(Abstraction) 추상화는 불필요한 세부 사항을 숨기고, 핵심 기능에 집중하는 것입니다. 복잡한 시스템을 단순하게 바라보게 해 주며, 유지보수성과 이해도를 높입니다. 프로그램 프로그램 = 자료구조 + 알고리즘 소프트웨어는 결국 데이터를 어떻게 구조화(자료구조)하고, 그 데이터를 어떻게 처리할지(알고리즘) 결정하는 것이 핵심입니다. 시간복잡도 시간 복잡도는 알고리즘이 실행될 때 주요 연산이 얼마나 반복되는지를 정량적으로 나타낸 값입니다. 연산에는 산술, 대입, 비교, 이동 연산 등이 포함되며, 이를 통해 알고리즘 간 성능 비교가 가능합니다. 순환(Recursion) 어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법입니다. 주어진 문제를 더 작은 동일한 문제들로 분해하여 해결하는 분할 정복이 있습니다. 순환 호출시에는 호출이 일어날 때마다 호출하는 함수의 상태를 기억해야 하므로 여분의 기억장소가 필요합니다. 순환은 이해하기 쉽지만 비효율적인 경우가 많습니다. 활성 레코드(Activation Record) 프로그래밍 언어에서 하나의 함수가 자기 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일합니다. 복귀주소가 시스템 스택에 저장되고 호출되는 함수를 위한 매개변수(parameter)와 지역변수를 스택으로부터 할당받는데 이러한 공간을 활성 레코드라고 합니다. 호출된 함수가 자기 자신이라면 자기 자신의 시작 위치로 점프하게 됩니다. 호출된 함수가 끝나게 되면 시스템 스택에서 복귀주소를 추출하여 호출한 함수로 되돌아갑니다. 꼬리 순환(Tail Recursion) 순환 호출이 끝에서 이루어지는 순환을 꼬리 순환이라고 하는데 이를 반복 알고리즘으로 쉽게 바꾸어 쓸 수 있습니다. 반복이 빠른 예시 팩토리얼(순환, 반복 둘다 시간복잡도는 O(n)이지만 순환에서는 여분의 기억공간이 필요하고 함수를 호출하기 위해 함수의 매개변수들을 스택에 저장하는 사전 작업이 필요하다.) 순환이 빠른 예시 거듭제곱(logn) Reference https://bnzn2426.tistory.com/115 https://developer-haru.tistory.com/70 https://wikidocs.net/224929 https://velog.io/@ghldjfldj/자료구조-자료구조란]]></summary></entry><entry><title type="html">[Pindora] Dependency Injection란?</title><link href="http://localhost:4000/Pindora-di/" rel="alternate" type="text/html" title="[Pindora] Dependency Injection란?" /><published>2025-07-15T00:00:00+00:00</published><updated>2025-07-15T00:00:00+00:00</updated><id>http://localhost:4000/%5BPindora%5D-di</id><content type="html" xml:base="http://localhost:4000/Pindora-di/"><![CDATA[<!-- https://www.youtube.com/watch?v=sBybUm8yVbI&list=PLgOlaPUIbynpuq9GKCwAedgWkkPm2Wo8v&index=18 -->

<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="dependency-injection란-무엇인가">Dependency Injection란 무엇인가?</h2>
<p>DI는 Dependency Injection의 줄임말로, 다양한 우리말 번역이 있지만, 이 글에서는 의존성 주입이라는 말로 사용하고자 한다.<br />
먼저 의존성, 주입, 의존성 주입 순서대로 알아보자.</p>

<h3 id="dependency의존성">Dependency(의존성)</h3>
<p>객체 지향 프로그래밍에서 Dependency, 의존성은 <code class="language-plaintext highlighter-rouge">서로 다른 객체 사이에 의존 관계가 있다는 것</code>을 말한다. 즉 <code class="language-plaintext highlighter-rouge">의존하는 객체가 수정되면 다른 객체도 영향을 받는다는 것</code>이다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="kd">class</span> <span class="kt">A부품</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"A부품"</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">B부품</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"B부품"</span>
<span class="p">}</span>


<span class="c1">/// ex: ViewController()</span>
<span class="kd">class</span> <span class="kt">C완성품</span> <span class="p">{</span>
    
    <span class="c1">/// ex: NetworkManager()</span>
    <span class="c1">// C완성품이 A부품에 의존한다 = 의존성이 생긴다</span>
    <span class="c1">// A부품의 코드가 바뀌면 C완성품의 코드를 바꿔줘야하는 문제가 생긴다</span>
    <span class="c1">// 부품을 바꾸고 싶을 때는 코드를 B부품으로 버꿔야 하는 문제가 생긴다</span>
    <span class="k">var</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">A부품</span> <span class="o">=</span> <span class="kt">A부품</span><span class="p">()</span>
    
    <span class="kd">func</span> <span class="nf">printName</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>하나의 객체가 다른 객체에 의존하고 있는 코드를 의존하고 있다고 말한다.<br />
이렇게 의존성이 생기는 코드를 확장성있게 바꾸기 위해 의존성 주입을 통해 코드를 개선할 수 있다.</p>

<h2 id="주입injection">주입(Injection)</h2>

<p>생성자를 통해 저장속성을 외부에서 주입하는 개념이다.  <br />
의존성 코드에서는 저장속성에 기본값을 인스턴스로 생성&amp;할당하여 생성자를 만들어 주지 않아도 괜찮았다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 주입(Injection)</span>
<span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 외부에서 값을 주입(할당/초기화)해서 인스턴스 생성</span>
<span class="k">let</span> <span class="nv">people</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Index"</span><span class="p">)</span>
</code></pre></div></div>
<p>실제로는 기본값보다는 생성자를 통해서 외부에서 들어온 값을 통해 저장속성에 할당할 수 있게 해주는 개념인 주입의 개념을 실제로 많이 사용한다.<br />
정리하자면 인스턴스를 생성할 때 저장속성을 외부에서 할당(=주입=초기화)해줄 수 있다고 한다.</p>

<h2 id="의존성-주입">의존성 주입</h2>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="kd">class</span> <span class="kt">A부품</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"A부품"</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">B부품</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"B부품"</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">C완성품</span> <span class="p">{</span>
    
    <span class="k">var</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">A부품</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="kt">A부품</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">printName</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 1. 인스턴스를 미리 만들고</span>
<span class="k">let</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">A부품</span> <span class="o">=</span> <span class="kt">A부품</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"비싼 A부품"</span>

<span class="c1">// 2. C완성품을 만들 때 주입(Injection)을 해줄 수 있다</span>
<span class="c1">// 하지만 이 코드를 의존성 주입(Dependency Injection)이라고 부르지는 않는다</span>
<span class="k">let</span> <span class="nv">c</span><span class="p">:</span> <span class="kt">C완성품</span> <span class="o">=</span> <span class="kt">C완성품</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div></div>
<p>C완성품을 만들 때 미리 만들어 둔 A부품을 주입할 수 있지만 이 코드를 의존성 주입이라고 부르지는 않는다.  <br />
의존적이지 않게 만들어주는 코드를 추가해야 의존성 주입이라는 개념이 된다.</p>

<h3 id="주입을-의존성-주입으로-개선">주입을 의존성 주입으로 개선</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// protocol은 자격증이라고 생각하자</span>
<span class="c1">// 각 부품에서 이 자격증을 채택한다</span>
<span class="c1">// 자격증을 정의할 때 name이라는 속성을 가지면서 읽기, 쓰기가 가능한 name이라는 속성을 가진다고 정의하고 이를 각 모듈에서 채택한다</span>
<span class="c1">// 이 protocol 덕분에 모듈화가 가능해지고 확장적인 코드를 작성할 수 있게 된다</span>
<span class="kd">protocol</span> <span class="n">모듈화된부품</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="k">set</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">A부품</span><span class="p">:</span> <span class="n">모듈화된부품</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"A부품"</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">B부품</span><span class="p">:</span> <span class="n">모듈화된부품</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"B부품"</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">C완성품</span> <span class="p">{</span>
    
    <span class="c1">// 프로토콜로 타입을 선언하여 이 프로토콜(자격증)을 채택한 모든 타입들을 할당해줄 수 있다</span>
    <span class="k">var</span> <span class="nv">a</span><span class="p">:</span> <span class="n">모듈화된부품</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="n">모듈화된부품</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">printName</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">Main</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">moduledA</span> <span class="o">=</span> <span class="kt">A부품</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">moduledB</span> <span class="o">=</span> <span class="kt">B부품</span><span class="p">()</span>
        
        <span class="c1">// 모듈화된 A를 주입할 수도 있고 모듈화된 B를 주입할 수도 있다</span>
        <span class="k">let</span> <span class="nv">c1</span><span class="p">:</span> <span class="kt">C완성품</span> <span class="o">=</span> <span class="kt">C완성품</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="n">moduledA</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">c2</span><span class="p">:</span> <span class="kt">C완성품</span> <span class="o">=</span> <span class="kt">C완성품</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="n">moduledB</span><span class="p">)</span>
        
        <span class="n">c1</span><span class="o">.</span><span class="nf">printName</span><span class="p">()</span>
        <span class="n">c2</span><span class="o">.</span><span class="nf">printName</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>주입 코드를 의존성 주입으로 개선하기 위해 protocol을 선언하고 클래스의 저장속성 타입들이 해당 protocol을 채택하면 된다.   <br />
이를 통해 C완성품은 저장속성으로 A부품도 주입할 수 있고 B부품도 주입할 수 있다.</p>

<p>정리하자면 각 부품이 서로 다른 타입이지만 모듈화가 가능해지고 확장적인 코드를 작성할 수 있게 된다.   <br />
protocol 자체를 타입으로 사용할 수 있어서 모듈화를 시킬 수 있는 장점이 존재하고, protocol을 채택한 여러 타입들이 속성에 할당될 수 있는 것이다.</p>

<h2 id="정리">정리</h2>
<p>의존성</p>
<ul>
  <li>서로 다른 객체 사이에 의존 관계가 있다는 것</li>
  <li>(한 객체가 다른 객체에 직접 접근하거나 사용하는 관계)</li>
</ul>

<p>주입</p>
<ul>
  <li>외부에서 객체(또는 데이터)를 생성해서 생성자를 통해 넣는 것</li>
  <li>(클래스 내부에서 직접 생성하지 않고, 외부에서 주입)</li>
</ul>

<p>의존성 주입(개선된 의존성)</p>
<ul>
  <li>프로토콜을 사용해서 의존성을 분리시키고 의존관계를 역전 시킨다
    <ul>
      <li>객체 간의 결합도를 낮추고, 의존 관계를 외부로 분리하여 더 유연한 구조를 만드는 설계 방식</li>
      <li><strong>의존 관계 역전 원칙(DIP)</strong>과 <strong>단일 책임 원칙(SRP)</strong>을 따르도록 도와준다</li>
      <li>주입 시 <strong>프로토콜(인터페이스)</strong>을 사용하면 모듈화와 확장성이 높아진다</li>
      <li>이를 통해 구체적인 클래스가 아닌 추상화(프로토콜)에 의존하게 되고, 이것이 바로 의존 관계의 역전</li>
    </ul>
  </li>
</ul>

<h2 id="reference">Reference</h2>
<ul>
  <li>https://eunjin3786.tistory.com/233</li>
  <li>https://medium.com/@jang.wangsu/di-dependency-injection-이란-1b12fdefec4f</li>
  <li>https://medium.com/@jang.wangsu/di-inversion-of-control-container-란-12ecd70ac7ea</li>
  <li>https://tecoble.techcourse.co.kr/post/2021-04-27-dependency-injection/</li>
  <li>https://dokit.tistory.com/54</li>
  <li>https://80000coding.oopy.io/68ee8d89-5d05-449d-87e2-5fba84d604ca</li>
  <li>https://www.inflearn.com/courses/lecture?courseId=328390&amp;type=LECTURE&amp;unitId=163822&amp;subtitleLanguage=ko&amp;tab=curriculum</li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="Pindora" /><summary type="html"><![CDATA[Dependency Injection란 무엇인가? DI는 Dependency Injection의 줄임말로, 다양한 우리말 번역이 있지만, 이 글에서는 의존성 주입이라는 말로 사용하고자 한다. 먼저 의존성, 주입, 의존성 주입 순서대로 알아보자. Dependency(의존성) 객체 지향 프로그래밍에서 Dependency, 의존성은 서로 다른 객체 사이에 의존 관계가 있다는 것을 말한다. 즉 의존하는 객체가 수정되면 다른 객체도 영향을 받는다는 것이다. import Foundation class A부품 { var name: String = "A부품" } class B부품 { var name: String = "B부품" } /// ex: ViewController() class C완성품 { /// ex: NetworkManager() // C완성품이 A부품에 의존한다 = 의존성이 생긴다 // A부품의 코드가 바뀌면 C완성품의 코드를 바꿔줘야하는 문제가 생긴다 // 부품을 바꾸고 싶을 때는 코드를 B부품으로 버꿔야 하는 문제가 생긴다 var a: A부품 = A부품() func printName() { print(a.name) } } 하나의 객체가 다른 객체에 의존하고 있는 코드를 의존하고 있다고 말한다. 이렇게 의존성이 생기는 코드를 확장성있게 바꾸기 위해 의존성 주입을 통해 코드를 개선할 수 있다. 주입(Injection) 생성자를 통해 저장속성을 외부에서 주입하는 개념이다. 의존성 코드에서는 저장속성에 기본값을 인스턴스로 생성&amp;할당하여 생성자를 만들어 주지 않아도 괜찮았다. // 주입(Injection) class Person { var name: String init(name: String) { self.name = name } } // 외부에서 값을 주입(할당/초기화)해서 인스턴스 생성 let people = Person(name: "Index") 실제로는 기본값보다는 생성자를 통해서 외부에서 들어온 값을 통해 저장속성에 할당할 수 있게 해주는 개념인 주입의 개념을 실제로 많이 사용한다. 정리하자면 인스턴스를 생성할 때 저장속성을 외부에서 할당(=주입=초기화)해줄 수 있다고 한다. 의존성 주입 import Foundation class A부품 { var name: String = "A부품" } class B부품 { var name: String = "B부품" } class C완성품 { var a: A부품 init(a: A부품) { self.a = a } func printName() { print(a.name) } } // 1. 인스턴스를 미리 만들고 let a: A부품 = A부품() a.name = "비싼 A부품" // 2. C완성품을 만들 때 주입(Injection)을 해줄 수 있다 // 하지만 이 코드를 의존성 주입(Dependency Injection)이라고 부르지는 않는다 let c: C완성품 = C완성품(a: a) C완성품을 만들 때 미리 만들어 둔 A부품을 주입할 수 있지만 이 코드를 의존성 주입이라고 부르지는 않는다. 의존적이지 않게 만들어주는 코드를 추가해야 의존성 주입이라는 개념이 된다. 주입을 의존성 주입으로 개선 // protocol은 자격증이라고 생각하자 // 각 부품에서 이 자격증을 채택한다 // 자격증을 정의할 때 name이라는 속성을 가지면서 읽기, 쓰기가 가능한 name이라는 속성을 가진다고 정의하고 이를 각 모듈에서 채택한다 // 이 protocol 덕분에 모듈화가 가능해지고 확장적인 코드를 작성할 수 있게 된다 protocol 모듈화된부품 { var name: String { get set } } class A부품: 모듈화된부품 { var name: String = "A부품" } class B부품: 모듈화된부품 { var name: String = "B부품" } class C완성품 { // 프로토콜로 타입을 선언하여 이 프로토콜(자격증)을 채택한 모든 타입들을 할당해줄 수 있다 var a: 모듈화된부품 init(a: 모듈화된부품) { self.a = a } func printName() { print(a.name) } } @main struct Main { static func main() { let moduledA = A부품() let moduledB = B부품() // 모듈화된 A를 주입할 수도 있고 모듈화된 B를 주입할 수도 있다 let c1: C완성품 = C완성품(a: moduledA) let c2: C완성품 = C완성품(a: moduledB) c1.printName() c2.printName() } } 주입 코드를 의존성 주입으로 개선하기 위해 protocol을 선언하고 클래스의 저장속성 타입들이 해당 protocol을 채택하면 된다. 이를 통해 C완성품은 저장속성으로 A부품도 주입할 수 있고 B부품도 주입할 수 있다. 정리하자면 각 부품이 서로 다른 타입이지만 모듈화가 가능해지고 확장적인 코드를 작성할 수 있게 된다. protocol 자체를 타입으로 사용할 수 있어서 모듈화를 시킬 수 있는 장점이 존재하고, protocol을 채택한 여러 타입들이 속성에 할당될 수 있는 것이다. 정리 의존성 서로 다른 객체 사이에 의존 관계가 있다는 것 (한 객체가 다른 객체에 직접 접근하거나 사용하는 관계) 주입 외부에서 객체(또는 데이터)를 생성해서 생성자를 통해 넣는 것 (클래스 내부에서 직접 생성하지 않고, 외부에서 주입) 의존성 주입(개선된 의존성) 프로토콜을 사용해서 의존성을 분리시키고 의존관계를 역전 시킨다 객체 간의 결합도를 낮추고, 의존 관계를 외부로 분리하여 더 유연한 구조를 만드는 설계 방식 의존 관계 역전 원칙(DIP)과 단일 책임 원칙(SRP)을 따르도록 도와준다 주입 시 프로토콜(인터페이스)을 사용하면 모듈화와 확장성이 높아진다 이를 통해 구체적인 클래스가 아닌 추상화(프로토콜)에 의존하게 되고, 이것이 바로 의존 관계의 역전 Reference https://eunjin3786.tistory.com/233 https://medium.com/@jang.wangsu/di-dependency-injection-이란-1b12fdefec4f https://medium.com/@jang.wangsu/di-inversion-of-control-container-란-12ecd70ac7ea https://tecoble.techcourse.co.kr/post/2021-04-27-dependency-injection/ https://dokit.tistory.com/54 https://80000coding.oopy.io/68ee8d89-5d05-449d-87e2-5fba84d604ca https://www.inflearn.com/courses/lecture?courseId=328390&amp;type=LECTURE&amp;unitId=163822&amp;subtitleLanguage=ko&amp;tab=curriculum]]></summary></entry></feed>