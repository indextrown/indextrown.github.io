<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2026-01-07T04:28:08+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">DongHyeon Kim’s Blog</title><subtitle>Swift와 크롤링 기술을 통해 안전한 세상을 만들고 싶습니다.</subtitle><author><name>Dong Hyeon</name></author><entry><title type="html">[SwiftUI] Equatable, Identifiable</title><link href="http://localhost:4000/SwiftUI-View/" rel="alternate" type="text/html" title="[SwiftUI] Equatable, Identifiable" /><published>2026-01-07T00:00:00+00:00</published><updated>2026-01-07T00:00:00+00:00</updated><id>http://localhost:4000/%5BSwiftUI%5D-View</id><content type="html" xml:base="http://localhost:4000/SwiftUI-View/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<!-- ## SwiftUI는 뷰를 어떻게 구분하고 업데이트 하는가?
사전 지식으로 동등성(equality)와 동일성(Identity)가 필요하다. -->

<h2 id="equatable-identifiable-요약">Equatable, Identifiable 요약</h2>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// id: 셀의 정체성 유지</span>
<span class="c1">// Equatable: 불필요한 리렌더링 방지</span>
<span class="kd">struct</span> <span class="kt">Item</span><span class="p">:</span> <span class="kt">Identifiable</span><span class="p">,</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span>
    <span class="k">var</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>Equatable: 값이 같은가</li>
  <li>Identity: 같은 존재인가</li>
</ul>

<p>-&gt; Equatable은 값 비교이고 Identifiable는 대상 식별이며 동일성은 id로 표현된다.</p>

<h2 id="list나-foreach는-내부적으로-다음-플로우를-사용한다">List나 ForEach는 내부적으로 다음 플로우를 사용한다</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1️⃣ Identifiable
   └─ 같은 Row인가?
      ├─ 아니면 → insert/delete/move
      └─ 맞으면 → 다음 단계

2️⃣ View 업데이트 판단
   ├─ Equatable 있음
   │    ├─ <span class="o">==</span> <span class="nb">true</span>  → body skip
   │    └─ <span class="o">==</span> <span class="nb">false</span> → body 재계산
   └─ Equatable 없음
        └─ 무조건 body 재계산
</code></pre></div></div>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Identifiable</code> 혹은 id로 판단
    <ul>
      <li>같은 Row인가</li>
      <li>insert/delete/remove 판단</li>
    </ul>
  </li>
  <li>뷰 업데이트
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Equatable</code>을 채택하지 않은 경우<br />
  이전 view 새로운 view 비교할 방법이 없어서 비교를 포기하고 항상 해당 View와 자식 View들의 <code class="language-plaintext highlighter-rouge">body</code>를 다시 계산한다</li>
      <li><code class="language-plaintext highlighter-rouge">Equatable</code> 채택한 경우  <br />
  <code class="language-plaintext highlighter-rouge">==</code>로 이전 view와 비교하여 같으면 자식 body 계산 생략하고 다르면 자식 body를 계산한다</li>
    </ul>
  </li>
</ol>

<h2 id="equatable는-선택적이지만-쓰면-이점이-있다">Equatable는 선택적이지만 쓰면 이점이 있다</h2>
<blockquote>
  <p>Equatable이 없으면 같은 셀이어도 body는 항상 다시 계산되고,<br />
Equatable이 있으면 내용이 같을 때 body 계산을 건너뛸 수 있다.</p>
</blockquote>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ Equatable 없음</span>
<span class="c1">// 상위 상태 변경</span>
<span class="c1">//  → List body 실행</span>
<span class="c1">//  → ForEach 실행</span>
<span class="c1">//  → 모든 RowView body 실행 ❗</span>
<span class="kd">struct</span> <span class="kt">RowView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">model</span><span class="p">:</span> <span class="kt">Item</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HeavyView</span><span class="p">(</span><span class="nv">model</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>상위 View가 다시 그려지면 같은 id 셀이라도 RowView.body는 다시 실행된다</li>
  <li>하지만 Heavy한 View에서는 문제가 된다.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ Equatable 있음</span>
<span class="c1">// 상위 상태 변경</span>
<span class="c1">//  → List body 실행</span>
<span class="c1">//  → ForEach 실행</span>
<span class="c1">//  → RowView == 비교</span>
<span class="c1">//      ├─ true → body skip</span>
<span class="c1">//      └─ false → body 실행</span>
<span class="c1">// 이전 RowView == 새로운 RowView ?</span>
<span class="c1">// ├─ true  → body 재계산 SKIP</span>
<span class="c1">// └─ false → body 재계산</span>
<span class="kd">struct</span> <span class="kt">RowView</span><span class="p">:</span> <span class="kt">View</span><span class="p">,</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">model</span><span class="p">:</span> <span class="kt">Item</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">RowView</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">RowView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="n">lhs</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">model</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HeavyView</span><span class="p">(</span><span class="nv">model</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">RowView</span><span class="p">(</span><span class="nv">model</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">equatable</span><span class="p">()</span>
</code></pre></div></div>
<ul>
  <li>Equatable을 채택하면 아래와 같은 이점이 있다<br />
줄어드는 것</li>
  <li>body 실행 횟수</li>
  <li>내부 View 트리 생성</li>
  <li>Layout / Preference / Modifier 재평가<br />
줄어들지 않는 것</li>
  <li>List의 diff 비교</li>
  <li>insert/delete/move판단<br />
-&gt; 즉 diff횟수는 감소되지 않고 render 판단 횟수가 감소한다</li>
</ul>

<h3 id="동등성equatable">동등성(Equatable)</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Person</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="c1">// Equtable은 값의 상태를 기준으로 비교하므로 두 인스턴스는 같다고 판단된다.</span>
<span class="k">let</span> <span class="nv">user1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">user2</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">user1</span> <span class="o">==</span> <span class="n">user2</span>  <span class="c1">// true</span>
</code></pre></div></div>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 속성들이 Equatable이므로 컴파일러가 자동으로 만들어줌</span>
<span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">Person</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">Person</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="n">lhs</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">name</span> <span class="o">&amp;&amp;</span>
    <span class="n">lhs</span><span class="o">.</span><span class="n">age</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">age</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>값 타입에서는 서로 다른 인스턴스라도 두 값의 전체 상태가 같거나 혹은 정의한 비교 규칙에 따라 일부 상태가 같다고 판단되면 동등하다</p>
</blockquote>

<h3 id="equatable-자동-완성-조건">Equatable 자동 완성 조건</h3>
<ul>
  <li>타입이 struct 또는 enum이고</li>
  <li>모든 저장 프로퍼티(또는 연관값)가 Equatable이고</li>
  <li>개발자가 <code class="language-plaintext highlighter-rouge">==</code> 을 직접 구현하지 않은 경우 컴파일러가 <code class="language-plaintext highlighter-rouge">==</code> 를 자동 합성한다.<br />
-&gt; 자동 합성된 <code class="language-plaintext highlighter-rouge">==</code>는 모든 저장 프로퍼티를 비교한다<br />
-&gt; 비교 기준을 일부 속성으로 제한하고 싶다면 <code class="language-plaintext highlighter-rouge">==</code>를 직접 구현해 커스텀 비교가 가능하다</li>
</ul>

<h3 id="동일성identity">동일성(Identity)</h3>
<blockquote>
  <p>내부 상태가 달라도 같은 대상을 가리키는지를 의미한다</p>
</blockquote>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Person</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">user1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="s">"기분 좋음"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">user2</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="s">"기분 나쁨"</span><span class="p">)</span>
<span class="n">user1</span> <span class="o">==</span> <span class="n">user2</span> <span class="c1">// false</span>
</code></pre></div></div>
<ul>
  <li>이름도 같고 나이도 같기 때문에 같은 사람이라고 생각할 수 있다</li>
  <li>하지만 Equatable로 비교하면 상태가 다르기 때문에 다르다고 나온다</li>
  <li>만약 이 둘을 동일한 사람으로 생각하려면 같은 사람으로 식별할 무언가가 필요하다</li>
  <li>주민등록번호같은 유일한 식별자가 필요하다<br />
-&gt; 이처럼 값의 상태만으로는 같은 대상을 판단할 수 없는 경우 동일성을 표현할 방법이 필요하다</li>
</ul>

<h3 id="identifiable-탄생">Identifiable 탄생</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">ID</span><span class="p">:</span> <span class="kt">Hashable</span>
    <span class="k">var</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">ID</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>Identifiable는 값의 내용과 무관하게 대상을 구분하기 위한 고유 식별자를 제공한다.</li>
</ul>

<h3 id="identifiable-예제">Identifiable 예제</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Peron</span><span class="p">:</span> <span class="kt">Equatable</span><span class="p">,</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">user1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="s">"고유식별자1"</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="s">"기분 좋음"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">user2</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="s">"고유식별자1"</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="s">"기분 좋음"</span><span class="p">)</span>
<span class="n">user1</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">user2</span><span class="o">.</span><span class="n">id</span>  <span class="c1">// true</span>
</code></pre></div></div>
<ul>
  <li>두 값의 상태는 다르지만</li>
  <li>id가 같기 때문에 같은 대상으로 판단할 수 있다</li>
  <li>이 경우 두 값은 동일성(identity)이 같다</li>
</ul>

<h2 id="reference">Reference</h2>
<ul>
  <li><a href="https://green1229.tistory.com/589">https://green1229.tistory.com/589</a></li>
  <li><a href="https://hasensprung.tistory.com/133">https://hasensprung.tistory.com/133</a></li>
  <li><a href="https://eunjin3786.tistory.com/m/559">https://eunjin3786.tistory.com/m/559</a></li>
  <li><a href="https://developer.apple.com/documentation/swiftui/view">https://developer.apple.com/documentation/swiftui/view</a></li>
  <li><a href="https://eunjin3786.tistory.com/560">https://eunjin3786.tistory.com/560</a></li>
  <li><a href="https://terry-some.tistory.com/133">https://terry-some.tistory.com/133</a></li>
  <li><a href="https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app">https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app</a></li>
  <li><a href="https://developer.apple.com/documentation/swiftui/view">https://developer.apple.com/documentation/swiftui/view</a></li>
  <li><a href="https://developer.apple.com/swiftui/">https://developer.apple.com/swiftui/</a></li>
  <li><a href="https://clamp-coding.tistory.com/519">https://clamp-coding.tistory.com/519</a></li>
  <li><a href="https://medium.com/airbnb-engineering/understanding-and-improving-swiftui-performance-37b77ac61896">https://medium.com/airbnb-engineering/understanding-and-improving-swiftui-performance-37b77ac61896</a></li>
  <li><a href="https://eunjin3786.tistory.com/560">https://eunjin3786.tistory.com/560</a></li>
  <li><a href="https://lzufs.tistory.com/2">https://lzufs.tistory.com/2</a></li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="SwiftUI" /><summary type="html"><![CDATA[Equatable, Identifiable 요약 // id: 셀의 정체성 유지 // Equatable: 불필요한 리렌더링 방지 struct Item: Identifiable, Equatable { let id: UUID var title: String } Equatable: 값이 같은가 Identity: 같은 존재인가 -&gt; Equatable은 값 비교이고 Identifiable는 대상 식별이며 동일성은 id로 표현된다. List나 ForEach는 내부적으로 다음 플로우를 사용한다 1️⃣ Identifiable └─ 같은 Row인가? ├─ 아니면 → insert/delete/move └─ 맞으면 → 다음 단계 2️⃣ View 업데이트 판단 ├─ Equatable 있음 │ ├─ == true → body skip │ └─ == false → body 재계산 └─ Equatable 없음 └─ 무조건 body 재계산 Identifiable 혹은 id로 판단 같은 Row인가 insert/delete/remove 판단 뷰 업데이트 Equatable을 채택하지 않은 경우 이전 view 새로운 view 비교할 방법이 없어서 비교를 포기하고 항상 해당 View와 자식 View들의 body를 다시 계산한다 Equatable 채택한 경우 ==로 이전 view와 비교하여 같으면 자식 body 계산 생략하고 다르면 자식 body를 계산한다 Equatable는 선택적이지만 쓰면 이점이 있다 Equatable이 없으면 같은 셀이어도 body는 항상 다시 계산되고, Equatable이 있으면 내용이 같을 때 body 계산을 건너뛸 수 있다. // ❌ Equatable 없음 // 상위 상태 변경 // → List body 실행 // → ForEach 실행 // → 모든 RowView body 실행 ❗ struct RowView: View { let model: Item var body: some View { HeavyView(model: model) } } 상위 View가 다시 그려지면 같은 id 셀이라도 RowView.body는 다시 실행된다 하지만 Heavy한 View에서는 문제가 된다. // ✅ Equatable 있음 // 상위 상태 변경 // → List body 실행 // → ForEach 실행 // → RowView == 비교 // ├─ true → body skip // └─ false → body 실행 // 이전 RowView == 새로운 RowView ? // ├─ true → body 재계산 SKIP // └─ false → body 재계산 struct RowView: View, Equatable { let model: Item static func == (lhs: RowView, rhs: RowView) -&gt; Bool { lhs.model == rhs.model } var body: some View { HeavyView(model: model) } } RowView(model: model) .equatable() Equatable을 채택하면 아래와 같은 이점이 있다 줄어드는 것 body 실행 횟수 내부 View 트리 생성 Layout / Preference / Modifier 재평가 줄어들지 않는 것 List의 diff 비교 insert/delete/move판단 -&gt; 즉 diff횟수는 감소되지 않고 render 판단 횟수가 감소한다 동등성(Equatable) struct Person: Equatable { var name: String var age: Int } // Equtable은 값의 상태를 기준으로 비교하므로 두 인스턴스는 같다고 판단된다. let user1 = Person(name: "홍길동", age: 25) let user2 = Person(name: "홍길동", age: 25) user1 == user2 // true // 속성들이 Equatable이므로 컴파일러가 자동으로 만들어줌 static func == (lhs: Person, rhs: Person) -&gt; Bool { lhs.name == rhs.name &amp;&amp; lhs.age == rhs.age } 값 타입에서는 서로 다른 인스턴스라도 두 값의 전체 상태가 같거나 혹은 정의한 비교 규칙에 따라 일부 상태가 같다고 판단되면 동등하다 Equatable 자동 완성 조건 타입이 struct 또는 enum이고 모든 저장 프로퍼티(또는 연관값)가 Equatable이고 개발자가 == 을 직접 구현하지 않은 경우 컴파일러가 == 를 자동 합성한다. -&gt; 자동 합성된 ==는 모든 저장 프로퍼티를 비교한다 -&gt; 비교 기준을 일부 속성으로 제한하고 싶다면 ==를 직접 구현해 커스텀 비교가 가능하다 동일성(Identity) 내부 상태가 달라도 같은 대상을 가리키는지를 의미한다 struct Person: Equatable { var name: String var age: Int var state: String } let user1 = Person(name: "홍길동", age: 25, state: "기분 좋음") let user2 = Person(name: "홍길동", age: 25, state: "기분 나쁨") user1 == user2 // false 이름도 같고 나이도 같기 때문에 같은 사람이라고 생각할 수 있다 하지만 Equatable로 비교하면 상태가 다르기 때문에 다르다고 나온다 만약 이 둘을 동일한 사람으로 생각하려면 같은 사람으로 식별할 무언가가 필요하다 주민등록번호같은 유일한 식별자가 필요하다 -&gt; 이처럼 값의 상태만으로는 같은 대상을 판단할 수 없는 경우 동일성을 표현할 방법이 필요하다 Identifiable 탄생 protocol Identifiable { associatedtype ID: Hashable var id: ID { get } } Identifiable는 값의 내용과 무관하게 대상을 구분하기 위한 고유 식별자를 제공한다. Identifiable 예제 struct Peron: Equatable, Identifiable { var id: String var name: String var age: Int var state: String } let user1 = Person(id: "고유식별자1", name: "홍길동", age: 25, state: "기분 좋음") let user2 = Person(id: "고유식별자1", name: "홍길동", age: 25, state: "기분 좋음") user1.id == user2.id // true 두 값의 상태는 다르지만 id가 같기 때문에 같은 대상으로 판단할 수 있다 이 경우 두 값은 동일성(identity)이 같다 Reference https://green1229.tistory.com/589 https://hasensprung.tistory.com/133 https://eunjin3786.tistory.com/m/559 https://developer.apple.com/documentation/swiftui/view https://eunjin3786.tistory.com/560 https://terry-some.tistory.com/133 https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app https://developer.apple.com/documentation/swiftui/view https://developer.apple.com/swiftui/ https://clamp-coding.tistory.com/519 https://medium.com/airbnb-engineering/understanding-and-improving-swiftui-performance-37b77ac61896 https://eunjin3786.tistory.com/560 https://lzufs.tistory.com/2]]></summary></entry><entry><title type="html">[SwiftUI] View</title><link href="http://localhost:4000/SwiftUI-View/" rel="alternate" type="text/html" title="[SwiftUI] View" /><published>2026-01-06T00:00:00+00:00</published><updated>2026-01-06T00:00:00+00:00</updated><id>http://localhost:4000/%5BSwiftUI%5D-View</id><content type="html" xml:base="http://localhost:4000/SwiftUI-View/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<h2 id="view">View</h2>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@MainActor</span> <span class="kd">@preconcurrency</span>
<span class="kd">protocol</span> <span class="kt">View</span>
</code></pre></div></div>
<blockquote>
  <p>SwiftUI의 View는 화면 그 자체가 아니라 이 상태라면 이런 화면이어야 한다는 설계도(설명값)이다.</p>
</blockquote>

<p>SwiftUI는 state-driven(언제 UI가 바뀌는가), data-driven(UI를 무엇으로 표현하는가)   <br />
UI 프레임워크로 state가 변경되면 View의 body가 다시 평가되며 이전 View 트리와 새로운 View 트리를 diff한 결과에 따라 필요한 UI만 업데이트한다.</p>

<ol>
  <li>View 값 생성
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
     <span class="kt">VStack</span> <span class="p">{</span>
         <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
         <span class="kt">Button</span><span class="p">(</span><span class="s">"Tap"</span><span class="p">)</span> <span class="p">{}</span>
     <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>body 실행</li>
      <li>View Struct 값 생성</li>
      <li>아직 화면에는 아무것도 안그려짐</li>
    </ul>
  </li>
  <li>View 트리 구성
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // SwiftUI는 body 결과를 모아서 이런 구조를 만든다
  VStack
 ├─ Text<span class="o">(</span><span class="s2">"Hello"</span><span class="o">)</span>
 └─ Button<span class="o">(</span><span class="s2">"Tap"</span><span class="o">)</span>
</code></pre></div>    </div>
  </li>
  <li>이전 트리와 diff
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Text는 같고 내용만 바뀜(전체 다시그리지 않고 부분 업데이트)</span>
  <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Text</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
</code></pre></div>    </div>
    <ul>
      <li>이전 View Tree vs 새 View Tree</li>
      <li>SwiftUI는 View 타입, 위치, identity(id), View 입력값을 비교한다</li>
    </ul>
  </li>
  <li>내부 Render Tree 갱신
    <ul>
      <li>SwiftUI는 View Tree를 Render Tree로 그린다</li>
      <li>레이아웃 계산</li>
      <li>애니메이션</li>
      <li>트랜지션</li>
      <li>접근성</li>
      <li>hit testing</li>
    </ul>
  </li>
  <li>UIKit / AppKit View 업데이트
    <ul>
      <li>여기서 실제 화면 객체가 등장한다</li>
      <li>iOS → UIKit (UIView)</li>
      <li>macOS → AppKit (NSView)</li>
    </ul>
  </li>
</ol>

<h2 id="swiftui는-뷰를-어떻게-구분하고-업데이트-하는가">SwiftUI는 뷰를 어떻게 구분하고 업데이트 하는가?</h2>
<p>사전 지식으로 동등성(equality)와 동일성(Identity)가 필요하다.</p>

<h3 id="동등성equatable">동등성(Equatable)</h3>
<ul>
  <li>두 객체의 전체 상태가 같거나 혹은 정의한 비교 규칙에 따라 값이 같다고 판단되는 것</li>
  <li>값 타입(struct, enum)에서 주로 사용
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Person</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">var</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">user1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">user2</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">user1</span> <span class="o">==</span> <span class="n">user2</span>  <span class="c1">// true</span>
</code></pre></div>    </div>
  </li>
  <li>Equtable로 비교하면 이 둘은 같게 된다</li>
  <li>이렇게 상태만을 비교하면 이 둘은 같다고 볼 수 있다</li>
</ul>

<h3 id="동일성identity">동일성(Identity)</h3>
<ul>
  <li>내부 상태가 달라도 같은 대상을 식별하는가
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Person</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">var</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">user1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="s">"기분 좋음"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">user2</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="s">"기분 나쁨"</span><span class="p">)</span>
<span class="n">user1</span> <span class="o">==</span> <span class="n">user2</span> <span class="c1">// false</span>
</code></pre></div>    </div>
  </li>
  <li>이름도 같고 나이도 같기 때문에 같은 사람이라고 생각할 수 있다</li>
  <li>하지만 Equatable로 비교하면 상태가 다르기 때문에 다르다고 나온다</li>
  <li>만약 이 둘을 동일한 사람으로 생각하려면 같은 사람으로 식별할 무언가가 필요하다</li>
  <li>주민등록번호같은 유일한 식별자가 필요하다</li>
</ul>

<h3 id="identifiable-탄생">Identifiable 탄생</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Peron</span><span class="p">:</span> <span class="kt">Equatable</span><span class="p">,</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">user1</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="s">"고유식별자1"</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="s">"기분 좋음"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">user2</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="s">"고유식별자1"</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="s">"홍길동"</span><span class="p">,</span> <span class="nv">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="s">"기분 좋음"</span><span class="p">)</span>
<span class="n">user1</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">user2</span><span class="o">.</span><span class="n">id</span>  <span class="c1">// true</span>
</code></pre></div></div>
<ul>
  <li>이렇게 되면 두 사람 모두 같은 사람이라고 판단할 수 있다</li>
  <li>이런 경우 이 둘의 identity(동일성)이 같다고 할 수 있다</li>
</ul>

<h3 id="사전지식이-필요한-이유">사전지식이 필요한 이유</h3>
<blockquote>
  <p>UIKit은 클래스 타입이기 때문에 뷰를 할당하므로 얻는 포인터가 그 뷰의 명시적 ID가 될 수 있다.  <br />
SwiftUI는 값 타입이기 때문에 이런 값을 지속적으로 사용할 수 없다.<br />
그래서 Identity가 등장하게 되었고 데이터 및 업데이트 주기에 영향을 미친다.</p>
</blockquote>

<p>SwiftUI는 값타입이다. 값타입은 복사에 의해 값이 전달되므로 원본을 변경하지 않고 각각의 복사본이 독립적으로 존재하게 된다. 변수에 값을 할당하거나 함수에 인자로 전달할 때 원본이 아닌 독립된 복사본이 생성된다. 각 복사본이 메모리 상의 다른 위치에 존재한다는 뜻이며 이러한 특성으로 해당 뷰를 지속적으로 추적하기 힘들다.</p>

<p>만약 SwiftUI가 내부적으로 뷰의 메모리 주소를 ID를 사용한다면 뷰가 재생성 될 때마다 새로운 id가 할당된다. SwiftUI는 뷰의 상태와 속성의 변화를 감지하고 변화된 부분만 효율적으로 업데이트한다.<br />
뷰의 새로운 상태외 이 전상태를 비교하게 되는데 이때 id가 다르다면 상태 비교가 불가능하게 된다.</p>

<h3 id="view-identity">View Identity</h3>
<ul>
  <li>명시적(Explicit) Identity</li>
  <li>구조적(Structural) Identity</li>
</ul>

<h3 id="명시적explicit-identity">명시적(Explicit) Identity</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">List</span> <span class="p">{</span>
    <span class="kt">ForEach</span><span class="p">(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">searchResults</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">resultId</span><span class="p">)</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
        <span class="c1">// </span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>직접 id를 설정해준다</li>
  <li>하지만 사소한 뷰 하나하나 id를 설정하는건 비효율적이다</li>
</ul>

<h3 id="구조적structuralidentity">구조적(Structural)Identity</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">MainView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">users</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="kt">EmptyView</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">UserListView</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>SwiftUI는 뷰 계층구조를 사용해 함시적 Identity를 생성한다</li>
  <li>전반에 걸쳐 구조적 Id를 생성하므로 모든 뷰의 id를 생성할 필요가 없다.</li>
</ul>

<h2 id="reference">Reference</h2>
<ul>
  <li><a href="https://green1229.tistory.com/589">https://green1229.tistory.com/589</a></li>
  <li><a href="https://hasensprung.tistory.com/133">https://hasensprung.tistory.com/133</a></li>
  <li><a href="https://eunjin3786.tistory.com/m/559">https://eunjin3786.tistory.com/m/559</a></li>
  <li><a href="https://developer.apple.com/documentation/swiftui/view">https://developer.apple.com/documentation/swiftui/view</a></li>
  <li><a href="https://eunjin3786.tistory.com/560">https://eunjin3786.tistory.com/560</a></li>
  <li><a href="https://terry-some.tistory.com/133">https://terry-some.tistory.com/133</a></li>
  <li><a href="https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app">https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app</a></li>
  <li><a href="https://developer.apple.com/documentation/swiftui/view">https://developer.apple.com/documentation/swiftui/view</a></li>
  <li><a href="https://developer.apple.com/swiftui/">https://developer.apple.com/swiftui/</a></li>
  <li><a href="https://clamp-coding.tistory.com/519">https://clamp-coding.tistory.com/519</a></li>
  <li><a href="https://medium.com/airbnb-engineering/understanding-and-improving-swiftui-performance-37b77ac61896">https://medium.com/airbnb-engineering/understanding-and-improving-swiftui-performance-37b77ac61896</a></li>
  <li><a href="https://eunjin3786.tistory.com/560">https://eunjin3786.tistory.com/560</a></li>
  <li><a href="https://lzufs.tistory.com/2">https://lzufs.tistory.com/2</a></li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="SwiftUI" /><summary type="html"><![CDATA[View @MainActor @preconcurrency protocol View SwiftUI의 View는 화면 그 자체가 아니라 이 상태라면 이런 화면이어야 한다는 설계도(설명값)이다. SwiftUI는 state-driven(언제 UI가 바뀌는가), data-driven(UI를 무엇으로 표현하는가) UI 프레임워크로 state가 변경되면 View의 body가 다시 평가되며 이전 View 트리와 새로운 View 트리를 diff한 결과에 따라 필요한 UI만 업데이트한다. View 값 생성 var body: some View { VStack { Text("Hello") Button("Tap") {} } } body 실행 View Struct 값 생성 아직 화면에는 아무것도 안그려짐 View 트리 구성 // SwiftUI는 body 결과를 모아서 이런 구조를 만든다 VStack ├─ Text("Hello") └─ Button("Tap") 이전 트리와 diff // Text는 같고 내용만 바뀜(전체 다시그리지 않고 부분 업데이트) Text("Hello") → Text("World") 이전 View Tree vs 새 View Tree SwiftUI는 View 타입, 위치, identity(id), View 입력값을 비교한다 내부 Render Tree 갱신 SwiftUI는 View Tree를 Render Tree로 그린다 레이아웃 계산 애니메이션 트랜지션 접근성 hit testing UIKit / AppKit View 업데이트 여기서 실제 화면 객체가 등장한다 iOS → UIKit (UIView) macOS → AppKit (NSView) SwiftUI는 뷰를 어떻게 구분하고 업데이트 하는가? 사전 지식으로 동등성(equality)와 동일성(Identity)가 필요하다. 동등성(Equatable) 두 객체의 전체 상태가 같거나 혹은 정의한 비교 규칙에 따라 값이 같다고 판단되는 것 값 타입(struct, enum)에서 주로 사용 struct Person: Equatable { var name: String var age: Int } let user1 = Person(name: "홍길동", age: 25) let user2 = Person(name: "홍길동", age: 25) user1 == user2 // true Equtable로 비교하면 이 둘은 같게 된다 이렇게 상태만을 비교하면 이 둘은 같다고 볼 수 있다 동일성(Identity) 내부 상태가 달라도 같은 대상을 식별하는가 struct Person: Equatable { var name: String var age: Int var state: String } let user1 = Person(name: "홍길동", age: 25, state: "기분 좋음") let user2 = Person(name: "홍길동", age: 25, state: "기분 나쁨") user1 == user2 // false 이름도 같고 나이도 같기 때문에 같은 사람이라고 생각할 수 있다 하지만 Equatable로 비교하면 상태가 다르기 때문에 다르다고 나온다 만약 이 둘을 동일한 사람으로 생각하려면 같은 사람으로 식별할 무언가가 필요하다 주민등록번호같은 유일한 식별자가 필요하다 Identifiable 탄생 struct Peron: Equatable, Identifiable { var id: String var name: String var age: Int var state: String } let user1 = Person(id: "고유식별자1", name: "홍길동", age: 25, state: "기분 좋음") let user2 = Person(id: "고유식별자1", name: "홍길동", age: 25, state: "기분 좋음") user1.id == user2.id // true 이렇게 되면 두 사람 모두 같은 사람이라고 판단할 수 있다 이런 경우 이 둘의 identity(동일성)이 같다고 할 수 있다 사전지식이 필요한 이유 UIKit은 클래스 타입이기 때문에 뷰를 할당하므로 얻는 포인터가 그 뷰의 명시적 ID가 될 수 있다. SwiftUI는 값 타입이기 때문에 이런 값을 지속적으로 사용할 수 없다. 그래서 Identity가 등장하게 되었고 데이터 및 업데이트 주기에 영향을 미친다. SwiftUI는 값타입이다. 값타입은 복사에 의해 값이 전달되므로 원본을 변경하지 않고 각각의 복사본이 독립적으로 존재하게 된다. 변수에 값을 할당하거나 함수에 인자로 전달할 때 원본이 아닌 독립된 복사본이 생성된다. 각 복사본이 메모리 상의 다른 위치에 존재한다는 뜻이며 이러한 특성으로 해당 뷰를 지속적으로 추적하기 힘들다. 만약 SwiftUI가 내부적으로 뷰의 메모리 주소를 ID를 사용한다면 뷰가 재생성 될 때마다 새로운 id가 할당된다. SwiftUI는 뷰의 상태와 속성의 변화를 감지하고 변화된 부분만 효율적으로 업데이트한다. 뷰의 새로운 상태외 이 전상태를 비교하게 되는데 이때 id가 다르다면 상태 비교가 불가능하게 된다. View Identity 명시적(Explicit) Identity 구조적(Structural) Identity 명시적(Explicit) Identity List { ForEach(viewModel.searchResults, id: \.resultId) { result in // } } 직접 id를 설정해준다 하지만 사소한 뷰 하나하나 id를 설정하는건 비효율적이다 구조적(Structural)Identity struct MainView: View { var body: some View { if users.isEmpty { EmptyView() } else { UserListView() } } } SwiftUI는 뷰 계층구조를 사용해 함시적 Identity를 생성한다 전반에 걸쳐 구조적 Id를 생성하므로 모든 뷰의 id를 생성할 필요가 없다. Reference https://green1229.tistory.com/589 https://hasensprung.tistory.com/133 https://eunjin3786.tistory.com/m/559 https://developer.apple.com/documentation/swiftui/view https://eunjin3786.tistory.com/560 https://terry-some.tistory.com/133 https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app https://developer.apple.com/documentation/swiftui/view https://developer.apple.com/swiftui/ https://clamp-coding.tistory.com/519 https://medium.com/airbnb-engineering/understanding-and-improving-swiftui-performance-37b77ac61896 https://eunjin3786.tistory.com/560 https://lzufs.tistory.com/2]]></summary></entry><entry><title type="html">[Architecture] TCA 개념 정리</title><link href="http://localhost:4000/Architecture-TCA-1/" rel="alternate" type="text/html" title="[Architecture] TCA 개념 정리" /><published>2025-12-15T00:00:00+00:00</published><updated>2025-12-15T00:00:00+00:00</updated><id>http://localhost:4000/%5BArchitecture%5D-TCA-1</id><content type="html" xml:base="http://localhost:4000/Architecture-TCA-1/"><![CDATA[<p><br /></p>

<h1 id="tcathe-composable-architecture">TCA(The Composable Architecture)</h1>
<p>TCA는 오픈소스 아키텍처 라이브러리다. Swift Composable Architecture, SCA라는 이름으로 부르는 경우도 있지만 공식문서상에는 TCA로 설명한다.</p>

<p>TCA는 SwiftUI에 적용하기 좋은 아키텍처다. 내부적으로 Combine이 활용되고 선언형 방식과 잘 맞는 아키텍처이기 때문이다. 물론 UIKit환경에서도 활용할 수 있다.<br />
<br /><br /></p>

<h1 id="tca-특징">TCA 특징</h1>
<ul>
  <li>Composable하다.(작은 요소 여러개가 합쳐져 하나의 큰 무언가를 이룬다)</li>
  <li>데이터의 경로가 단방향이라 앱 흐름을 파악하기 용이하다.</li>
  <li>Side-Effect를 테스트할 수 있어 코드의 안전성을 높일 수 있다.</li>
  <li>대규모 프로젝트에서 복잡한 앱의 상태 관리나 비즈니스 로직 처리, 테스트 코드 등을 작성하는데 있어 구조적으로 일관성을 유지하며 개발할 수 있도록 도와준다.<br />
<br /><br /></li>
</ul>

<h1 id="tca는-단방향-데이터-흐름을-기반으로-설계되었다">TCA는 단방향 데이터 흐름을 기반으로 설계되었다</h1>
<p>iOS 개발에서 가장 대중적인 MVVM구조를 보더라도 View와 ViewModel 사이가 양방향 데이터 흐름으로 이어지고 있다.</p>

<p>양방향 데이터 흐름에서 데이터 흐름을 파악하기가 단방향에 비해 상대적으로 어렵고 양방향 관계에서는 강한 결합 문제가 발생할 수 있다는 근거도 일리는 있지만 꼭 단방향 흐름을 채택하는 아키테처를 사용해서 해결할 문제는 아니다.</p>

<p>이런 이유보다는 기존 명령형 UI인 UIKit에서 선언현 UI환경인 SwiftUI로 트렌드가 옮겨지는 과정에서 기존의 MVC, MVVM이 최선의 방식인가? 라는 질문에서 TCA의 선호 흐름을 봐야 할 필요가 있다는 주장이 있다.</p>

<p>SwiftUI 데이터 바인딩은 viewModel을 두지 않더라도 View자체에서 프로퍼티 래퍼를 사용하는 방식으로 구현할 수 있다는 점, 하지만 비즈니스 로직까지 View에서 처리해야 하는 질문에는 답이 <strong>No</strong> 라는 점에서 해결책으로 등장한 흐름이 <strong>단방향 데이터 흐름</strong>이라는 점,</p>

<p>여기서 데이터 바인딩이 아니라 비즈니스 로직을 View로부터 효율적으로 분리하는 과정에서 떠올리게 된 단방향 데이터 흐름 구조가 Flux였고 TCA는 이 단방향 데이터 흐름이라는 Flux 컨셉을 받아 발전시킨 아키텍처 라이브러리이다.</p>

<blockquote>
  <ul>
    <li>선언형 프로그래밍인 SwiftUI에서 적합한 데이터 흐름 구조를 떠올리다가 등장한 것이 단방향 데이터 흐름 (Unidirectional Data Flow)이다.</li>
    <li>단방향 데이터 흐름을 제안한 대표 아키텍처가 Flux이고 이 컨셉을 발전시킨 것이 TCA (The Composable Architecure)이다.</li>
  </ul>
</blockquote>

<p><br /><br /></p>

<h1 id="tca-단방향-흐름-구조">TCA 단방향 흐름 구조</h1>
<ul>
  <li><strong>State</strong>: 애플리케이션의 상태를 나타내는 타입. 애플리케이션 상태란 UI를 그리기 위한 데이터나 비즈니스 로직이다.</li>
  <li><strong>Action</strong>: 애플리케이션에서 발생하는 모든 이벤트를 정의한 열거형이다. 사용자의 버튼 탭, 네트워크 응답, 알림 등 모든 이벤트가 포함될 수 있다.</li>
  <li><strong>Reducer</strong>: 입력된 Action에 따라 새로운 State 값을 업데이트하거나 API 요청과 같은 Effect를 반환하는 함수다.</li>
  <li><strong>Store</strong>: State, Action, Reducer를 실제 관리하고 개발자가 정의한 애플리케이션 모든 기능이 동작하는 핵심 공간이다.</li>
  <li><strong>Environment</strong>: 애플리케이션 외부로부터 데이터를 받아올 때 애플리케이션이 갖게 되는 의존성을 갖고 있는 타입이다.<br />
<br /><br /></li>
</ul>

<h1 id="reference">Reference</h1>
<ul>
  <li><a href="https://github.com/pointfreeco/swift-composable-architecture">Document</a></li>
  <li><a href="https://mini-min-dev.tistory.com/320">Blog</a></li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="Architecture" /><summary type="html"><![CDATA[TCA(The Composable Architecture) TCA는 오픈소스 아키텍처 라이브러리다. Swift Composable Architecture, SCA라는 이름으로 부르는 경우도 있지만 공식문서상에는 TCA로 설명한다. TCA는 SwiftUI에 적용하기 좋은 아키텍처다. 내부적으로 Combine이 활용되고 선언형 방식과 잘 맞는 아키텍처이기 때문이다. 물론 UIKit환경에서도 활용할 수 있다. TCA 특징 Composable하다.(작은 요소 여러개가 합쳐져 하나의 큰 무언가를 이룬다) 데이터의 경로가 단방향이라 앱 흐름을 파악하기 용이하다. Side-Effect를 테스트할 수 있어 코드의 안전성을 높일 수 있다. 대규모 프로젝트에서 복잡한 앱의 상태 관리나 비즈니스 로직 처리, 테스트 코드 등을 작성하는데 있어 구조적으로 일관성을 유지하며 개발할 수 있도록 도와준다. TCA는 단방향 데이터 흐름을 기반으로 설계되었다 iOS 개발에서 가장 대중적인 MVVM구조를 보더라도 View와 ViewModel 사이가 양방향 데이터 흐름으로 이어지고 있다. 양방향 데이터 흐름에서 데이터 흐름을 파악하기가 단방향에 비해 상대적으로 어렵고 양방향 관계에서는 강한 결합 문제가 발생할 수 있다는 근거도 일리는 있지만 꼭 단방향 흐름을 채택하는 아키테처를 사용해서 해결할 문제는 아니다. 이런 이유보다는 기존 명령형 UI인 UIKit에서 선언현 UI환경인 SwiftUI로 트렌드가 옮겨지는 과정에서 기존의 MVC, MVVM이 최선의 방식인가? 라는 질문에서 TCA의 선호 흐름을 봐야 할 필요가 있다는 주장이 있다. SwiftUI 데이터 바인딩은 viewModel을 두지 않더라도 View자체에서 프로퍼티 래퍼를 사용하는 방식으로 구현할 수 있다는 점, 하지만 비즈니스 로직까지 View에서 처리해야 하는 질문에는 답이 No 라는 점에서 해결책으로 등장한 흐름이 단방향 데이터 흐름이라는 점, 여기서 데이터 바인딩이 아니라 비즈니스 로직을 View로부터 효율적으로 분리하는 과정에서 떠올리게 된 단방향 데이터 흐름 구조가 Flux였고 TCA는 이 단방향 데이터 흐름이라는 Flux 컨셉을 받아 발전시킨 아키텍처 라이브러리이다. 선언형 프로그래밍인 SwiftUI에서 적합한 데이터 흐름 구조를 떠올리다가 등장한 것이 단방향 데이터 흐름 (Unidirectional Data Flow)이다. 단방향 데이터 흐름을 제안한 대표 아키텍처가 Flux이고 이 컨셉을 발전시킨 것이 TCA (The Composable Architecure)이다. TCA 단방향 흐름 구조 State: 애플리케이션의 상태를 나타내는 타입. 애플리케이션 상태란 UI를 그리기 위한 데이터나 비즈니스 로직이다. Action: 애플리케이션에서 발생하는 모든 이벤트를 정의한 열거형이다. 사용자의 버튼 탭, 네트워크 응답, 알림 등 모든 이벤트가 포함될 수 있다. Reducer: 입력된 Action에 따라 새로운 State 값을 업데이트하거나 API 요청과 같은 Effect를 반환하는 함수다. Store: State, Action, Reducer를 실제 관리하고 개발자가 정의한 애플리케이션 모든 기능이 동작하는 핵심 공간이다. Environment: 애플리케이션 외부로부터 데이터를 받아올 때 애플리케이션이 갖게 되는 의존성을 갖고 있는 타입이다. Reference Document Blog]]></summary></entry><entry><title type="html">[UIKit] UITableview 개념 정리</title><link href="http://localhost:4000/UITableview-UITableview/" rel="alternate" type="text/html" title="[UIKit] UITableview 개념 정리" /><published>2025-12-14T00:00:00+00:00</published><updated>2025-12-14T00:00:00+00:00</updated><id>http://localhost:4000/%5BUITableview%5D-UITableview</id><content type="html" xml:base="http://localhost:4000/UITableview-UITableview/"><![CDATA[<blockquote>
  <h2 id="uitableview">UITableview</h2>
  <p>사용자 지정 가능한 행으로 구성된 단일 열에 데이터를 표시합니다.</p>
  <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@MainActor</span>
<span class="kd">class</span> <span class="kt">UITableView</span>
</code></pre></div>  </div>
</blockquote>

<h2 id="개념">개념</h2>
<p>테이블 뷰는 행과 섹션으로 나뉜, 세로로 스크롤되는 콘텐츠를 한 열료 표시한다.   <br />
각 행에는 하나의 정보를 기본으로 표시한다. 섹션을 사용하면 관련된 행들을 그룹화할 수 있다.</p>

<h2 id="협업되는-객체">협업되는 객체</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Cell</code>: 셀은 콘텐츠를 시각적으로 표현하는 요소이다.</li>
  <li><code class="language-plaintext highlighter-rouge">Tableview</code> 컨트롤러: 테이블뷰를 관리하는 데 객체를 사용한다. 테이블 관련 기능을 위해 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Datasource</code>: 프로토콜을 채택하고 테이블에 필요한 데이터를 제공한다,</li>
  <li><code class="language-plaintext highlighter-rouge">Delegate</code>: 프로토콜을 채택하고 테이블 내용과 사용자의 상호작용을 관리한다.</li>
</ol>

<h2 id="reference">Reference</h2>
<ul>
  <li><a href="https://developer.apple.com/documentation/uikit/table-views">UITableview Document</a></li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="UITableview" /><summary type="html"><![CDATA[UITableview 사용자 지정 가능한 행으로 구성된 단일 열에 데이터를 표시합니다. @MainActor class UITableView 개념 테이블 뷰는 행과 섹션으로 나뉜, 세로로 스크롤되는 콘텐츠를 한 열료 표시한다. 각 행에는 하나의 정보를 기본으로 표시한다. 섹션을 사용하면 관련된 행들을 그룹화할 수 있다. 협업되는 객체 Cell: 셀은 콘텐츠를 시각적으로 표현하는 요소이다. Tableview 컨트롤러: 테이블뷰를 관리하는 데 객체를 사용한다. 테이블 관련 기능을 위해 사용한다. Datasource: 프로토콜을 채택하고 테이블에 필요한 데이터를 제공한다, Delegate: 프로토콜을 채택하고 테이블 내용과 사용자의 상호작용을 관리한다. Reference UITableview Document]]></summary></entry><entry><title type="html">[DifferenceKit] Swift 컬렉션에 최적화딘 가장 빠른 O(N) diffing 알고리즘</title><link href="http://localhost:4000/DifferenceKit-DifferenceKit/" rel="alternate" type="text/html" title="[DifferenceKit] Swift 컬렉션에 최적화딘 가장 빠른 O(N) diffing 알고리즘" /><published>2025-12-06T00:00:00+00:00</published><updated>2025-12-06T00:00:00+00:00</updated><id>http://localhost:4000/%5BDifferenceKit%5D-DifferenceKit</id><content type="html" xml:base="http://localhost:4000/DifferenceKit-DifferenceKit/"><![CDATA[<h1 id="differencefrom">difference(from:)</h1>
<p>difference(from:)을 이용하면 두 Collection의 차이를 쉽게 구할 수 있다.  <br />
A와 B를 비교할 때 무엇이 추가로 있고 무엇이 없는지 알 수 있다.</p>

<h1 id="reference">Reference</h1>
<ul>
  <li>https://green1229.tistory.com/589</li>
  <li>https://jeong9216.tistory.com/716#google_vignette</li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="Swift" /><category term="DifferenceKit" /><summary type="html"><![CDATA[difference(from:) difference(from:)을 이용하면 두 Collection의 차이를 쉽게 구할 수 있다. A와 B를 비교할 때 무엇이 추가로 있고 무엇이 없는지 알 수 있다. Reference https://green1229.tistory.com/589 https://jeong9216.tistory.com/716#google_vignette]]></summary></entry><entry><title type="html">[RxDataSource] 5. 버튼 액션을 클로저 이벤트로 전달하기</title><link href="http://localhost:4000/RxDataSource-RxDataSource-5/" rel="alternate" type="text/html" title="[RxDataSource] 5. 버튼 액션을 클로저 이벤트로 전달하기" /><published>2025-09-13T00:00:00+00:00</published><updated>2025-09-13T00:00:00+00:00</updated><id>http://localhost:4000/%5BRxDataSource%5D-RxDataSource-5</id><content type="html" xml:base="http://localhost:4000/RxDataSource-RxDataSource-5/"><![CDATA[<h1 id="기존-코드-개선">기존 코드 개선</h1>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - 한번 그려지고 끝나기 때문에 추가/삭제같은 이벤트를 반영할 수 없다.</span>
<span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">RxTodo</span><span class="p">]</span><span class="o">&gt;.</span><span class="nf">just</span><span class="p">(</span><span class="kt">RxTodo</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">())</span>
<span class="n">data</span><span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">myTableView</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">items</span><span class="p">(</span><span class="nv">cellIdentifier</span><span class="p">:</span> <span class="s">"RxTodoCell"</span><span class="p">,</span> <span class="nv">cellType</span><span class="p">:</span> <span class="kt">RxTodoCell</span><span class="o">.</span><span class="k">self</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">index</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">cell</span> <span class="k">in</span>
    <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// =&gt; BehaviorRelay를 사용하여 단발성이 아닌 변화가능한 상태를 가진 스트림을 만들어서 사용하자.</span>
<span class="c1">// MARK: - Relay는 Subject계열인데 끊어지지 않는다(.value로 접근시 마지막 데이터 확인가능 = stateful)</span>
<span class="k">var</span> <span class="nv">rxTodosRelay</span><span class="p">:</span> <span class="kt">BehaviorRelay</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">RxTodo</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">BehaviorRelay</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">RxTodo</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">())</span>
<span class="n">rxTodosRelay</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">myTableView</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">tableView</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">RxTodoCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">RxTodoCell</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()}</span>
        <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">element</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cell</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<p>이전 포스팅에서 아래와 같이 더미 데이터를 한 번만 방출하도록 설정하였다.  <br />
이 코드는 초기 데이터만 표시하고 변화가 될 수 없기 때문에 한계가 있다.<br />
<br /><br /><br /><br /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - 3초뒤 갱신</span>
<span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="nf">asyncAfter</span><span class="p">(</span><span class="nv">deadline</span><span class="p">:</span> <span class="o">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="kt">RxTodo</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// MARK: - Rx스러운 3초뒤 갱신</span>
<span class="kt">Observable</span><span class="o">.</span><span class="nf">just</span><span class="p">(())</span>
    <span class="o">.</span><span class="nf">delay</span><span class="p">(</span><span class="o">.</span><span class="nf">seconds</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="kt">MainScheduler</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span> <span class="c1">// Observable&lt;Void&gt;</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">RxTodo</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span> <span class="p">}</span>                    <span class="c1">// Observable&lt;[RxTodo]&gt;</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="nv">_</span><span class="p">:))</span>            <span class="c1">// 같은 자료형이면 클로저가 들어갈 수 있다</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<p>기존 딜레이 코드를 Rx스럽게 변경도 된다 동일한 로직이다.<br />
<br /><br /><br /><br /></p>

<h1 id="rxdatasource">RxDataSource</h1>
<p>RxDataSource는 Relay 같은 Observable이 갱신되면 렌더링이 된다.<br />
지금 코드에서 todosRelay를 BehaviorRelay로 사용한 이유는 마지막 데이터를 알아야 CRUD를 진행할 수 있기 때문이다.<br />
<br /><br /><br /><br /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - 버튼 연결</span>
<span class="n">addButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="k">var</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span> <span class="c1">// .value 하면 마지막에 보낸 데이터 할 수 있음</span>
        <span class="n">currentTodos</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="kt">RxTodo</span><span class="p">(),</span> <span class="nv">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>       <span class="c1">// 첫번째 열에 넣겠다</span>
        <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">currentTodos</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<p>crud 기능을 위해 추가 버튼을 만들었다.   <br />
맨위에서부터 데이터를 들어가게 하기위해 insert를 사용했으나 아래에 넣고싶으면 append를 사용하면된다.<br />
<br /><br /><br /><br /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 2. (더 유연하지만 수동 캐스팅 필요 – RxCocoa)</span>
<span class="n">rxTodosRelay</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">myTableView</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">tableView</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">RxTodoCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">RxTodoCell</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()}</span>
        <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">element</span><span class="p">)</span>
        
        <span class="c1">// MARK: - 셀의 delete버튼 선택되었을 때 액션을 여기서 처리</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">deleteAction</span> <span class="o">=</span> <span class="p">{</span> <span class="n">id</span> <span class="k">in</span>
            <span class="k">let</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span>
            <span class="k">let</span> <span class="nv">filteredTodos</span> <span class="o">=</span> <span class="n">currentTodos</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="n">id</span> <span class="p">}</span>
            <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">filteredTodos</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="c1">// MARK: - 셀의 토글 클릭시 액션을 여기서 처리</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">isDoneChange</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">id</span><span class="p">,</span> <span class="n">updatedIsDone</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="k">var</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span>
            <span class="c1">// 일치하는것 찾기</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">foundTodoIndex</span> <span class="o">=</span> <span class="n">currentTodos</span><span class="o">.</span><span class="nf">firstIndex</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="p">})</span> <span class="p">{</span>
                <span class="n">currentTodos</span><span class="p">[</span><span class="n">foundTodoIndex</span><span class="p">]</span><span class="o">.</span><span class="n">isDone</span> <span class="o">=</span> <span class="n">updatedIsDone</span>
            <span class="p">}</span>
            <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">currentTodos</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">cell</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<p>커스텀 셀에서 만든 클로저 버튼 액션 내부 로직을 직접 구현해준다.  <br />
이제 두가지 문제가 있는데 다음 포스팅에서 진행하겠다.</p>
<ul>
  <li>버튼도 그냥 addTarget말고 Rx로 연결하는게 어떨까?</li>
  <li>토글시 애니메이션이 전혀 없어서 어색하게 보인다<br />
<br /><br /><br /><br /></li>
</ul>

<h1 id="전체-코드">전체 코드</h1>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Model</span>
<span class="kd">import</span> <span class="kt">Fakery</span>
<span class="kd">import</span> <span class="kt">UIKit</span>

<span class="c1">// MARK: - Model</span>
<span class="kd">struct</span> <span class="kt">RxTodo</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span> <span class="o">=</span> <span class="kt">UUID</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">isDone</span><span class="p">:</span> <span class="kt">Bool</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">,</span>
         <span class="nv">isDone</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span> <span class="p">??</span> <span class="s">"터이틀: </span><span class="se">\(</span><span class="n">id</span><span class="o">.</span><span class="n">uuidString</span><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="se">)</span><span class="s">"</span>
        <span class="k">self</span><span class="o">.</span><span class="n">isDone</span> <span class="o">=</span> <span class="n">isDone</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">getDumies</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">RxTodo</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">faker</span> <span class="o">=</span> <span class="kt">Faker</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="s">"ko"</span><span class="p">)</span>
        <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="p">[</span><span class="kt">RxTodo</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">firstName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">firstName</span><span class="p">()</span>
            <span class="k">let</span> <span class="nv">lastName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">lastName</span><span class="p">()</span>
            <span class="k">let</span> <span class="nv">title</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">lastName</span><span class="se">)</span><span class="s"> </span><span class="se">\(</span><span class="n">firstName</span><span class="se">)</span><span class="s">"</span>
            <span class="n">result</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="kt">RxTodo</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="n">title</span><span class="p">,</span> <span class="nv">isDone</span><span class="p">:</span> <span class="kc">false</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cell</span>
<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">RxSwift</span>
<span class="kd">import</span> <span class="kt">RxCocoa</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">RxTodoCell</span><span class="p">:</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>

    <span class="k">var</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">RxTodo</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>

    <span class="c1">// MARK: - Rx</span>
    <span class="k">var</span> <span class="nv">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">isDoneChange</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span><span class="p">,</span> <span class="n">_</span> <span class="nv">newValue</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="k">var</span> <span class="nv">deleteAction</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span>

    <span class="kd">private</span> <span class="k">let</span> <span class="nv">titleLabel</span><span class="p">:</span> <span class="kt">UILabel</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
        <span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"제목"</span>
        <span class="n">label</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">label</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="kt">UIFont</span><span class="o">.</span><span class="nf">systemFont</span><span class="p">(</span><span class="nv">ofSize</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">bold</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">label</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="k">let</span> <span class="nv">idLabel</span><span class="p">:</span> <span class="kt">UILabel</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
        <span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"아이디"</span>
        <span class="n">label</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">label</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="kt">UIFont</span><span class="o">.</span><span class="nf">systemFont</span><span class="p">(</span><span class="nv">ofSize</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">regular</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">label</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">isDoneSwitch</span><span class="p">:</span> <span class="kt">UISwitch</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">sw</span> <span class="o">=</span> <span class="kt">UISwitch</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sw</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">deleteButton</span><span class="p">:</span> <span class="kt">UIButton</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">btn</span> <span class="o">=</span> <span class="kt">UIButton</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">system</span><span class="p">)</span>
        <span class="n">btn</span><span class="o">.</span><span class="nf">setTitle</span><span class="p">(</span><span class="s">"Delete"</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">btn</span><span class="o">.</span><span class="n">widthAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalToConstant</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">isActive</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="k">return</span> <span class="n">btn</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">vStack</span><span class="p">:</span> <span class="kt">UIStackView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">stack</span> <span class="o">=</span> <span class="kt">UIStackView</span><span class="p">(</span><span class="nv">arrangedSubviews</span><span class="p">:</span> <span class="p">[</span><span class="n">titleLabel</span><span class="p">,</span> <span class="n">idLabel</span><span class="p">])</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="o">.</span><span class="n">vertical</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">hStack</span><span class="p">:</span> <span class="kt">UIStackView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">stack</span> <span class="o">=</span> <span class="kt">UIStackView</span><span class="p">(</span><span class="nv">arrangedSubviews</span><span class="p">:</span> <span class="p">[</span><span class="n">vStack</span><span class="p">,</span> <span class="n">isDoneSwitch</span><span class="p">,</span> <span class="n">deleteButton</span><span class="p">])</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="o">.</span><span class="n">horizontal</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="o">.</span><span class="n">center</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="p">}()</span>

    <span class="k">override</span> <span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">.</span><span class="kt">CellStyle</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="n">style</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="n">reuseIdentifier</span><span class="p">)</span>
        <span class="nf">makeUI</span><span class="p">()</span>
        <span class="nf">constraints</span><span class="p">()</span>
        
        <span class="c1">// MARK: - 버튼 연결</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="nf">addTarget</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">handleIsDone</span><span class="p">),</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">valueChanged</span><span class="p">)</span>
        <span class="n">deleteButton</span><span class="o">.</span><span class="nf">addTarget</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">handleDeleteButton</span><span class="p">),</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">touchUpInside</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="nv">coder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">fatalError</span><span class="p">(</span><span class="s">"init(coder:) has not been implemented"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeUI</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">hStack</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="n">contentView</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">constraints</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">NSLayoutConstraint</span><span class="o">.</span><span class="nf">activate</span><span class="p">([</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">topAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="mi">10</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="mi">20</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">),</span>
        <span class="p">])</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">prepareForReuse</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">prepareForReuse</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"prepareForReuse() - cellData.id: </span><span class="se">\(</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="p">??</span> <span class="kt">UUID</span><span class="p">()</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">RxTodoCell</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">configure</span><span class="p">(</span><span class="n">with</span> <span class="nv">todo</span><span class="p">:</span> <span class="kt">RxTodo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">cellData</span> <span class="o">=</span> <span class="n">todo</span>
        <span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">title</span>

        <span class="k">let</span> <span class="nv">idString</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">todo</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">uuidString</span><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
        <span class="n">idLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"ID: </span><span class="se">\(</span><span class="n">idString</span><span class="se">)</span><span class="s">"</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">isOn</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">isDone</span>
        <span class="c1">// setRx()</span>
    <span class="p">}</span>
 
    <span class="c1">// MARK: - 디버깅용</span>
    <span class="kd">func</span> <span class="nf">configure</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">title</span>
        <span class="n">idLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"ID: </span><span class="se">\(</span><span class="n">id</span><span class="se">)</span><span class="s">"</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">isOn</span> <span class="o">=</span> <span class="kc">false</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">RxTodoCell</span> <span class="p">{</span>
    <span class="kd">@objc</span> <span class="kd">func</span> <span class="nf">handleIsDone</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UISwitch</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- id: </span><span class="se">\(</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">uuidString</span> <span class="p">??</span> <span class="s">""</span><span class="se">)</span><span class="s"> sender: </span><span class="se">\(</span><span class="n">sender</span><span class="o">.</span><span class="n">isOn</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="nf">isDoneChange</span><span class="p">?(</span><span class="n">id</span><span class="p">,</span> <span class="n">sender</span><span class="o">.</span><span class="n">isOn</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">@objc</span> <span class="kd">func</span> <span class="nf">handleDeleteButton</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="nf">deleteAction</span><span class="p">?(</span><span class="n">id</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if DEBUG</span>
<span class="kd">import</span> <span class="kt">SwiftUI</span>
<span class="c1">// TodoCell 미리보기</span>
<span class="kd">struct</span> <span class="kt">RxTodoCell_Preview</span><span class="p">:</span> <span class="kt">PreviewProvider</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">previews</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="kt">RxTodoCell</span><span class="p">()</span>
        <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"할 일 예제"</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="mi">42</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cell</span><span class="o">.</span><span class="n">contentView</span>
            <span class="o">.</span><span class="nf">getPreview</span><span class="p">()</span>
            <span class="o">.</span><span class="nf">previewLayout</span><span class="p">(</span><span class="o">.</span><span class="nf">fixed</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">350</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">))</span>
            <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="kt">Color</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</code></pre></div></div>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ViewController</span>
<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">RxSwift</span>
<span class="kd">import</span> <span class="kt">RxCocoa</span>
<span class="kd">import</span> <span class="kt">RxRelay</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">RxTodoViewController2</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="c1">// MARK: - 구독에 대한 찌꺼기 처리</span>
    <span class="k">var</span> <span class="nv">disposeBag</span> <span class="o">=</span>  <span class="kt">DisposeBag</span><span class="p">()</span>
    
    <span class="c1">// MARK: - Relay는 Subject계열인데 끊어지지 않는다(.value로 접근시 마지막 데이터 확인가능 = stateful)</span>
    <span class="k">var</span> <span class="nv">rxTodosRelay</span><span class="p">:</span> <span class="kt">BehaviorRelay</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">RxTodo</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">BehaviorRelay</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">RxTodo</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">())</span>

    <span class="c1">// MARK: - UI</span>
    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">addButton</span> <span class="o">=</span> <span class="kt">UIBarButtonItem</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"추가"</span><span class="p">,</span>
                                                 <span class="nv">style</span><span class="p">:</span> <span class="o">.</span><span class="n">plain</span><span class="p">,</span>
                                                 <span class="nv">target</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
                                                 <span class="nv">action</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">tv</span> <span class="o">=</span> <span class="kt">UITableView</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tv</span>
    <span class="p">}()</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">white</span>
        <span class="nf">makeUI</span><span class="p">()</span>
        <span class="nf">constraints</span><span class="p">()</span>
        
        <span class="c1">// MARK: - 코드기반 사용한다면</span>
        <span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">RxTodoCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="s">"RxTodoCell"</span><span class="p">)</span>
        
        <span class="c1">// ✅ 1. RxTodoCell을 타입으로 명시하여 바인딩하는 간결한 방식</span>
        <span class="cm">/*
         data.bind(to: myTableView.rx.items(cellIdentifier: RxTodoCell.reuseIdentifier,
                                            cellType: RxTodoCell.self)) { index, model, cell in
             cell.configure(with: model)
         }
        .disposed(by: disposeBag)
         */</span>
        
        
        <span class="c1">// ✅ 2. (더 유연하지만 수동 캐스팅 필요 – RxCocoa)</span>
        <span class="n">rxTodosRelay</span>
            <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">myTableView</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">tableView</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">RxTodoCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">RxTodoCell</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()}</span>
                <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">element</span><span class="p">)</span>
                
                <span class="c1">// MARK: - 셀의 delete버튼 선택되었을 때 액션을 여기서 처리</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">deleteAction</span> <span class="o">=</span> <span class="p">{</span> <span class="n">id</span> <span class="k">in</span>
                    <span class="k">let</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">let</span> <span class="nv">filteredTodos</span> <span class="o">=</span> <span class="n">currentTodos</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="n">id</span> <span class="p">}</span>
                    <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">filteredTodos</span><span class="p">)</span>
                <span class="p">}</span>
                
                <span class="c1">// MARK: - 셀의 토글 클릭시 액션을 여기서 처리</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">isDoneChange</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">id</span><span class="p">,</span> <span class="n">updatedIsDone</span> <span class="k">in</span>
                    <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
                    <span class="k">var</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span>
                    <span class="c1">// 일치하는것 찾기</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nv">foundTodoIndex</span> <span class="o">=</span> <span class="n">currentTodos</span><span class="o">.</span><span class="nf">firstIndex</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="p">})</span> <span class="p">{</span>
                        <span class="n">currentTodos</span><span class="p">[</span><span class="n">foundTodoIndex</span><span class="p">]</span><span class="o">.</span><span class="n">isDone</span> <span class="o">=</span> <span class="n">updatedIsDone</span>
                    <span class="p">}</span>
                    <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">currentTodos</span><span class="p">)</span>
                <span class="p">}</span>
                
                <span class="k">return</span> <span class="n">cell</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
        
        
        <span class="c1">// MARK: - 3초뒤 갱신</span>
        <span class="cm">/*
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            self.rxTodosRelay.accept(RxTodo.getDumies(count: 3))
        }
         */</span>
        
        <span class="c1">// MARK: - Rx스러운 3초뒤 갱신</span>
        <span class="cm">/*
        Observable.just(())
            .delay(.seconds(3), scheduler: MainScheduler.instance) // Observable&lt;Void&gt;
            .map { RxTodo.getDumies(count: 5) }                    // Observable&lt;[RxTodo]&gt;
            .bind(onNext: self.rxTodosRelay.accept(_:))            // 같은 자료형이면 클로저가 들어갈 수 있다
            .disposed(by: disposeBag)
        */</span>
        
        <span class="c1">// MARK: - 버튼 연결</span>
        <span class="n">addButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span>
            <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
                <span class="k">var</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span> <span class="c1">// .value 하면 마지막에 보낸 데이터 할 수 있음</span>
                <span class="n">currentTodos</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="kt">RxTodo</span><span class="p">(),</span> <span class="nv">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>       <span class="c1">// 첫번째 열에 넣겠다</span>
                <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">currentTodos</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeUI</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">myTableView</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="n">view</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
        
        <span class="c1">// 네비게이션 버튼</span>
        <span class="n">navigationItem</span><span class="o">.</span><span class="n">rightBarButtonItems</span> <span class="o">=</span> <span class="p">[</span><span class="n">addButton</span><span class="p">]</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">constraints</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">NSLayoutConstraint</span><span class="o">.</span><span class="nf">activate</span><span class="p">([</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">safeAreaLayoutGuide</span><span class="o">.</span><span class="n">topAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="ReactiveX" /><category term="RxDataSource" /><summary type="html"><![CDATA[기존 코드 개선 // MARK: - 한번 그려지고 끝나기 때문에 추가/삭제같은 이벤트를 반영할 수 없다. let data = Observable&lt;[RxTodo]&gt;.just(RxTodo.getDumies()) data.bind(to: myTableView.rx.items(cellIdentifier: "RxTodoCell", cellType: RxTodoCell.self)) { index, model, cell in cell.configure(with: model) } // =&gt; BehaviorRelay를 사용하여 단발성이 아닌 변화가능한 상태를 가진 스트림을 만들어서 사용하자. // MARK: - Relay는 Subject계열인데 끊어지지 않는다(.value로 접근시 마지막 데이터 확인가능 = stateful) var rxTodosRelay: BehaviorRelay&lt;[RxTodo]&gt; = BehaviorRelay(value: RxTodo.getDumies()) rxTodosRelay .bind(to: myTableView.rx.items) { (tableView, row, element) in guard let cell = tableView.dequeueReusableCell(withIdentifier: RxTodoCell.reuseIdentifier) as? RxTodoCell else { return UITableViewCell()} cell.configure(with: element) return cell } .disposed(by: disposeBag) 이전 포스팅에서 아래와 같이 더미 데이터를 한 번만 방출하도록 설정하였다. 이 코드는 초기 데이터만 표시하고 변화가 될 수 없기 때문에 한계가 있다. // MARK: - 3초뒤 갱신 DispatchQueue.main.asyncAfter(deadline: .now() + 3) { self.rxTodosRelay.accept(RxTodo.getDumies(count: 3)) } // MARK: - Rx스러운 3초뒤 갱신 Observable.just(()) .delay(.seconds(3), scheduler: MainScheduler.instance) // Observable&lt;Void&gt; .map { RxTodo.getDumies(count: 5) } // Observable&lt;[RxTodo]&gt; .bind(onNext: self.rxTodosRelay.accept(_:)) // 같은 자료형이면 클로저가 들어갈 수 있다 .disposed(by: disposeBag) 기존 딜레이 코드를 Rx스럽게 변경도 된다 동일한 로직이다. RxDataSource RxDataSource는 Relay 같은 Observable이 갱신되면 렌더링이 된다. 지금 코드에서 todosRelay를 BehaviorRelay로 사용한 이유는 마지막 데이터를 알아야 CRUD를 진행할 수 있기 때문이다. // MARK: - 버튼 연결 addButton.rx.tap .bind(onNext: { [weak self] _ in guard let self = self else { return } var currentTodos = self.rxTodosRelay.value // .value 하면 마지막에 보낸 데이터 할 수 있음 currentTodos.insert(RxTodo(), at: 0) // 첫번째 열에 넣겠다 self.rxTodosRelay.accept(currentTodos) }) .disposed(by: disposeBag) crud 기능을 위해 추가 버튼을 만들었다. 맨위에서부터 데이터를 들어가게 하기위해 insert를 사용했으나 아래에 넣고싶으면 append를 사용하면된다. // ✅ 2. (더 유연하지만 수동 캐스팅 필요 – RxCocoa) rxTodosRelay .bind(to: myTableView.rx.items) { (tableView, row, element) in guard let cell = tableView.dequeueReusableCell(withIdentifier: RxTodoCell.reuseIdentifier) as? RxTodoCell else { return UITableViewCell()} cell.configure(with: element) // MARK: - 셀의 delete버튼 선택되었을 때 액션을 여기서 처리 cell.deleteAction = { id in let currentTodos = self.rxTodosRelay.value let filteredTodos = currentTodos.filter { $0.id != id } self.rxTodosRelay.accept(filteredTodos) } // MARK: - 셀의 토글 클릭시 액션을 여기서 처리 cell.isDoneChange = { [weak self] id, updatedIsDone in guard let self = self else { return } var currentTodos = self.rxTodosRelay.value // 일치하는것 찾기 if let foundTodoIndex = currentTodos.firstIndex(where: { $0.id == id }) { currentTodos[foundTodoIndex].isDone = updatedIsDone } self.rxTodosRelay.accept(currentTodos) } return cell } .disposed(by: disposeBag) 커스텀 셀에서 만든 클로저 버튼 액션 내부 로직을 직접 구현해준다. 이제 두가지 문제가 있는데 다음 포스팅에서 진행하겠다. 버튼도 그냥 addTarget말고 Rx로 연결하는게 어떨까? 토글시 애니메이션이 전혀 없어서 어색하게 보인다 전체 코드 // Model import Fakery import UIKit // MARK: - Model struct RxTodo { let id: UUID = UUID() let title: String var isDone: Bool init(title: String? = nil, isDone: Bool = false ) { self.title = title ?? "터이틀: \(id.uuidString.prefix(8))" self.isDone = isDone } static func getDumies(count: Int = 10) -&gt; [RxTodo] { let faker = Faker(locale: "ko") var result: [RxTodo] = [] for _ in 1...count { let firstName = faker.name.firstName() let lastName = faker.name.lastName() let title = "\(lastName) \(firstName)" result.append(RxTodo(title: title, isDone: false)) } return result } } // Cell import UIKit import RxSwift import RxCocoa final class RxTodoCell: UITableViewCell { var cellData: RxTodo? = nil // MARK: - Rx var disposeBag = DisposeBag() var isDoneChange: ((_ id: UUID, _ newValue: Bool) -&gt; Void)? = nil var deleteAction: ((_ id: UUID) -&gt; Void)? = nil private let titleLabel: UILabel = { let label = UILabel() label.text = "제목" label.numberOfLines = 1 label.font = UIFont.systemFont(ofSize: 14, weight: .bold) return label }() private let idLabel: UILabel = { let label = UILabel() label.text = "아이디" label.numberOfLines = 0 label.font = UIFont.systemFont(ofSize: 12, weight: .regular) return label }() private lazy var isDoneSwitch: UISwitch = { let sw = UISwitch() return sw }() private lazy var deleteButton: UIButton = { let btn = UIButton(type: .system) btn.setTitle("Delete", for: .normal) btn.widthAnchor.constraint(equalToConstant: 50).isActive = true return btn }() private lazy var vStack: UIStackView = { let stack = UIStackView(arrangedSubviews: [titleLabel, idLabel]) stack.axis = .vertical stack.spacing = 8 return stack }() private lazy var hStack: UIStackView = { let stack = UIStackView(arrangedSubviews: [vStack, isDoneSwitch, deleteButton]) stack.axis = .horizontal stack.alignment = .center stack.spacing = 20 return stack }() override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) makeUI() constraints() // MARK: - 버튼 연결 isDoneSwitch.addTarget(self, action: #selector(handleIsDone), for: .valueChanged) deleteButton.addTarget(self, action: #selector(handleDeleteButton), for: .touchUpInside) } required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") } private func makeUI() { [hStack].forEach { contentView.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } } private func constraints() { NSLayoutConstraint.activate([ hStack.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 10), hStack.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20), hStack.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20), hStack.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -10), ]) } override func prepareForReuse() { super.prepareForReuse() print(#fileID, #function, #line, "prepareForReuse() - cellData.id: \(cellData?.id ?? UUID())") self.disposeBag = DisposeBag() } } extension RxTodoCell { func configure(with todo: RxTodo) { self.cellData = todo titleLabel.text = todo.title let idString = String(todo.id.uuidString.prefix(10)) idLabel.text = "ID: \(idString)" isDoneSwitch.isOn = todo.isDone // setRx() } // MARK: - 디버깅용 func configure(title: String, id: Int) { titleLabel.text = title idLabel.text = "ID: \(id)" isDoneSwitch.isOn = false } } extension RxTodoCell { @objc func handleIsDone(_ sender: UISwitch) { print(#fileID, #function, #line, "- id: \(cellData?.id.uuidString ?? "") sender: \(sender.isOn)") guard let id = self.cellData?.id else { return } isDoneChange?(id, sender.isOn) } @objc func handleDeleteButton(_ sender: UIButton) { guard let id = self.cellData?.id else { return } deleteAction?(id) } } #if DEBUG import SwiftUI // TodoCell 미리보기 struct RxTodoCell_Preview: PreviewProvider { static var previews: some View { let cell = RxTodoCell() cell.configure(title: "할 일 예제", id: 42) return cell.contentView .getPreview() .previewLayout(.fixed(width: 350, height: 100)) .background(Color.white) } } #endif // ViewController import UIKit import RxSwift import RxCocoa import RxRelay final class RxTodoViewController2: UIViewController { // MARK: - 구독에 대한 찌꺼기 처리 var disposeBag = DisposeBag() // MARK: - Relay는 Subject계열인데 끊어지지 않는다(.value로 접근시 마지막 데이터 확인가능 = stateful) var rxTodosRelay: BehaviorRelay&lt;[RxTodo]&gt; = BehaviorRelay(value: RxTodo.getDumies()) // MARK: - UI private lazy var addButton = UIBarButtonItem(title: "추가", style: .plain, target: nil, action: nil) private lazy var myTableView: UITableView = { let tv = UITableView() return tv }() override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white makeUI() constraints() // MARK: - 코드기반 사용한다면 myTableView.register(RxTodoCell.self, forCellReuseIdentifier: "RxTodoCell") // ✅ 1. RxTodoCell을 타입으로 명시하여 바인딩하는 간결한 방식 /* data.bind(to: myTableView.rx.items(cellIdentifier: RxTodoCell.reuseIdentifier, cellType: RxTodoCell.self)) { index, model, cell in cell.configure(with: model) } .disposed(by: disposeBag) */ // ✅ 2. (더 유연하지만 수동 캐스팅 필요 – RxCocoa) rxTodosRelay .bind(to: myTableView.rx.items) { (tableView, row, element) in guard let cell = tableView.dequeueReusableCell(withIdentifier: RxTodoCell.reuseIdentifier) as? RxTodoCell else { return UITableViewCell()} cell.configure(with: element) // MARK: - 셀의 delete버튼 선택되었을 때 액션을 여기서 처리 cell.deleteAction = { id in let currentTodos = self.rxTodosRelay.value let filteredTodos = currentTodos.filter { $0.id != id } self.rxTodosRelay.accept(filteredTodos) } // MARK: - 셀의 토글 클릭시 액션을 여기서 처리 cell.isDoneChange = { [weak self] id, updatedIsDone in guard let self = self else { return } var currentTodos = self.rxTodosRelay.value // 일치하는것 찾기 if let foundTodoIndex = currentTodos.firstIndex(where: { $0.id == id }) { currentTodos[foundTodoIndex].isDone = updatedIsDone } self.rxTodosRelay.accept(currentTodos) } return cell } .disposed(by: disposeBag) // MARK: - 3초뒤 갱신 /* DispatchQueue.main.asyncAfter(deadline: .now() + 3) { self.rxTodosRelay.accept(RxTodo.getDumies(count: 3)) } */ // MARK: - Rx스러운 3초뒤 갱신 /* Observable.just(()) .delay(.seconds(3), scheduler: MainScheduler.instance) // Observable&lt;Void&gt; .map { RxTodo.getDumies(count: 5) } // Observable&lt;[RxTodo]&gt; .bind(onNext: self.rxTodosRelay.accept(_:)) // 같은 자료형이면 클로저가 들어갈 수 있다 .disposed(by: disposeBag) */ // MARK: - 버튼 연결 addButton.rx.tap .bind(onNext: { [weak self] _ in guard let self = self else { return } var currentTodos = self.rxTodosRelay.value // .value 하면 마지막에 보낸 데이터 할 수 있음 currentTodos.insert(RxTodo(), at: 0) // 첫번째 열에 넣겠다 self.rxTodosRelay.accept(currentTodos) }) .disposed(by: disposeBag) } private func makeUI() { [myTableView].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } // 네비게이션 버튼 navigationItem.rightBarButtonItems = [addButton] } private func constraints() { NSLayoutConstraint.activate([ myTableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor), myTableView.leadingAnchor.constraint(equalTo: view.leadingAnchor), myTableView.trailingAnchor.constraint(equalTo: view.trailingAnchor), myTableView.bottomAnchor.constraint(equalTo: view.bottomAnchor) ]) } }]]></summary></entry><entry><title type="html">[RxDataSource] 4. Rx로 테이블 사용해보기</title><link href="http://localhost:4000/RxDataSource-RxDataSource-4/" rel="alternate" type="text/html" title="[RxDataSource] 4. Rx로 테이블 사용해보기" /><published>2025-09-13T00:00:00+00:00</published><updated>2025-09-13T00:00:00+00:00</updated><id>http://localhost:4000/%5BRxDataSource%5D-RxDataSource-4</id><content type="html" xml:base="http://localhost:4000/RxDataSource-RxDataSource-4/"><![CDATA[<h1 id="정리">정리</h1>
<p>기본적인 Rx테이블 사용방법에 대해 코드로 작성하였다.  <br />
셀을 Nib파일로 사용하거나 코드기반으로 사용함에 따라서 register 사용방식이 다르다는 것만 이해하면 된다. 다음 포스팅에서 RxDatasource로 CRUD로 진행해볼 예정이다.</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Nib파일 사용한다면</span>
<span class="k">let</span> <span class="nv">cellNib</span> <span class="o">=</span> <span class="kt">UINib</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="s">"RxTodoCell"</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
<span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="n">cellNib</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="s">"RxTodoCell"</span><span class="p">)</span>

<span class="c1">// MARK: - 코드기반 사용한다면</span>
<span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">RxTodoCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="s">"RxTodoCell"</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="전체코드">전체코드</h1>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Model</span>
<span class="kd">import</span> <span class="kt">Fakery</span>
<span class="kd">import</span> <span class="kt">UIKit</span>

<span class="c1">// MARK: - Model</span>
<span class="kd">struct</span> <span class="kt">RxTodo</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span> <span class="o">=</span> <span class="kt">UUID</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">isDone</span><span class="p">:</span> <span class="kt">Bool</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
         <span class="nv">isDone</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="k">self</span><span class="o">.</span><span class="n">isDone</span> <span class="o">=</span> <span class="n">isDone</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">getDumies</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">RxTodo</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">faker</span> <span class="o">=</span> <span class="kt">Faker</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="s">"ko"</span><span class="p">)</span>
        <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="p">[</span><span class="kt">RxTodo</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="n">count</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">firstName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">firstName</span><span class="p">()</span>
            <span class="k">let</span> <span class="nv">lastName</span> <span class="o">=</span> <span class="n">faker</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">lastName</span><span class="p">()</span>
            <span class="k">let</span> <span class="nv">title</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">lastName</span><span class="se">)</span><span class="s"> </span><span class="se">\(</span><span class="n">firstName</span><span class="se">)</span><span class="s">"</span>
            <span class="n">result</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="kt">RxTodo</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="n">title</span><span class="p">,</span> <span class="nv">isDone</span><span class="p">:</span> <span class="kc">false</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cell</span>
<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">RxSwift</span>
<span class="kd">import</span> <span class="kt">RxCocoa</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">RxTodoCell</span><span class="p">:</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>

    <span class="k">var</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">RxTodo</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>

    <span class="c1">// MARK: - Rx</span>
    <span class="k">var</span> <span class="nv">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">deleteActionObservable</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">UUID</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">empty</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">updateActionObservable</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span><span class="p">,</span> <span class="nv">newValue</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">empty</span><span class="p">()</span>


    <span class="kd">private</span> <span class="k">let</span> <span class="nv">titleLabel</span><span class="p">:</span> <span class="kt">UILabel</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
        <span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"제목"</span>
        <span class="n">label</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">label</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="kt">UIFont</span><span class="o">.</span><span class="nf">systemFont</span><span class="p">(</span><span class="nv">ofSize</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">bold</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">label</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="k">let</span> <span class="nv">idLabel</span><span class="p">:</span> <span class="kt">UILabel</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
        <span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"아이디"</span>
        <span class="n">label</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">label</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="kt">UIFont</span><span class="o">.</span><span class="nf">systemFont</span><span class="p">(</span><span class="nv">ofSize</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">regular</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">label</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">isDoneSwitch</span><span class="p">:</span> <span class="kt">UISwitch</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">sw</span> <span class="o">=</span> <span class="kt">UISwitch</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sw</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">deleteButton</span><span class="p">:</span> <span class="kt">UIButton</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">btn</span> <span class="o">=</span> <span class="kt">UIButton</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">system</span><span class="p">)</span>
        <span class="n">btn</span><span class="o">.</span><span class="nf">setTitle</span><span class="p">(</span><span class="s">"Delete"</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">btn</span><span class="o">.</span><span class="n">widthAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalToConstant</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">isActive</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="k">return</span> <span class="n">btn</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">vStack</span><span class="p">:</span> <span class="kt">UIStackView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">stack</span> <span class="o">=</span> <span class="kt">UIStackView</span><span class="p">(</span><span class="nv">arrangedSubviews</span><span class="p">:</span> <span class="p">[</span><span class="n">titleLabel</span><span class="p">,</span> <span class="n">idLabel</span><span class="p">])</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="o">.</span><span class="n">vertical</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">hStack</span><span class="p">:</span> <span class="kt">UIStackView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">stack</span> <span class="o">=</span> <span class="kt">UIStackView</span><span class="p">(</span><span class="nv">arrangedSubviews</span><span class="p">:</span> <span class="p">[</span><span class="n">vStack</span><span class="p">,</span> <span class="n">isDoneSwitch</span><span class="p">,</span> <span class="n">deleteButton</span><span class="p">])</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="o">.</span><span class="n">horizontal</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="o">.</span><span class="n">center</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="p">}()</span>

    <span class="k">override</span> <span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">.</span><span class="kt">CellStyle</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="n">style</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="n">reuseIdentifier</span><span class="p">)</span>
        <span class="nf">makeUI</span><span class="p">()</span>
        <span class="nf">constraints</span><span class="p">()</span>
        <span class="c1">// setRx()</span>
    <span class="p">}</span>

    <span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="nv">coder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">fatalError</span><span class="p">(</span><span class="s">"init(coder:) has not been implemented"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeUI</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">hStack</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="n">contentView</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">constraints</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">NSLayoutConstraint</span><span class="o">.</span><span class="nf">activate</span><span class="p">([</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">topAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="mi">10</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="mi">20</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">),</span>
        <span class="p">])</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">prepareForReuse</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">prepareForReuse</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"prepareForReuse() - cellData.id: </span><span class="se">\(</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="p">??</span> <span class="kt">UUID</span><span class="p">()</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">setRx</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- "</span><span class="p">)</span>
        <span class="n">updateActionObservable</span> <span class="o">=</span> <span class="n">isDoneSwitch</span>
            <span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">isOn</span>
            <span class="o">.</span><span class="nf">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                 <span class="c1">// 초기값 무시</span>
            <span class="o">.</span><span class="nf">debug</span><span class="p">(</span><span class="s">"isDoneSwitch"</span><span class="p">)</span>
            <span class="c1">/// nul을 제거하고 유효한 값만 방출하는 오퍼레이터</span>
            <span class="c1">/// self 또는 cellData 존재하지 않을 수 있어서 compactMap 사용</span>
            <span class="o">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">isOn</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span><span class="p">,</span> <span class="nv">newValue</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)?</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span><span class="p">,</span>
                      <span class="k">let</span> <span class="nv">inWrappedId</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kc">nil</span>
                <span class="p">}</span>
                <span class="c1">// return (id: inWrappedId, newValue: self.isDoneSwitch.isOn)</span>
                <span class="nf">return</span> <span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="n">inWrappedId</span><span class="p">,</span> <span class="nv">newValue</span><span class="p">:</span> <span class="n">isOn</span><span class="p">)</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">RxTodoCell</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">configure</span><span class="p">(</span><span class="n">with</span> <span class="nv">todo</span><span class="p">:</span> <span class="kt">RxTodo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">cellData</span> <span class="o">=</span> <span class="n">todo</span>
        <span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">title</span>

        <span class="k">let</span> <span class="nv">idString</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">todo</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">uuidString</span><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
        <span class="n">idLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"ID: </span><span class="se">\(</span><span class="n">idString</span><span class="se">)</span><span class="s">"</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">isOn</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">isDone</span>
        <span class="nf">setRx</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// MARK: - 디버깅용</span>
    <span class="kd">func</span> <span class="nf">configure</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">title</span>
        <span class="n">idLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"ID: </span><span class="se">\(</span><span class="n">id</span><span class="se">)</span><span class="s">"</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">isOn</span> <span class="o">=</span> <span class="kc">false</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if DEBUG</span>
<span class="kd">import</span> <span class="kt">SwiftUI</span>
<span class="c1">// TodoCell 미리보기</span>
<span class="kd">struct</span> <span class="kt">RxTodoCell_Preview</span><span class="p">:</span> <span class="kt">PreviewProvider</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">previews</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="kt">RxTodoCell</span><span class="p">()</span>
        <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"할 일 예제"</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="mi">42</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cell</span><span class="o">.</span><span class="n">contentView</span>
            <span class="o">.</span><span class="nf">getPreview</span><span class="p">()</span>
            <span class="o">.</span><span class="nf">previewLayout</span><span class="p">(</span><span class="o">.</span><span class="nf">fixed</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">350</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">))</span>
            <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="kt">Color</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</code></pre></div></div>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ViewController</span>
<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">RxSwift</span>
<span class="kd">import</span> <span class="kt">RxCocoa</span>
<span class="kd">import</span> <span class="kt">RxRelay</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">RxTodoViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="c1">// MARK: - 구독에 대한 찌꺼기 처리</span>
    <span class="k">var</span> <span class="nv">disposeBag</span> <span class="o">=</span>  <span class="kt">DisposeBag</span><span class="p">()</span>

    <span class="c1">// MARK: - UI</span>
    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">addButton</span> <span class="o">=</span> <span class="kt">UIBarButtonItem</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"추가"</span><span class="p">,</span>
                                                 <span class="nv">style</span><span class="p">:</span> <span class="o">.</span><span class="n">plain</span><span class="p">,</span>
                                                 <span class="nv">target</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
                                                 <span class="nv">action</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">tv</span> <span class="o">=</span> <span class="kt">UITableView</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tv</span>
    <span class="p">}()</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">white</span>
        <span class="nf">makeUI</span><span class="p">()</span>
        <span class="nf">constraints</span><span class="p">()</span>
        
        <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">RxTodo</span><span class="p">]</span><span class="o">&gt;.</span><span class="nf">just</span><span class="p">(</span><span class="kt">RxTodo</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">())</span>
        
        <span class="c1">// MARK: - Nib파일 사용한다면</span>
        <span class="c1">// let cellNib = UINib(nibName: "RxTodoCell", bundle: nil)</span>
        <span class="c1">// myTableView.register(cellNib, forCellReuseIdentifier: "RxTodoCell")</span>
        
        <span class="c1">// MARK: - 코드기반 사용한다면</span>
        <span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">RxTodoCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="s">"RxTodoCell"</span><span class="p">)</span>

        
        <span class="n">data</span><span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">myTableView</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">items</span><span class="p">(</span><span class="nv">cellIdentifier</span><span class="p">:</span> <span class="s">"RxTodoCell"</span><span class="p">,</span> <span class="nv">cellType</span><span class="p">:</span> <span class="kt">RxTodoCell</span><span class="o">.</span><span class="k">self</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">cell</span> <span class="k">in</span>
            <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
            
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeUI</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">myTableView</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="n">view</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
        
        <span class="c1">// 네비게이션 버튼</span>
        <span class="n">navigationItem</span><span class="o">.</span><span class="n">rightBarButtonItems</span> <span class="o">=</span> <span class="p">[</span><span class="n">addButton</span><span class="p">]</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">constraints</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">NSLayoutConstraint</span><span class="o">.</span><span class="nf">activate</span><span class="p">([</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">safeAreaLayoutGuide</span><span class="o">.</span><span class="n">topAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="ReactiveX" /><category term="RxDataSource" /><summary type="html"><![CDATA[정리 기본적인 Rx테이블 사용방법에 대해 코드로 작성하였다. 셀을 Nib파일로 사용하거나 코드기반으로 사용함에 따라서 register 사용방식이 다르다는 것만 이해하면 된다. 다음 포스팅에서 RxDatasource로 CRUD로 진행해볼 예정이다. // MARK: - Nib파일 사용한다면 let cellNib = UINib(nibName: "RxTodoCell", bundle: nil) myTableView.register(cellNib, forCellReuseIdentifier: "RxTodoCell") // MARK: - 코드기반 사용한다면 myTableView.register(RxTodoCell.self, forCellReuseIdentifier: "RxTodoCell") 전체코드 // Model import Fakery import UIKit // MARK: - Model struct RxTodo { let id: UUID = UUID() let title: String var isDone: Bool init(title: String, isDone: Bool = false ) { self.title = title self.isDone = isDone } static func getDumies(count: Int = 10) -&gt; [RxTodo] { let faker = Faker(locale: "ko") var result: [RxTodo] = [] for _ in 1...count { let firstName = faker.name.firstName() let lastName = faker.name.lastName() let title = "\(lastName) \(firstName)" result.append(RxTodo(title: title, isDone: false)) } return result } } // Cell import UIKit import RxSwift import RxCocoa final class RxTodoCell: UITableViewCell { var cellData: RxTodo? = nil // MARK: - Rx var disposeBag = DisposeBag() var deleteActionObservable: Observable&lt;UUID&gt; = Observable.empty() var updateActionObservable: Observable&lt;(id: UUID, newValue: Bool)&gt; = Observable.empty() private let titleLabel: UILabel = { let label = UILabel() label.text = "제목" label.numberOfLines = 1 label.font = UIFont.systemFont(ofSize: 14, weight: .bold) return label }() private let idLabel: UILabel = { let label = UILabel() label.text = "아이디" label.numberOfLines = 0 label.font = UIFont.systemFont(ofSize: 12, weight: .regular) return label }() private lazy var isDoneSwitch: UISwitch = { let sw = UISwitch() return sw }() private lazy var deleteButton: UIButton = { let btn = UIButton(type: .system) btn.setTitle("Delete", for: .normal) btn.widthAnchor.constraint(equalToConstant: 50).isActive = true return btn }() private lazy var vStack: UIStackView = { let stack = UIStackView(arrangedSubviews: [titleLabel, idLabel]) stack.axis = .vertical stack.spacing = 8 return stack }() private lazy var hStack: UIStackView = { let stack = UIStackView(arrangedSubviews: [vStack, isDoneSwitch, deleteButton]) stack.axis = .horizontal stack.alignment = .center stack.spacing = 20 return stack }() override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) makeUI() constraints() // setRx() } required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") } private func makeUI() { [hStack].forEach { contentView.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } } private func constraints() { NSLayoutConstraint.activate([ hStack.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 10), hStack.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20), hStack.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20), hStack.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -10), ]) } override func prepareForReuse() { super.prepareForReuse() print(#fileID, #function, #line, "prepareForReuse() - cellData.id: \(cellData?.id ?? UUID())") self.disposeBag = DisposeBag() } private func setRx() { print(#fileID, #function, #line, "- ") updateActionObservable = isDoneSwitch .rx.isOn .skip(1) // 초기값 무시 .debug("isDoneSwitch") /// nul을 제거하고 유효한 값만 방출하는 오퍼레이터 /// self 또는 cellData 존재하지 않을 수 있어서 compactMap 사용 .compactMap { [weak self] isOn -&gt; (id: UUID, newValue: Bool)? in guard let self = self, let inWrappedId = self.cellData?.id else { return nil } // return (id: inWrappedId, newValue: self.isDoneSwitch.isOn) return (id: inWrappedId, newValue: isOn) } } } extension RxTodoCell { func configure(with todo: RxTodo) { self.cellData = todo titleLabel.text = todo.title let idString = String(todo.id.uuidString.prefix(10)) idLabel.text = "ID: \(idString)" isDoneSwitch.isOn = todo.isDone setRx() } // MARK: - 디버깅용 func configure(title: String, id: Int) { titleLabel.text = title idLabel.text = "ID: \(id)" isDoneSwitch.isOn = false } } #if DEBUG import SwiftUI // TodoCell 미리보기 struct RxTodoCell_Preview: PreviewProvider { static var previews: some View { let cell = RxTodoCell() cell.configure(title: "할 일 예제", id: 42) return cell.contentView .getPreview() .previewLayout(.fixed(width: 350, height: 100)) .background(Color.white) } } #endif // ViewController import UIKit import RxSwift import RxCocoa import RxRelay final class RxTodoViewController: UIViewController { // MARK: - 구독에 대한 찌꺼기 처리 var disposeBag = DisposeBag() // MARK: - UI private lazy var addButton = UIBarButtonItem(title: "추가", style: .plain, target: nil, action: nil) private lazy var myTableView: UITableView = { let tv = UITableView() return tv }() override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white makeUI() constraints() let data = Observable&lt;[RxTodo]&gt;.just(RxTodo.getDumies()) // MARK: - Nib파일 사용한다면 // let cellNib = UINib(nibName: "RxTodoCell", bundle: nil) // myTableView.register(cellNib, forCellReuseIdentifier: "RxTodoCell") // MARK: - 코드기반 사용한다면 myTableView.register(RxTodoCell.self, forCellReuseIdentifier: "RxTodoCell") data.bind(to: myTableView.rx.items(cellIdentifier: "RxTodoCell", cellType: RxTodoCell.self)) { index, model, cell in cell.configure(with: model) } .disposed(by: disposeBag) } private func makeUI() { [myTableView].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } // 네비게이션 버튼 navigationItem.rightBarButtonItems = [addButton] } private func constraints() { NSLayoutConstraint.activate([ myTableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor), myTableView.leadingAnchor.constraint(equalTo: view.leadingAnchor), myTableView.trailingAnchor.constraint(equalTo: view.trailingAnchor), myTableView.bottomAnchor.constraint(equalTo: view.bottomAnchor) ]) } }]]></summary></entry><entry><title type="html">[RxDataSource] 6. 버튼 액션을 Rx로 연결하기 with 성능 이슈 해결</title><link href="http://localhost:4000/RxDataSource-RxDataSource-6/" rel="alternate" type="text/html" title="[RxDataSource] 6. 버튼 액션을 Rx로 연결하기 with 성능 이슈 해결" /><published>2025-09-13T00:00:00+00:00</published><updated>2025-09-13T00:00:00+00:00</updated><id>http://localhost:4000/%5BRxDataSource%5D-RxDataSource-6</id><content type="html" xml:base="http://localhost:4000/RxDataSource-RxDataSource-6/"><![CDATA[<h1 id="기존-코드-개선">기존 코드 개선</h1>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">.</span><span class="kt">CellStyle</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="n">style</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="n">reuseIdentifier</span><span class="p">)</span>
    <span class="nf">makeUI</span><span class="p">()</span>
    <span class="nf">constraints</span><span class="p">()</span>
    
    <span class="c1">// MARK: - 버튼 연결</span>
    <span class="c1">// isDoneSwitch.addTarget(self, action: #selector(handleIsDone), for: .valueChanged)</span>
    <span class="c1">// deleteButton.addTarget(self, action: #selector(handleDeleteButton), for: .touchUpInside)</span>
<span class="p">}</span>

<span class="c1">// MARK: - Rx로 버튼 연결</span>
<span class="kd">func</span> <span class="nf">setRx</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="c1">// MARK: - 초기 이벤트를 버리고 이후부터 모두 전달받겠다</span>
    <span class="cm">/*
    isDoneSwitch.rx.isOn
        .skip(1) // 처음 방출값 무시(초기값 세팅 이벤트 무시)
        .debug("isDoneSwitch 디버그")
        .bind(onNext: { [weak self] isOn in
            guard let self = self, let id = self.cellData?.id else { return }
            self.isDoneChange?(id, isOn)
        })
        .disposed(by: disposeBag)
        */</span>
    
    <span class="c1">// MARK: - 스위치가 valueChanged이벤트를 낼 때만 트리거 하겠다 &amp; 해당시점은 isOn 값을 가져오겠다</span>
    <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">controlEvent</span><span class="p">(</span><span class="o">.</span><span class="n">valueChanged</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">withLatestFrom</span><span class="p">(</span><span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">isOn</span><span class="p">)</span> <span class="c1">// 토글 후 최신값 가져오기</span>
        <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">isOn</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span><span class="p">,</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="k">self</span><span class="o">.</span><span class="nf">isDoneChange</span><span class="p">?(</span><span class="n">id</span><span class="p">,</span> <span class="n">isOn</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
    
    <span class="n">deleteButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span>
        <span class="o">.</span><span class="nf">debug</span><span class="p">(</span><span class="s">"deleteButton 디버그"</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span><span class="p">,</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="k">self</span><span class="o">.</span><span class="nf">deleteAction</span><span class="p">?(</span><span class="n">id</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>기존 커스텀 셀의 버튼 연결 방식은 addTarget인데 Rx스럽게 하기 위해 주석처리 및 setRx()함수를 만들었다.   <br />
setRx()은 configure 함수에서 호출하도록 하였다.<br />
지금은 이벤트 처리 자체를 클로저로 주고 있는데 이렇게 말고 deleteButton.rx.tap 자체를 외부에서 넘겨줄 수 있다. deleteActionObservable을 만들어서 외부에서 주입하도록 해보자.</p>

<h1 id="rxtodocell-수정">RxTodoCell 수정</h1>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">deleteActionObservalble</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">UUID</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">empty</span><span class="p">()</span>

    <span class="c1">// MARK: - Rx로 버튼 연결</span>
    <span class="kd">func</span> <span class="nf">setRx</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="c1">// MARK: - 초기 이벤트를 버리고 이후부터 모두 전달받겠다</span>
        <span class="cm">/*
        isDoneSwitch.rx.isOn
            .skip(1) // 처음 방출값 무시(초기값 세팅 이벤트 무시)
            .debug("isDoneSwitch 디버그")
            .bind(onNext: { [weak self] isOn in
                guard let self = self, let id = self.cellData?.id else { return }
                self.isDoneChange?(id, isOn)
            })
            .disposed(by: disposeBag)
         */</span>
        
        <span class="c1">// MARK: - 스위치가 valueChanged이벤트를 낼 때만 트리거 하겠다 &amp; 해당시점은 isOn 값을 가져오겠다</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">controlEvent</span><span class="p">(</span><span class="o">.</span><span class="n">valueChanged</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">withLatestFrom</span><span class="p">(</span><span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">isOn</span><span class="p">)</span> <span class="c1">// 토글 후 최신값 가져오기</span>
            <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">isOn</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span><span class="p">,</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
                <span class="k">self</span><span class="o">.</span><span class="nf">isDoneChange</span><span class="p">?(</span><span class="n">id</span><span class="p">,</span> <span class="n">isOn</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
        
        <span class="c1">// MARK: - 기존 방식</span>
        <span class="cm">/*
        deleteButton.rx.tap
            .debug("deleteButton 디버그")
            .bind(onNext: { [weak self] _ in
                guard let self = self, let id = self.cellData?.id else { return }
                self.deleteAction?(id)
            })
            .disposed(by: disposeBag)
         */</span>
        
        <span class="c1">// MARK: - 개선된 방식(클로저를 전달안하고싶고 옵저버블로 하고싶다면)</span>
        <span class="n">deleteActionObservalble</span> <span class="o">=</span> <span class="n">deleteButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span>
            <span class="o">.</span><span class="nf">debug</span><span class="p">(</span><span class="s">"deleteButton 디버그"</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">compactMap</span><span class="p">({</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
                <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span>
            <span class="p">})</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>deleteActionObservalble을 선언해주고 기존 방식을 주석처리하고 deleteActionObservalble을 연결해주었다. 나머지는 viewController에서 진행하면 된다.<br />
<br /><br /><br /><br /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ 2. (더 유연하지만 수동 캐스팅 필요 – RxCocoa)</span>
<span class="n">rxTodosRelay</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">myTableView</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">tableView</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">RxTodoCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">RxTodoCell</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()}</span>
        <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">element</span><span class="p">)</span>
        
        <span class="c1">// MARK: - 셀의 delete버튼 선택되었을 때 액션을 여기서 처리</span>
<span class="c1">//                cell.deleteAction = { id in</span>
<span class="c1">//                    let currentTodos = self.rxTodosRelay.value</span>
<span class="c1">//                    let filteredTodos = currentTodos.filter { $0.id != id }</span>
<span class="c1">//                    self.rxTodosRelay.accept(filteredTodos)</span>
<span class="c1">//                }</span>
        
        <span class="c1">// MARK: - 개선방식(bind대신 map도 가능)</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">deleteActionObservalble</span>
            <span class="o">.</span><span class="nf">withUnretained</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">debug</span><span class="p">(</span><span class="s">"deleteActionObservalble"</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">vc</span><span class="p">,</span> <span class="n">uuid</span> <span class="k">in</span>
                <span class="k">let</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span>
                <span class="k">let</span> <span class="nv">filteredTodos</span> <span class="o">=</span> <span class="n">currentTodos</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="n">uuid</span> <span class="p">}</span>
                <span class="k">return</span> <span class="n">filteredTodos</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">disposeBag</span><span class="p">)</span>

            
        
        <span class="c1">// MARK: - 셀의 토글 클릭시 액션을 여기서 처리</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">isDoneChange</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">id</span><span class="p">,</span> <span class="n">updatedIsDone</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="k">var</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span>
            <span class="c1">// 일치하는것 찾기</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">foundTodoIndex</span> <span class="o">=</span> <span class="n">currentTodos</span><span class="o">.</span><span class="nf">firstIndex</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="p">})</span> <span class="p">{</span>
                <span class="n">currentTodos</span><span class="p">[</span><span class="n">foundTodoIndex</span><span class="p">]</span><span class="o">.</span><span class="n">isDone</span> <span class="o">=</span> <span class="n">updatedIsDone</span>
            <span class="p">}</span>
            <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">currentTodos</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">cell</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<p>기존 deleteAction을 주석처리후 deleteActionObservalble을 연결해준다 이때 bind대신 map으로 해주어도 된다.<br />
<br /><br /><br /><br /></p>

<h1 id="전체-코드">전체 코드</h1>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cell</span>
<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">RxSwift</span>
<span class="kd">import</span> <span class="kt">RxCocoa</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">RxTodoCell</span><span class="p">:</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>

    <span class="k">var</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">RxTodo</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>

    <span class="c1">// MARK: - Rx</span>
    <span class="k">var</span> <span class="nv">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">isDoneChange</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span><span class="p">,</span> <span class="n">_</span> <span class="nv">newValue</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="k">var</span> <span class="nv">deleteAction</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="k">var</span> <span class="nv">deleteActionObservalble</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">UUID</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">empty</span><span class="p">()</span>

    <span class="kd">private</span> <span class="k">let</span> <span class="nv">titleLabel</span><span class="p">:</span> <span class="kt">UILabel</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
        <span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"제목"</span>
        <span class="n">label</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">label</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="kt">UIFont</span><span class="o">.</span><span class="nf">systemFont</span><span class="p">(</span><span class="nv">ofSize</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">bold</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">label</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="k">let</span> <span class="nv">idLabel</span><span class="p">:</span> <span class="kt">UILabel</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
        <span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"아이디"</span>
        <span class="n">label</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">label</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="kt">UIFont</span><span class="o">.</span><span class="nf">systemFont</span><span class="p">(</span><span class="nv">ofSize</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">regular</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">label</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">isDoneSwitch</span><span class="p">:</span> <span class="kt">UISwitch</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">sw</span> <span class="o">=</span> <span class="kt">UISwitch</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sw</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">deleteButton</span><span class="p">:</span> <span class="kt">UIButton</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">btn</span> <span class="o">=</span> <span class="kt">UIButton</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">system</span><span class="p">)</span>
        <span class="n">btn</span><span class="o">.</span><span class="nf">setTitle</span><span class="p">(</span><span class="s">"Delete"</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">btn</span><span class="o">.</span><span class="n">widthAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalToConstant</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">isActive</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="k">return</span> <span class="n">btn</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">vStack</span><span class="p">:</span> <span class="kt">UIStackView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">stack</span> <span class="o">=</span> <span class="kt">UIStackView</span><span class="p">(</span><span class="nv">arrangedSubviews</span><span class="p">:</span> <span class="p">[</span><span class="n">titleLabel</span><span class="p">,</span> <span class="n">idLabel</span><span class="p">])</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="o">.</span><span class="n">vertical</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="p">}()</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">hStack</span><span class="p">:</span> <span class="kt">UIStackView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">stack</span> <span class="o">=</span> <span class="kt">UIStackView</span><span class="p">(</span><span class="nv">arrangedSubviews</span><span class="p">:</span> <span class="p">[</span><span class="n">vStack</span><span class="p">,</span> <span class="n">isDoneSwitch</span><span class="p">,</span> <span class="n">deleteButton</span><span class="p">])</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="o">.</span><span class="n">horizontal</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="o">.</span><span class="n">center</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="p">}()</span>

    <span class="k">override</span> <span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">.</span><span class="kt">CellStyle</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">style</span><span class="p">:</span> <span class="n">style</span><span class="p">,</span> <span class="nv">reuseIdentifier</span><span class="p">:</span> <span class="n">reuseIdentifier</span><span class="p">)</span>
        <span class="nf">makeUI</span><span class="p">()</span>
        <span class="nf">constraints</span><span class="p">()</span>
        
        <span class="c1">// MARK: - 버튼 연결</span>
        <span class="c1">// isDoneSwitch.addTarget(self, action: #selector(handleIsDone), for: .valueChanged)</span>
        <span class="c1">// deleteButton.addTarget(self, action: #selector(handleDeleteButton), for: .touchUpInside)</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - Rx로 버튼 연결</span>
    <span class="kd">func</span> <span class="nf">setRx</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="c1">// MARK: - 초기 이벤트를 버리고 이후부터 모두 전달받겠다</span>
        <span class="cm">/*
        isDoneSwitch.rx.isOn
            .skip(1) // 처음 방출값 무시(초기값 세팅 이벤트 무시)
            .debug("isDoneSwitch 디버그")
            .bind(onNext: { [weak self] isOn in
                guard let self = self, let id = self.cellData?.id else { return }
                self.isDoneChange?(id, isOn)
            })
            .disposed(by: disposeBag)
         */</span>
        
        <span class="c1">// MARK: - 스위치가 valueChanged이벤트를 낼 때만 트리거 하겠다 &amp; 해당시점은 isOn 값을 가져오겠다</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">controlEvent</span><span class="p">(</span><span class="o">.</span><span class="n">valueChanged</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">withLatestFrom</span><span class="p">(</span><span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">isOn</span><span class="p">)</span> <span class="c1">// 토글 후 최신값 가져오기</span>
            <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">isOn</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span><span class="p">,</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
                <span class="k">self</span><span class="o">.</span><span class="nf">isDoneChange</span><span class="p">?(</span><span class="n">id</span><span class="p">,</span> <span class="n">isOn</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
        
        <span class="c1">// MARK: - 기존 방식</span>
        <span class="cm">/*
        deleteButton.rx.tap
            .debug("deleteButton 디버그")
            .bind(onNext: { [weak self] _ in
                guard let self = self, let id = self.cellData?.id else { return }
                self.deleteAction?(id)
            })
            .disposed(by: disposeBag)
         */</span>
        
        <span class="c1">// MARK: - 개선된 방식(클로저를 전달안하고싶고 옵저버블로 하고싶다면)</span>
        <span class="n">deleteActionObservalble</span> <span class="o">=</span> <span class="n">deleteButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span>
            <span class="o">.</span><span class="nf">debug</span><span class="p">(</span><span class="s">"deleteButton 디버그"</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">compactMap</span><span class="p">({</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
                <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span>
            <span class="p">})</span>
    <span class="p">}</span>

    <span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="nv">coder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">fatalError</span><span class="p">(</span><span class="s">"init(coder:) has not been implemented"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeUI</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">hStack</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="n">contentView</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">constraints</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">NSLayoutConstraint</span><span class="o">.</span><span class="nf">activate</span><span class="p">([</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">topAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="mi">10</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="mi">20</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">),</span>
            <span class="n">hStack</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">contentView</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">),</span>
        <span class="p">])</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">prepareForReuse</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">prepareForReuse</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"prepareForReuse() - cellData.id: </span><span class="se">\(</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="p">??</span> <span class="kt">UUID</span><span class="p">()</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span> <span class="c1">// MARK: - 이전 구독을 끊어주는 작업</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">RxTodoCell</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">configure</span><span class="p">(</span><span class="n">with</span> <span class="nv">todo</span><span class="p">:</span> <span class="kt">RxTodo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">cellData</span> <span class="o">=</span> <span class="n">todo</span>
        <span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">title</span>

        <span class="k">let</span> <span class="nv">idString</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">todo</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">uuidString</span><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
        <span class="n">idLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"ID: </span><span class="se">\(</span><span class="n">idString</span><span class="se">)</span><span class="s">"</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">isOn</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">isDone</span>
        <span class="nf">setRx</span><span class="p">()</span>
    <span class="p">}</span>
 
    <span class="c1">// MARK: - 디버깅용</span>
    <span class="kd">func</span> <span class="nf">configure</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">title</span>
        <span class="n">idLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"ID: </span><span class="se">\(</span><span class="n">id</span><span class="se">)</span><span class="s">"</span>
        <span class="n">isDoneSwitch</span><span class="o">.</span><span class="n">isOn</span> <span class="o">=</span> <span class="kc">false</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">RxTodoCell</span> <span class="p">{</span>
    <span class="kd">@objc</span> <span class="kd">func</span> <span class="nf">handleIsDone</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UISwitch</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- id: </span><span class="se">\(</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">uuidString</span> <span class="p">??</span> <span class="s">""</span><span class="se">)</span><span class="s"> sender: </span><span class="se">\(</span><span class="n">sender</span><span class="o">.</span><span class="n">isOn</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="nf">isDoneChange</span><span class="p">?(</span><span class="n">id</span><span class="p">,</span> <span class="n">sender</span><span class="o">.</span><span class="n">isOn</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">@objc</span> <span class="kd">func</span> <span class="nf">handleDeleteButton</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="nf">deleteAction</span><span class="p">?(</span><span class="n">id</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if DEBUG</span>
<span class="kd">import</span> <span class="kt">SwiftUI</span>
<span class="c1">// TodoCell 미리보기</span>
<span class="kd">struct</span> <span class="kt">RxTodoCell_Preview</span><span class="p">:</span> <span class="kt">PreviewProvider</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">previews</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="kt">RxTodoCell</span><span class="p">()</span>
        <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"할 일 예제"</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="mi">42</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cell</span><span class="o">.</span><span class="n">contentView</span>
            <span class="o">.</span><span class="nf">getPreview</span><span class="p">()</span>
            <span class="o">.</span><span class="nf">previewLayout</span><span class="p">(</span><span class="o">.</span><span class="nf">fixed</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">350</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">))</span>
            <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="kt">Color</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</code></pre></div></div>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ViewController</span>
<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">RxSwift</span>
<span class="kd">import</span> <span class="kt">RxCocoa</span>
<span class="kd">import</span> <span class="kt">RxRelay</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">RxTodoViewController4</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="c1">// MARK: - 구독에 대한 찌꺼기 처리</span>
    <span class="k">var</span> <span class="nv">disposeBag</span> <span class="o">=</span>  <span class="kt">DisposeBag</span><span class="p">()</span>
    
    <span class="c1">// MARK: - Relay는 Subject계열인데 끊어지지 않는다(.value로 접근시 마지막 데이터 확인가능 = stateful)</span>
    <span class="k">var</span> <span class="nv">rxTodosRelay</span><span class="p">:</span> <span class="kt">BehaviorRelay</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">RxTodo</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">BehaviorRelay</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">RxTodo</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">())</span>

    <span class="c1">// MARK: - UI</span>
    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">addButton</span> <span class="o">=</span> <span class="kt">UIBarButtonItem</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"추가"</span><span class="p">,</span>
                                                 <span class="nv">style</span><span class="p">:</span> <span class="o">.</span><span class="n">plain</span><span class="p">,</span>
                                                 <span class="nv">target</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
                                                 <span class="nv">action</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>

    <span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">tv</span> <span class="o">=</span> <span class="kt">UITableView</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tv</span>
    <span class="p">}()</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">white</span>
        <span class="nf">makeUI</span><span class="p">()</span>
        <span class="nf">constraints</span><span class="p">()</span>
        
        <span class="c1">// MARK: - 코드기반 사용한다면</span>
        <span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">RxTodoCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="s">"RxTodoCell"</span><span class="p">)</span>

        <span class="c1">// ✅ 2. (더 유연하지만 수동 캐스팅 필요 – RxCocoa)</span>
        <span class="n">rxTodosRelay</span>
            <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">myTableView</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">tableView</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">RxTodoCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">RxTodoCell</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()}</span>
                <span class="n">cell</span><span class="o">.</span><span class="nf">configure</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">element</span><span class="p">)</span>
                
                <span class="c1">// MARK: - 셀의 delete버튼 선택되었을 때 액션을 여기서 처리</span>
<span class="c1">//                cell.deleteAction = { id in</span>
<span class="c1">//                    let currentTodos = self.rxTodosRelay.value</span>
<span class="c1">//                    let filteredTodos = currentTodos.filter { $0.id != id }</span>
<span class="c1">//                    self.rxTodosRelay.accept(filteredTodos)</span>
<span class="c1">//                }</span>
                
                <span class="c1">// MARK: - 개선방식(bind대신 map도 가능)</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">deleteActionObservalble</span>
                    <span class="o">.</span><span class="nf">withUnretained</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
                    <span class="o">.</span><span class="nf">debug</span><span class="p">(</span><span class="s">"deleteActionObservalble"</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">vc</span><span class="p">,</span> <span class="n">uuid</span> <span class="k">in</span>
                        <span class="k">let</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span>
                        <span class="k">let</span> <span class="nv">filteredTodos</span> <span class="o">=</span> <span class="n">currentTodos</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="n">uuid</span> <span class="p">}</span>
                        <span class="k">return</span> <span class="n">filteredTodos</span>
                    <span class="p">}</span>
                    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="p">)</span>
                    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">disposeBag</span><span class="p">)</span>

                   
                
                <span class="c1">// MARK: - 셀의 토글 클릭시 액션을 여기서 처리</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">isDoneChange</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">id</span><span class="p">,</span> <span class="n">updatedIsDone</span> <span class="k">in</span>
                    <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
                    <span class="k">var</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span>
                    <span class="c1">// 일치하는것 찾기</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nv">foundTodoIndex</span> <span class="o">=</span> <span class="n">currentTodos</span><span class="o">.</span><span class="nf">firstIndex</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="p">})</span> <span class="p">{</span>
                        <span class="n">currentTodos</span><span class="p">[</span><span class="n">foundTodoIndex</span><span class="p">]</span><span class="o">.</span><span class="n">isDone</span> <span class="o">=</span> <span class="n">updatedIsDone</span>
                    <span class="p">}</span>
                    <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">currentTodos</span><span class="p">)</span>
                <span class="p">}</span>
                
                <span class="k">return</span> <span class="n">cell</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
        
        
        <span class="c1">// MARK: - 3초뒤 갱신</span>
        <span class="cm">/*
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            self.rxTodosRelay.accept(RxTodo.getDumies(count: 3))
        }
         */</span>
        
        <span class="c1">// MARK: - Rx스러운 3초뒤 갱신</span>
        <span class="cm">/*
        Observable.just(())
            .delay(.seconds(3), scheduler: MainScheduler.instance) // Observable&lt;Void&gt;
            .map { RxTodo.getDumies(count: 5) }                    // Observable&lt;[RxTodo]&gt;
            .bind(onNext: self.rxTodosRelay.accept(_:))            // 같은 자료형이면 클로저가 들어갈 수 있다
            .disposed(by: disposeBag)
        */</span>
        
        <span class="c1">// MARK: - 버튼 연결</span>
        <span class="n">addButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span>
            <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
                <span class="k">var</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span> <span class="c1">// .value 하면 마지막에 보낸 데이터 할 수 있음</span>
                <span class="n">currentTodos</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="kt">RxTodo</span><span class="p">(),</span> <span class="nv">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>       <span class="c1">// 첫번째 열에 넣겠다</span>
                <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">currentTodos</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeUI</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">myTableView</span><span class="p">]</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="n">view</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
        
        <span class="c1">// 네비게이션 버튼</span>
        <span class="n">navigationItem</span><span class="o">.</span><span class="n">rightBarButtonItems</span> <span class="o">=</span> <span class="p">[</span><span class="n">addButton</span><span class="p">]</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">constraints</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">NSLayoutConstraint</span><span class="o">.</span><span class="nf">activate</span><span class="p">([</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">safeAreaLayoutGuide</span><span class="o">.</span><span class="n">topAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">trailingAnchor</span><span class="p">),</span>
            <span class="n">myTableView</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">view</span><span class="o">.</span><span class="n">bottomAnchor</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="성능-이슈-해결법">성능 이슈 해결법</h1>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 커스텀 셀</span>
<span class="k">override</span> <span class="kd">func</span> <span class="nf">prepareForReuse</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">prepareForReuse</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"prepareForReuse() - cellData.id: </span><span class="se">\(</span><span class="n">cellData</span><span class="p">?</span><span class="o">.</span><span class="n">id</span> <span class="p">??</span> <span class="kt">UUID</span><span class="p">()</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">self</span><span class="o">.</span><span class="n">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span> <span class="c1">// MARK: - 이전 구독을 끊어주는 작업을 통해 성능 개선</span>
<span class="p">}</span>

<span class="c1">// ViewController</span>
<span class="c1">// MARK: - 개선방식(bind대신 map도 가능)</span>
<span class="n">cell</span><span class="o">.</span><span class="n">deleteActionObservalble</span>
    <span class="o">.</span><span class="nf">withUnretained</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">debug</span><span class="p">(</span><span class="s">"deleteActionObservalble 디버그"</span><span class="p">)</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">vc</span><span class="p">,</span> <span class="n">uuid</span> <span class="k">in</span>
        <span class="k">let</span> <span class="nv">currentTodos</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="o">.</span><span class="n">value</span>
        <span class="k">let</span> <span class="nv">filteredTodos</span> <span class="o">=</span> <span class="n">currentTodos</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="n">uuid</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">filteredTodos</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">rxTodosRelay</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">cell</span><span class="o">.</span><span class="n">disposeBag</span><span class="p">)</span> <span class="c1">// self.disposeBag -&gt; ell.disposeBag</span>
</code></pre></div></div>

<hr />
<p>테이블뷰/컬렉션뷰는 셀을 재사용한다.<br />
따라서 셀이 재사용될 때 기존 구독은 끊어줘야 한다.<br />
그렇지 않으면 같은 셀 인스턴스에 구독이 계속 쌓여서 메모리 증가와 이벤트 중복이 발생한다.<br />
해결법: prepareForReuse()에서 disposeBag = DisposeBag()으로 초기화하고, VC에서는 반드시 cell.disposeBag에 구독을 넣는다.</p>

<p>UITableViewCell은 재사용되므로, 셀이 다시 쓰일 때 이전 구독이 남아있으면 이벤트가 중복으로 전달되고 메모리도 증가한다. 이를 방지하기 위해 prepareForReuse()에서 disposeBag을 새로 생성하여 구독을 초기화하고, ViewController에서는 cell.disposeBag에 바인딩한다.</p>]]></content><author><name>Dong Hyeon</name></author><category term="ReactiveX" /><category term="RxDataSource" /><summary type="html"><![CDATA[기존 코드 개선 override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) makeUI() constraints() // MARK: - 버튼 연결 // isDoneSwitch.addTarget(self, action: #selector(handleIsDone), for: .valueChanged) // deleteButton.addTarget(self, action: #selector(handleDeleteButton), for: .touchUpInside) } // MARK: - Rx로 버튼 연결 func setRx() { // MARK: - 초기 이벤트를 버리고 이후부터 모두 전달받겠다 /* isDoneSwitch.rx.isOn .skip(1) // 처음 방출값 무시(초기값 세팅 이벤트 무시) .debug("isDoneSwitch 디버그") .bind(onNext: { [weak self] isOn in guard let self = self, let id = self.cellData?.id else { return } self.isDoneChange?(id, isOn) }) .disposed(by: disposeBag) */ // MARK: - 스위치가 valueChanged이벤트를 낼 때만 트리거 하겠다 &amp; 해당시점은 isOn 값을 가져오겠다 isDoneSwitch.rx.controlEvent(.valueChanged) .withLatestFrom(isDoneSwitch.rx.isOn) // 토글 후 최신값 가져오기 .bind(onNext: { [weak self] isOn in guard let self = self, let id = self.cellData?.id else { return } self.isDoneChange?(id, isOn) }) .disposed(by: disposeBag) deleteButton.rx.tap .debug("deleteButton 디버그") .bind(onNext: { [weak self] _ in guard let self = self, let id = self.cellData?.id else { return } self.deleteAction?(id) }) .disposed(by: disposeBag) } 기존 커스텀 셀의 버튼 연결 방식은 addTarget인데 Rx스럽게 하기 위해 주석처리 및 setRx()함수를 만들었다. setRx()은 configure 함수에서 호출하도록 하였다. 지금은 이벤트 처리 자체를 클로저로 주고 있는데 이렇게 말고 deleteButton.rx.tap 자체를 외부에서 넘겨줄 수 있다. deleteActionObservable을 만들어서 외부에서 주입하도록 해보자. RxTodoCell 수정 var deleteActionObservalble: Observable&lt;UUID&gt; = Observable.empty() // MARK: - Rx로 버튼 연결 func setRx() { // MARK: - 초기 이벤트를 버리고 이후부터 모두 전달받겠다 /* isDoneSwitch.rx.isOn .skip(1) // 처음 방출값 무시(초기값 세팅 이벤트 무시) .debug("isDoneSwitch 디버그") .bind(onNext: { [weak self] isOn in guard let self = self, let id = self.cellData?.id else { return } self.isDoneChange?(id, isOn) }) .disposed(by: disposeBag) */ // MARK: - 스위치가 valueChanged이벤트를 낼 때만 트리거 하겠다 &amp; 해당시점은 isOn 값을 가져오겠다 isDoneSwitch.rx.controlEvent(.valueChanged) .withLatestFrom(isDoneSwitch.rx.isOn) // 토글 후 최신값 가져오기 .bind(onNext: { [weak self] isOn in guard let self = self, let id = self.cellData?.id else { return } self.isDoneChange?(id, isOn) }) .disposed(by: disposeBag) // MARK: - 기존 방식 /* deleteButton.rx.tap .debug("deleteButton 디버그") .bind(onNext: { [weak self] _ in guard let self = self, let id = self.cellData?.id else { return } self.deleteAction?(id) }) .disposed(by: disposeBag) */ // MARK: - 개선된 방식(클로저를 전달안하고싶고 옵저버블로 하고싶다면) deleteActionObservalble = deleteButton.rx.tap .debug("deleteButton 디버그") .compactMap({ [weak self] _ in self?.cellData?.id }) } deleteActionObservalble을 선언해주고 기존 방식을 주석처리하고 deleteActionObservalble을 연결해주었다. 나머지는 viewController에서 진행하면 된다. // ✅ 2. (더 유연하지만 수동 캐스팅 필요 – RxCocoa) rxTodosRelay .bind(to: myTableView.rx.items) { (tableView, row, element) in guard let cell = tableView.dequeueReusableCell(withIdentifier: RxTodoCell.reuseIdentifier) as? RxTodoCell else { return UITableViewCell()} cell.configure(with: element) // MARK: - 셀의 delete버튼 선택되었을 때 액션을 여기서 처리 // cell.deleteAction = { id in // let currentTodos = self.rxTodosRelay.value // let filteredTodos = currentTodos.filter { $0.id != id } // self.rxTodosRelay.accept(filteredTodos) // } // MARK: - 개선방식(bind대신 map도 가능) cell.deleteActionObservalble .withUnretained(self) .debug("deleteActionObservalble") .map { vc, uuid in let currentTodos = self.rxTodosRelay.value let filteredTodos = currentTodos.filter { $0.id != uuid } return filteredTodos } .bind(to: self.rxTodosRelay) .disposed(by: self.disposeBag) // MARK: - 셀의 토글 클릭시 액션을 여기서 처리 cell.isDoneChange = { [weak self] id, updatedIsDone in guard let self = self else { return } var currentTodos = self.rxTodosRelay.value // 일치하는것 찾기 if let foundTodoIndex = currentTodos.firstIndex(where: { $0.id == id }) { currentTodos[foundTodoIndex].isDone = updatedIsDone } self.rxTodosRelay.accept(currentTodos) } return cell } .disposed(by: disposeBag) 기존 deleteAction을 주석처리후 deleteActionObservalble을 연결해준다 이때 bind대신 map으로 해주어도 된다. 전체 코드 // Cell import UIKit import RxSwift import RxCocoa final class RxTodoCell: UITableViewCell { var cellData: RxTodo? = nil // MARK: - Rx var disposeBag = DisposeBag() var isDoneChange: ((_ id: UUID, _ newValue: Bool) -&gt; Void)? = nil var deleteAction: ((_ id: UUID) -&gt; Void)? = nil var deleteActionObservalble: Observable&lt;UUID&gt; = Observable.empty() private let titleLabel: UILabel = { let label = UILabel() label.text = "제목" label.numberOfLines = 1 label.font = UIFont.systemFont(ofSize: 14, weight: .bold) return label }() private let idLabel: UILabel = { let label = UILabel() label.text = "아이디" label.numberOfLines = 0 label.font = UIFont.systemFont(ofSize: 12, weight: .regular) return label }() private lazy var isDoneSwitch: UISwitch = { let sw = UISwitch() return sw }() private lazy var deleteButton: UIButton = { let btn = UIButton(type: .system) btn.setTitle("Delete", for: .normal) btn.widthAnchor.constraint(equalToConstant: 50).isActive = true return btn }() private lazy var vStack: UIStackView = { let stack = UIStackView(arrangedSubviews: [titleLabel, idLabel]) stack.axis = .vertical stack.spacing = 8 return stack }() private lazy var hStack: UIStackView = { let stack = UIStackView(arrangedSubviews: [vStack, isDoneSwitch, deleteButton]) stack.axis = .horizontal stack.alignment = .center stack.spacing = 20 return stack }() override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) makeUI() constraints() // MARK: - 버튼 연결 // isDoneSwitch.addTarget(self, action: #selector(handleIsDone), for: .valueChanged) // deleteButton.addTarget(self, action: #selector(handleDeleteButton), for: .touchUpInside) } // MARK: - Rx로 버튼 연결 func setRx() { // MARK: - 초기 이벤트를 버리고 이후부터 모두 전달받겠다 /* isDoneSwitch.rx.isOn .skip(1) // 처음 방출값 무시(초기값 세팅 이벤트 무시) .debug("isDoneSwitch 디버그") .bind(onNext: { [weak self] isOn in guard let self = self, let id = self.cellData?.id else { return } self.isDoneChange?(id, isOn) }) .disposed(by: disposeBag) */ // MARK: - 스위치가 valueChanged이벤트를 낼 때만 트리거 하겠다 &amp; 해당시점은 isOn 값을 가져오겠다 isDoneSwitch.rx.controlEvent(.valueChanged) .withLatestFrom(isDoneSwitch.rx.isOn) // 토글 후 최신값 가져오기 .bind(onNext: { [weak self] isOn in guard let self = self, let id = self.cellData?.id else { return } self.isDoneChange?(id, isOn) }) .disposed(by: disposeBag) // MARK: - 기존 방식 /* deleteButton.rx.tap .debug("deleteButton 디버그") .bind(onNext: { [weak self] _ in guard let self = self, let id = self.cellData?.id else { return } self.deleteAction?(id) }) .disposed(by: disposeBag) */ // MARK: - 개선된 방식(클로저를 전달안하고싶고 옵저버블로 하고싶다면) deleteActionObservalble = deleteButton.rx.tap .debug("deleteButton 디버그") .compactMap({ [weak self] _ in self?.cellData?.id }) } required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") } private func makeUI() { [hStack].forEach { contentView.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } } private func constraints() { NSLayoutConstraint.activate([ hStack.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 10), hStack.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20), hStack.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20), hStack.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -10), ]) } override func prepareForReuse() { super.prepareForReuse() print(#fileID, #function, #line, "prepareForReuse() - cellData.id: \(cellData?.id ?? UUID())") self.disposeBag = DisposeBag() // MARK: - 이전 구독을 끊어주는 작업 } } extension RxTodoCell { func configure(with todo: RxTodo) { self.cellData = todo titleLabel.text = todo.title let idString = String(todo.id.uuidString.prefix(10)) idLabel.text = "ID: \(idString)" isDoneSwitch.isOn = todo.isDone setRx() } // MARK: - 디버깅용 func configure(title: String, id: Int) { titleLabel.text = title idLabel.text = "ID: \(id)" isDoneSwitch.isOn = false } } extension RxTodoCell { @objc func handleIsDone(_ sender: UISwitch) { print(#fileID, #function, #line, "- id: \(cellData?.id.uuidString ?? "") sender: \(sender.isOn)") guard let id = self.cellData?.id else { return } isDoneChange?(id, sender.isOn) } @objc func handleDeleteButton(_ sender: UIButton) { guard let id = self.cellData?.id else { return } deleteAction?(id) } } #if DEBUG import SwiftUI // TodoCell 미리보기 struct RxTodoCell_Preview: PreviewProvider { static var previews: some View { let cell = RxTodoCell() cell.configure(title: "할 일 예제", id: 42) return cell.contentView .getPreview() .previewLayout(.fixed(width: 350, height: 100)) .background(Color.white) } } #endif // ViewController import UIKit import RxSwift import RxCocoa import RxRelay final class RxTodoViewController4: UIViewController { // MARK: - 구독에 대한 찌꺼기 처리 var disposeBag = DisposeBag() // MARK: - Relay는 Subject계열인데 끊어지지 않는다(.value로 접근시 마지막 데이터 확인가능 = stateful) var rxTodosRelay: BehaviorRelay&lt;[RxTodo]&gt; = BehaviorRelay(value: RxTodo.getDumies()) // MARK: - UI private lazy var addButton = UIBarButtonItem(title: "추가", style: .plain, target: nil, action: nil) private lazy var myTableView: UITableView = { let tv = UITableView() return tv }() override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white makeUI() constraints() // MARK: - 코드기반 사용한다면 myTableView.register(RxTodoCell.self, forCellReuseIdentifier: "RxTodoCell") // ✅ 2. (더 유연하지만 수동 캐스팅 필요 – RxCocoa) rxTodosRelay .bind(to: myTableView.rx.items) { (tableView, row, element) in guard let cell = tableView.dequeueReusableCell(withIdentifier: RxTodoCell.reuseIdentifier) as? RxTodoCell else { return UITableViewCell()} cell.configure(with: element) // MARK: - 셀의 delete버튼 선택되었을 때 액션을 여기서 처리 // cell.deleteAction = { id in // let currentTodos = self.rxTodosRelay.value // let filteredTodos = currentTodos.filter { $0.id != id } // self.rxTodosRelay.accept(filteredTodos) // } // MARK: - 개선방식(bind대신 map도 가능) cell.deleteActionObservalble .withUnretained(self) .debug("deleteActionObservalble") .map { vc, uuid in let currentTodos = self.rxTodosRelay.value let filteredTodos = currentTodos.filter { $0.id != uuid } return filteredTodos } .bind(to: self.rxTodosRelay) .disposed(by: self.disposeBag) // MARK: - 셀의 토글 클릭시 액션을 여기서 처리 cell.isDoneChange = { [weak self] id, updatedIsDone in guard let self = self else { return } var currentTodos = self.rxTodosRelay.value // 일치하는것 찾기 if let foundTodoIndex = currentTodos.firstIndex(where: { $0.id == id }) { currentTodos[foundTodoIndex].isDone = updatedIsDone } self.rxTodosRelay.accept(currentTodos) } return cell } .disposed(by: disposeBag) // MARK: - 3초뒤 갱신 /* DispatchQueue.main.asyncAfter(deadline: .now() + 3) { self.rxTodosRelay.accept(RxTodo.getDumies(count: 3)) } */ // MARK: - Rx스러운 3초뒤 갱신 /* Observable.just(()) .delay(.seconds(3), scheduler: MainScheduler.instance) // Observable&lt;Void&gt; .map { RxTodo.getDumies(count: 5) } // Observable&lt;[RxTodo]&gt; .bind(onNext: self.rxTodosRelay.accept(_:)) // 같은 자료형이면 클로저가 들어갈 수 있다 .disposed(by: disposeBag) */ // MARK: - 버튼 연결 addButton.rx.tap .bind(onNext: { [weak self] _ in guard let self = self else { return } var currentTodos = self.rxTodosRelay.value // .value 하면 마지막에 보낸 데이터 할 수 있음 currentTodos.insert(RxTodo(), at: 0) // 첫번째 열에 넣겠다 self.rxTodosRelay.accept(currentTodos) }) .disposed(by: disposeBag) } private func makeUI() { [myTableView].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } // 네비게이션 버튼 navigationItem.rightBarButtonItems = [addButton] } private func constraints() { NSLayoutConstraint.activate([ myTableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor), myTableView.leadingAnchor.constraint(equalTo: view.leadingAnchor), myTableView.trailingAnchor.constraint(equalTo: view.trailingAnchor), myTableView.bottomAnchor.constraint(equalTo: view.bottomAnchor) ]) } } 성능 이슈 해결법 // 커스텀 셀 override func prepareForReuse() { super.prepareForReuse() print(#fileID, #function, #line, "prepareForReuse() - cellData.id: \(cellData?.id ?? UUID())") self.disposeBag = DisposeBag() // MARK: - 이전 구독을 끊어주는 작업을 통해 성능 개선 } // ViewController // MARK: - 개선방식(bind대신 map도 가능) cell.deleteActionObservalble .withUnretained(self) .debug("deleteActionObservalble 디버그") .map { vc, uuid in let currentTodos = self.rxTodosRelay.value let filteredTodos = currentTodos.filter { $0.id != uuid } return filteredTodos } .bind(to: self.rxTodosRelay) .disposed(by: cell.disposeBag) // self.disposeBag -&gt; ell.disposeBag 테이블뷰/컬렉션뷰는 셀을 재사용한다. 따라서 셀이 재사용될 때 기존 구독은 끊어줘야 한다. 그렇지 않으면 같은 셀 인스턴스에 구독이 계속 쌓여서 메모리 증가와 이벤트 중복이 발생한다. 해결법: prepareForReuse()에서 disposeBag = DisposeBag()으로 초기화하고, VC에서는 반드시 cell.disposeBag에 구독을 넣는다. UITableViewCell은 재사용되므로, 셀이 다시 쓰일 때 이전 구독이 남아있으면 이벤트가 중복으로 전달되고 메모리도 증가한다. 이를 방지하기 위해 prepareForReuse()에서 disposeBag을 새로 생성하여 구독을 초기화하고, ViewController에서는 cell.disposeBag에 바인딩한다.]]></summary></entry><entry><title type="html">[CustomView] 3. 컨테이너뷰 &amp;amp; 코드로 만들어보기</title><link href="http://localhost:4000/CustomView-customView3/" rel="alternate" type="text/html" title="[CustomView] 3. 컨테이너뷰 &amp;amp; 코드로 만들어보기" /><published>2025-09-11T00:00:00+00:00</published><updated>2025-09-11T00:00:00+00:00</updated><id>http://localhost:4000/%5BCustomView%5D-customView3</id><content type="html" xml:base="http://localhost:4000/CustomView-customView3/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<h1 id="containerview">ContainerView</h1>
<p>컨테이너뷰는 뷰컨트롤러를 화면에 넣은 것이다.  <br />
이번에는 코드기반으로 구현을 해보자.<br />
<a href="https://developer.apple.com/documentation/uikit/creating-a-custom-container-view-controller">공식문서</a><br />
<br /><br /><br /><br /></p>

<h1 id="코드로-구현하기">코드로 구현하기</h1>
<p><img src="/assets/img/2025-09-11-CustomView%5D-customView3/image-20250911144836289.png" alt="이미지" width="60%" /> <br />
이전 포스팅에서 사용한 스토리보드에 추가적으로 민트색 UIView를 추가하였다.    <br />
민트색을 지정하고, 상단 회색 UIView로 드래그하여 leading, trailing, height,vertical spacing을 설정하였다.</p>

<pre><code class="language-sswift">import UIKit

final class CodeParentViewController: UIViewController {
    
    @IBOutlet weak var mintChildContainerView: UIView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .white
        print(#fileID, #function, #line, "- ")
        configureChildContaianerView()
    }
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
   
    }
    
    private func configureChildContaianerView() {
        let storyboard = UIStoryboard(name: "CodeContainer", bundle: .main)
        
        // MARK: - ChildVC라는 이름을 가진 녀석의 타입이 ChildVC라면 가져와러
        if let childVC = storyboard.instantiateViewController(identifier: "CodeChildViewController")
            as? CodeChildViewController {
            
            // MARK: - 이벤트 추가 가능(스토리보드 방식과 동일)
            childVC.placeHolder = "테스트"
            childVC.titleText = "코드로 만들었습니다."
            childVC.onBtnAClicked = {
                print(#fileID, #function, #line, "- 버튼 A 클릭")
            }
            
            childVC.onBtnBClicked = { input in
                print(#fileID, #function, #line, "- 버튼 B 클릭: \(input)")
            }
            childVC.onUserInputChanged = { input in
                print(#fileID, #function, #line, "- 입력됨: \(input)")
            }
            
            addChild(childVC)             // 뷰컨 자식으로 넣기
            view.addSubview(childVC.view) // 내가 가진 뷰에 뷰를 추가(뷰끼리 넣어주기)
            
            // MARK: - AutoLayout
            childVC.view.translatesAutoresizingMaskIntoConstraints = false
            let childVCConstraints = [
                childVC.view.topAnchor.constraint(equalTo: self.mintChildContainerView.topAnchor),
                childVC.view.bottomAnchor.constraint(equalTo: self.mintChildContainerView.bottomAnchor),
                childVC.view.leadingAnchor.constraint(equalTo: self.mintChildContainerView.leadingAnchor),
                childVC.view.trailingAnchor.constraint(equalTo: self.mintChildContainerView.trailingAnchor),
            ]
            
                                                                   
            NSLayoutConstraint.activate(childVCConstraints )
            
            // 자식뷰가 들어왔다고 알려주기
            childVC.didMove(toParent: self)
        }
    }
    
    /*
    private func configureChildContaianerViewWidhCreatorBlock() {
        let storyboard = UIStoryboard(name: "CodeContainer", bundle: .main)
        
        // MARK: - ChildVC라는 이름을 가진 녀석의 타입이 ChildVC라면 가져와러
        if let childVC = storyboard.instantiateViewController(identifier: "CodeChildViewController", creator: { coder in
            return CodeChildViewController(coder: coder,
                                           titleText: "테스트",
                                           placeholder: "테스트2",
                                           onBtnAClicked: self.handleAtnAClicked,
                                           onBtnBClicked: self.handleBtnAClicked,
                                           onUserInputChanged: self.handleInputFromChildVC
            )
        }) as? CodeChildViewController {
            
            // MARK: - 이벤트 추가 가능(스토리보드 방식과 동일)
            childVC.placeHolder = "테스트"
            childVC.titleText = "코드로 만들었습니다."
            childVC.onBtnAClicked = {
                print(#fileID, #function, #line, "- 버튼 A 클릭")
            }
            
            childVC.onBtnBClicked = { input in
                print(#fileID, #function, #line, "- 버튼 B 클릭: \(input)")
            }
            childVC.onUserInputChanged = { input in
                print(#fileID, #function, #line, "- 입력됨: \(input)")
            }
            
            addChild(childVC)             // 뷰컨 자식으로 넣기
            view.addSubview(childVC.view) // 내가 가진 뷰에 뷰를 추가(뷰끼리 넣어주기)
            
            // MARK: - AutoLayout
            childVC.view.translatesAutoresizingMaskIntoConstraints = false
            let childVCConstraints = [
                childVC.view.topAnchor.constraint(equalTo: self.mintChildContainerView.topAnchor),
                childVC.view.bottomAnchor.constraint(equalTo: self.mintChildContainerView.bottomAnchor),
                childVC.view.leadingAnchor.constraint(equalTo: self.mintChildContainerView.leadingAnchor),
                childVC.view.trailingAnchor.constraint(equalTo: self.mintChildContainerView.trailingAnchor),
            ]
            
                                                                   
            NSLayoutConstraint.activate(childVCConstraints )
            
            // 자식뷰가 들어왔다고 알려주기
            childVC.didMove(toParent: self)
        }
    }
     */
    
    
    private func handleAtnAClicked() {
        
    }
    
    private func handleBtnAClicked(_ input: String) {
        
    }
    
    private func handleInputFromChildVC(_ input: String) {
        
    }
}
</code></pre>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">CodeChildViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">titleLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">inputTextField</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    
    <span class="k">var</span> <span class="nv">onBtnAClicked</span><span class="p">:</span> <span class="p">(()</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span>            <span class="c1">// A버튼 클릭 이벤트</span>
    <span class="k">var</span> <span class="nv">onBtnBClicked</span><span class="p">:</span> <span class="p">((</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span>      <span class="c1">// B버튼 클릭 이벤트</span>
    <span class="k">var</span> <span class="nv">onUserInputChanged</span><span class="p">:</span> <span class="p">((</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// 글자 입력시 이벤트</span>
    
    <span class="c1">// @IBInspectable: Interface Builder에서 속성을 넣어주는 역할</span>
    <span class="c1">// 프로퍼티 옵저버</span>
    <span class="kd">@IBInspectable</span>
    <span class="k">var</span> <span class="nv">titleText</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">titleText</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">@IBInspectable</span>
    <span class="k">var</span> <span class="nv">placeHolder</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">inputTextField</span><span class="o">.</span><span class="n">placeholder</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">placeHolder</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">?</span> <span class="s">"글자를 입력해주세요"</span> <span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">placeHolder</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">bgColor</span><span class="p">:</span> <span class="kt">UIColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">systemYellow</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">bgColor</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - creator를 이용한 생성자 주입방식</span>
<span class="c1">//    init?(coder: NSCoder,</span>
<span class="c1">//          titleText: String,</span>
<span class="c1">//          placeholder: String,</span>
<span class="c1">//          onBtnAClicked: (() -&gt; Void)? = nil,</span>
<span class="c1">//          onBtnBClicked: ((String) -&gt; Void)? = nil,</span>
<span class="c1">//          onUserInputChanged: ((String) -&gt; Void)? = nil</span>
<span class="c1">//    ) {</span>
<span class="c1">//        self.titleText = titleText</span>
<span class="c1">//        self.placeHolder = placeholder</span>
<span class="c1">//        self.onBtnAClicked = onBtnAClicked</span>
<span class="c1">//        self.onBtnBClicked = onBtnBClicked</span>
<span class="c1">//        self.onUserInputChanged = onUserInputChanged</span>
<span class="c1">//        super.init(coder: coder)</span>
<span class="c1">//    }</span>
<span class="c1">//    </span>
<span class="c1">//    required init?(coder: NSCoder) {</span>
<span class="c1">//        fatalError("init(coder:) has not been implemented")</span>
<span class="c1">//    }</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">white</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- "</span><span class="p">)</span>
        
        <span class="n">inputTextField</span><span class="o">.</span><span class="nf">addTarget</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="nf">onUserInputChanged</span><span class="p">(</span><span class="nv">_</span><span class="p">:)),</span> <span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">editingChanged</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - 버튼 이벤트</span>
    <span class="c1">/// 스토리보드에서 태그 설정해두면 이 메서드 하나로 여러 버튼 연결해서 분기 가능</span>
    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">onBtcClicked</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">sender</span><span class="o">.</span><span class="n">tag</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"버튼 A 클릭"</span><span class="p">)</span>
            <span class="nf">onBtnAClicked</span><span class="p">?()</span>
        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"버튼 B 클릭"</span><span class="p">)</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">input</span> <span class="o">=</span> <span class="n">inputTextField</span><span class="o">.</span><span class="n">text</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="nf">onBtnBClicked</span><span class="p">?(</span><span class="n">input</span><span class="p">)</span>
        <span class="k">default</span><span class="p">:</span> <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - 텍스트필드 입력시 이벤트</span>
    <span class="kd">@objc</span> <span class="kd">private</span> <span class="kd">func</span> <span class="nf">onUserInputChanged</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UITextField</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="k">#fileID</span><span class="p">,</span> <span class="k">#function</span><span class="p">,</span> <span class="k">#line</span><span class="p">,</span> <span class="s">"- sender.text: </span><span class="se">\(</span><span class="n">sender</span><span class="o">.</span><span class="n">text</span><span class="o">!</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">onUserInputChanged</span><span class="p">?(</span><span class="n">sender</span><span class="o">.</span><span class="n">text</span> <span class="p">??</span> <span class="s">""</span><span class="p">)</span>
    <span class="p">}</span>
    
<span class="p">}</span>
</code></pre></div></div>

<h1 id="reference">Reference</h1>
<ul>
  <li><a href="https://developer.apple.com/documentation/uikit/creating-a-custom-container-view-controller">공식문서</a></li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="CustomView" /><summary type="html"><![CDATA[ContainerView 컨테이너뷰는 뷰컨트롤러를 화면에 넣은 것이다. 이번에는 코드기반으로 구현을 해보자. 공식문서 코드로 구현하기 이전 포스팅에서 사용한 스토리보드에 추가적으로 민트색 UIView를 추가하였다. 민트색을 지정하고, 상단 회색 UIView로 드래그하여 leading, trailing, height,vertical spacing을 설정하였다. import UIKit final class CodeParentViewController: UIViewController { @IBOutlet weak var mintChildContainerView: UIView! override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white print(#fileID, #function, #line, "- ") configureChildContaianerView() } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { } private func configureChildContaianerView() { let storyboard = UIStoryboard(name: "CodeContainer", bundle: .main) // MARK: - ChildVC라는 이름을 가진 녀석의 타입이 ChildVC라면 가져와러 if let childVC = storyboard.instantiateViewController(identifier: "CodeChildViewController") as? CodeChildViewController { // MARK: - 이벤트 추가 가능(스토리보드 방식과 동일) childVC.placeHolder = "테스트" childVC.titleText = "코드로 만들었습니다." childVC.onBtnAClicked = { print(#fileID, #function, #line, "- 버튼 A 클릭") } childVC.onBtnBClicked = { input in print(#fileID, #function, #line, "- 버튼 B 클릭: \(input)") } childVC.onUserInputChanged = { input in print(#fileID, #function, #line, "- 입력됨: \(input)") } addChild(childVC) // 뷰컨 자식으로 넣기 view.addSubview(childVC.view) // 내가 가진 뷰에 뷰를 추가(뷰끼리 넣어주기) // MARK: - AutoLayout childVC.view.translatesAutoresizingMaskIntoConstraints = false let childVCConstraints = [ childVC.view.topAnchor.constraint(equalTo: self.mintChildContainerView.topAnchor), childVC.view.bottomAnchor.constraint(equalTo: self.mintChildContainerView.bottomAnchor), childVC.view.leadingAnchor.constraint(equalTo: self.mintChildContainerView.leadingAnchor), childVC.view.trailingAnchor.constraint(equalTo: self.mintChildContainerView.trailingAnchor), ] NSLayoutConstraint.activate(childVCConstraints ) // 자식뷰가 들어왔다고 알려주기 childVC.didMove(toParent: self) } } /* private func configureChildContaianerViewWidhCreatorBlock() { let storyboard = UIStoryboard(name: "CodeContainer", bundle: .main) // MARK: - ChildVC라는 이름을 가진 녀석의 타입이 ChildVC라면 가져와러 if let childVC = storyboard.instantiateViewController(identifier: "CodeChildViewController", creator: { coder in return CodeChildViewController(coder: coder, titleText: "테스트", placeholder: "테스트2", onBtnAClicked: self.handleAtnAClicked, onBtnBClicked: self.handleBtnAClicked, onUserInputChanged: self.handleInputFromChildVC ) }) as? CodeChildViewController { // MARK: - 이벤트 추가 가능(스토리보드 방식과 동일) childVC.placeHolder = "테스트" childVC.titleText = "코드로 만들었습니다." childVC.onBtnAClicked = { print(#fileID, #function, #line, "- 버튼 A 클릭") } childVC.onBtnBClicked = { input in print(#fileID, #function, #line, "- 버튼 B 클릭: \(input)") } childVC.onUserInputChanged = { input in print(#fileID, #function, #line, "- 입력됨: \(input)") } addChild(childVC) // 뷰컨 자식으로 넣기 view.addSubview(childVC.view) // 내가 가진 뷰에 뷰를 추가(뷰끼리 넣어주기) // MARK: - AutoLayout childVC.view.translatesAutoresizingMaskIntoConstraints = false let childVCConstraints = [ childVC.view.topAnchor.constraint(equalTo: self.mintChildContainerView.topAnchor), childVC.view.bottomAnchor.constraint(equalTo: self.mintChildContainerView.bottomAnchor), childVC.view.leadingAnchor.constraint(equalTo: self.mintChildContainerView.leadingAnchor), childVC.view.trailingAnchor.constraint(equalTo: self.mintChildContainerView.trailingAnchor), ] NSLayoutConstraint.activate(childVCConstraints ) // 자식뷰가 들어왔다고 알려주기 childVC.didMove(toParent: self) } } */ private func handleAtnAClicked() { } private func handleBtnAClicked(_ input: String) { } private func handleInputFromChildVC(_ input: String) { } } import UIKit final class CodeChildViewController: UIViewController { @IBOutlet weak var titleLabel: UILabel! @IBOutlet weak var inputTextField: UITextField! var onBtnAClicked: (() -&gt; Void)? = nil // A버튼 클릭 이벤트 var onBtnBClicked: ((String) -&gt; Void)? = nil // B버튼 클릭 이벤트 var onUserInputChanged: ((String) -&gt; Void)? = nil // 글자 입력시 이벤트 // @IBInspectable: Interface Builder에서 속성을 넣어주는 역할 // 프로퍼티 옵저버 @IBInspectable var titleText: String = "" { didSet { DispatchQueue.main.async { self.titleLabel.text = self.titleText } } } @IBInspectable var placeHolder: String = "" { didSet { DispatchQueue.main.async { self.inputTextField.placeholder = self.placeHolder.isEmpty ? "글자를 입력해주세요" : self.placeHolder } } } var bgColor: UIColor = .systemYellow { didSet { DispatchQueue.main.async { self.view.backgroundColor = self.bgColor } } } // MARK: - creator를 이용한 생성자 주입방식 // init?(coder: NSCoder, // titleText: String, // placeholder: String, // onBtnAClicked: (() -&gt; Void)? = nil, // onBtnBClicked: ((String) -&gt; Void)? = nil, // onUserInputChanged: ((String) -&gt; Void)? = nil // ) { // self.titleText = titleText // self.placeHolder = placeholder // self.onBtnAClicked = onBtnAClicked // self.onBtnBClicked = onBtnBClicked // self.onUserInputChanged = onUserInputChanged // super.init(coder: coder) // } // // required init?(coder: NSCoder) { // fatalError("init(coder:) has not been implemented") // } override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white print(#fileID, #function, #line, "- ") inputTextField.addTarget(self, action: #selector(onUserInputChanged(_:)), for: .editingChanged) } // MARK: - 버튼 이벤트 /// 스토리보드에서 태그 설정해두면 이 메서드 하나로 여러 버튼 연결해서 분기 가능 @IBAction func onBtcClicked(_ sender: UIButton) { switch sender.tag { case 1: print("버튼 A 클릭") onBtnAClicked?() case 2: print("버튼 B 클릭") guard let input = inputTextField.text else { return } onBtnBClicked?(input) default: break } } // MARK: - 텍스트필드 입력시 이벤트 @objc private func onUserInputChanged(_ sender: UITextField) { print(#fileID, #function, #line, "- sender.text: \(sender.text!)") self.onUserInputChanged?(sender.text ?? "") } } Reference 공식문서]]></summary></entry><entry><title type="html">[CustomView] 4. UIKit에서 SwiftUI뷰 불러오기</title><link href="http://localhost:4000/CustomView-customView4/" rel="alternate" type="text/html" title="[CustomView] 4. UIKit에서 SwiftUI뷰 불러오기" /><published>2025-09-11T00:00:00+00:00</published><updated>2025-09-11T00:00:00+00:00</updated><id>http://localhost:4000/%5BCustomView%5D-customView4</id><content type="html" xml:base="http://localhost:4000/CustomView-customView4/"><![CDATA[<!-- <img src="/%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B2%BD%EB%A1%9C" alt="이미지" width="30%"> -->

<h1 id="uihostingcontroller">UIHostingController</h1>

<blockquote>
  <p>A UIKit view controller that manages a SwiftUI view hierarchy. <br />
SwiftUI 뷰 계층구조를 관리하는 뷰컨트롤러이다.     <br />
<a href="https://developer.apple.com/documentation/swiftui/uihostingcontroller">공식문서</a></p>
</blockquote>]]></content><author><name>Dong Hyeon</name></author><category term="CustomView" /><summary type="html"><![CDATA[UIHostingController A UIKit view controller that manages a SwiftUI view hierarchy. SwiftUI 뷰 계층구조를 관리하는 뷰컨트롤러이다. 공식문서]]></summary></entry></feed>