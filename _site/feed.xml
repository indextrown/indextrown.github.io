<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-05-24T09:59:42+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">DongHyeon Kim’s Blog</title><subtitle>Swift와 크롤링 기술을 통해 안전한 세상을 만들고 싶습니다.</subtitle><author><name>Dong Hyeon</name></author><entry><title type="html">[CleanArchitecture] SOLID, MVVM, CleanArchitecture</title><link href="http://localhost:4000/CleanArchitecture-Clean-Architecture/" rel="alternate" type="text/html" title="[CleanArchitecture] SOLID, MVVM, CleanArchitecture" /><published>2025-05-24T00:00:00+00:00</published><updated>2025-05-24T00:00:00+00:00</updated><id>http://localhost:4000/%5BCleanArchitecture%5D-Clean%20Architecture</id><content type="html" xml:base="http://localhost:4000/CleanArchitecture-Clean-Architecture/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<!-- <table>
  <tr>
    <td><img src="/assets/img/2025-03-25-%5BCleanArchitecture%5D-CleanArchitecture/clean1.png" alt="커스텀셀1" width="50%"></td>
    <td><img src="/assets/img/2025-03-25-%5BCleanArchitecture%5D-CleanArchitecture/clean3.png" alt="커스텀셀" width="50%"></td>
  </tr>
</table>

<div style="display: flex; justify-content: space-between;">
  <img src="/assets/img/2025-03-25-%5BCleanArchitecture%5D-CleanArchitecture/clean1.png" alt="커스텀셀1" width="50%">
  <img src="/assets/img/2025-03-25-%5BCleanArchitecture%5D-CleanArchitecture/clean3.png" alt="커스텀셀" width="50%">
</div> -->

<!-- <div style="display: flex; justify-content: space-between;">
  <img src="/assets/img/2025-03-25-%5BCleanArchitecture%5D-CleanArchitecture/clean1.png" alt="커스텀셀1" width="50%">
  <img src="/assets/img/2025-03-25-%5BCleanArchitecture%5D-CleanArchitecture/clean3.png" alt="커스텀셀" width="50%">
</div> -->

<h1 id="solod-mvvm-cleanarchitecture">SOLOD, MVVM, CleanArchitecture</h1>

<p>클린 아키텍처를 알기 위해서는 MVVM을 알아야 하고 MVVM을 알기 위해서는 SOLID 원칙을 알아야 한다.  SOLID 원칙 -&gt; MVVM -&gt; Clean Architecture 순서로 정리하였다.</p>

<h2 id="원칙이란">원칙이란?</h2>

<p><img src="/assets/img/2025-05-24-%5BCleanArchitecture%5D-Clean%20Architecture/img.jpg" alt="이미지" width="70%" /></p>
<ul>
  <li>원칙을 지키면 시간이 흐른 뒤에는 큰 영향을 가져온다.</li>
  <li>SOLID 프로그램의 원칙을 지키면 프로젝트 규모가 커질수록 큰 영향을 가져온다.</li>
  <li>원칙을 지키지 않는다면 어디서부터 어떻게 고쳐야 할 지 어렵고, 한 부분을 해결하면 다른 부분에서 문제가 발생할 수도 있다.</li>
  <li>이렇기 때문에 SOLID 원칙을 지켜야 한다.</li>
  <li>이 원칙을 지키면 얻을 수 있는 효과가 유지보수성이다.</li>
  <li>유지보수가 쉬운 코드 = 어떤 상황에서도 잘 동작하고 변경에 용이</li>
</ul>

<hr />

<h2 id="solid원칙">SOLID원칙</h2>

<ul>
  <li>SOLOD원칙은 5가지 원칙을 의미한다.</li>
</ul>

<h3 id="1-단일-책임">1. 단일 책임</h3>

<ul>
  <li>클래스는 하나의 책임만을 가져야 한다</li>
</ul>

<p>ex) ViewConntroller의 책임(책임 = 변경이 일어날 때 영향을 받는다라고 가정)</p>

<ul>
  <li>UI 그리기   (&lt;- 책임)</li>
  <li>UI 로직 구현</li>
  <li>API 호출</li>
  <li>내부 데이터 저장, 불러오기</li>
</ul>

<p>=&gt; 이 4개중에 하나의 책임만 가져야 한다. 여기서는 UI 그리기가 책임이 된다.<br />
<br /><br /></p>

<h3 id="2-개팡-폐쇄">2. 개팡 폐쇄</h3>

<ul>
  <li>클래스는 기능의 확장에 있어서 열려 있어야 하고 수정에는 닫혀 있어야 한다.</li>
</ul>

<p><img src="/assets/img/2025-05-24-%5BCleanArchitecture%5D-Clean%20Architecture/image-20250524154310671.png" alt="이미지" width="50%" /><br />
ViewModel에서 User데이터에 대한 타입이 변경되면 ViewModel에 의존하는 ViewController가 영향을 받는다.  하지만 ViewController에서 UI에 대한 코드가 변경되면 안된다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    MARK: - 개방 폐쇄 원칙
    - viewController가 ViewModelProtocol을 의존하므로 ViewModel 내부 구현이 변경되어도 영향이 없다.
    - ex) FriendUser -&gt; FamilyUser로 바뀌어도 ViewController에서 UI코드 변경 필요 없다.
    - ViewController 코드를 수정하지 않고 기능을 확장할 수 있다.
 */</span>
<span class="kd">protocol</span> <span class="kt">UserProtocol</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">protocol</span> <span class="kt">ViewModelProtocol</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">getUserList</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">UserProtocol</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">FriendUser</span><span class="p">:</span> <span class="kt">UserProtocol</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">struct</span> <span class="kt">FamilyUser</span><span class="p">:</span> <span class="kt">UserProtocol</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">class</span> <span class="kt">ViewModel</span><span class="p">:</span> <span class="kt">ViewModelProtocol</span> <span class="p">{</span>
    <span class="c1">// ViewController는 각 객체가 어떤 구체 타입인지 몰라도 공통 인터페이스(UserProtocol)로 처리 가능하다.</span>
    <span class="kd">func</span> <span class="nf">getUserList</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">UserProtocol</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="kt">FriendUser</span><span class="p">(),</span> <span class="kt">FamilyUser</span><span class="p">()]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /><br /></p>

<h3 id="3-인터페이스-분리-원칙">3. 인터페이스 분리 원칙</h3>

<ul>
  <li>사용하지 않는 인터페이스는 쓰지 않아야 한다.</li>
</ul>

<p><img src="/assets/img/2025-05-24-%5BCleanArchitecture%5D-Clean%20Architecture/image-20250524160614297.png" alt="이미지" width="50%" /><br />
사진과 같이 ViewController가 property1과 func3만 사용한다면  ViewController입장에서 나머지 property2, func1, func2는 필요 없다. 이럴때는 인터페이스를 분리해야 한다.<br />
<br /><br /></p>

<h3 id="4-의존성-역전-원칙">4. 의존성 역전 원칙</h3>

<ul>
  <li>고수준 모듈은 저수준 모듈에 의존해서는 안된다. 둘다 추상화에 의존해야 한다.</li>
</ul>

<p><img src="/assets/img/2025-05-24-%5BCleanArchitecture%5D-Clean%20Architecture/image-20250524161541708.png" alt="이미지" width="50%" /><br />
저수준은 UI와 같이 잘 바뀌는 코드를 의미하고 고수준은 앱에서 핵심 기능인 잘 안바뀌는 기능을 의미한다.(쇼핑앱에서는 결제 기능과 유사)<br />
즉 쉽게 바뀌는 코드가 쉽게 바뀌지 않는 코드를 의존해야 한다.<br />
참고로 추상화(인터페이스)에 의존해야한다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Model</span>
<span class="kd">protocol</span> <span class="kt">UserProtocol</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">FriendUser</span><span class="p">:</span> <span class="kt">UserProtocol</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"친구 유저"</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">FamilyUser</span><span class="p">:</span> <span class="kt">UserProtocol</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"가족 유저"</span>
<span class="p">}</span>

<span class="c1">// MARK: - ViewModelProtocol(고수준의 추상화)</span>
<span class="c1">// 핵심 로직 담당, UserProtocol 추상화에만 의존</span>
<span class="kd">protocol</span> <span class="kt">ViewModelProtocol</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">users</span><span class="p">:</span> <span class="p">[</span><span class="kt">UserProtocol</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 고수준</span>
<span class="kd">class</span> <span class="kt">ViewModel</span><span class="p">:</span> <span class="kt">ViewModelProtocol</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">users</span><span class="p">:</span> <span class="p">[</span><span class="kt">UserProtocol</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="kt">FriendUser</span><span class="p">(),</span><span class="kt">FamilyUser</span><span class="p">()]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - View(저수준)</span>
<span class="c1">// UI 담당, ViewModel의 추상화(ViewModelProtocol)에만 의존</span>
<span class="kd">class</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModelProtocol</span> <span class="c1">// 고수준 추상화에 의존</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModelProtocol</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">viewModel</span> <span class="o">=</span> <span class="n">viewModel</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">user</span> <span class="k">in</span> <span class="n">viewModel</span><span class="o">.</span><span class="n">users</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"👤 이름: </span><span class="se">\(</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - 실행</span>
<span class="k">let</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">ViewModel</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">view</span> <span class="o">=</span> <span class="kt">View</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span>
<span class="n">view</span><span class="o">.</span><span class="nf">render</span><span class="p">()</span>
</code></pre></div></div>

<p><br /><br /></p>

<h3 id="5-리스코프-치환원칙">5. 리스코프 치환원칙</h3>

<ul>
  <li>자식 클래스는 언제나 자신의 부모 클래스로 교체할 수 있어야 한다. 즉 부모 타입을 사용하는 곳에 자식 타입을 넣어도 정상적으로 작동해야 한다.</li>
</ul>

<h3 id="리스코프-치환-위반-예시">리스코프 치환 위반 예시</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Bird</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">fly</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"날아갑니다!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Penguin</span><span class="p">:</span> <span class="kt">Bird</span> <span class="p">{</span>
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">fly</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 펭귄은 날 수 없음 → LSP 위반</span>
        <span class="nf">fatalError</span><span class="p">(</span><span class="s">"펭귄은 날 수 없습니다!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">letBirdFly</span><span class="p">(</span><span class="n">_</span> <span class="nv">bird</span><span class="p">:</span> <span class="kt">Bird</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bird</span><span class="o">.</span><span class="nf">fly</span><span class="p">()</span>
<span class="p">}</span>

<span class="nf">letBirdFly</span><span class="p">(</span><span class="kt">Bird</span><span class="p">())</span>     <span class="c1">// ✅ "날아갑니다!"</span>
<span class="nf">letBirdFly</span><span class="p">(</span><span class="kt">Penguin</span><span class="p">())</span>  <span class="c1">// ❌ 런타임 에러!</span>

</code></pre></div></div>

<h3 id="리스코프-치환-지키는-예시">리스코프 치환 지키는 예시</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Bird</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">move</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">FlyingBird</span><span class="p">:</span> <span class="kt">Bird</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">move</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"날아갑니다!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">WalkingBird</span><span class="p">:</span> <span class="kt">Bird</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">move</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"걸어갑니다!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">letBirdMove</span><span class="p">(</span><span class="n">_</span> <span class="nv">bird</span><span class="p">:</span> <span class="kt">Bird</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bird</span><span class="o">.</span><span class="nf">move</span><span class="p">()</span>
<span class="p">}</span>

<span class="nf">letBirdMove</span><span class="p">(</span><span class="kt">FlyingBird</span><span class="p">())</span> <span class="c1">// ✅ 날아갑니다!</span>
<span class="nf">letBirdMove</span><span class="p">(</span><span class="kt">WalkingBird</span><span class="p">())</span> <span class="c1">// ✅ 걸어갑니다!</span>

</code></pre></div></div>

<hr />

<h2 id="mvvm">MVVM</h2>

<p><img src="/assets/img/2025-05-24-%5BCleanArchitecture%5D-Clean%20Architecture/image-20250524171856966.png" alt="이미지" width="70%" /></p>

<p>SOLID 원칙을 지키기 위해 MVVM 패턴을 사용한다. MVVM패턴을 지키면 자연스럽게 SOLID 원칙을 지킬 수 있다. MVVM은 Model, View, ViewModel로 3등분으로 구성된다.</p>

<h3 id="그림-상세내용참고">그림 상세내용(참고)</h3>

<ul>
  <li>View는 UI를 표현하고 버튼 클릭이나 텍스트 입력과 같은 <strong>이벤트를 ViewModel으로 전달</strong>한다.</li>
  <li>ViewModel은 View(UI)와 관련한 로직을 모두 처리하거나 상태를 보유한다. 또한 View에서 전달된 이벤트에 따라 바뀐 상태나 바뀐 UI 관련 로직을 처리하고 필요시 ViewController에게 바로 상태를 전달하고, 만약 더 핵심적인 비즈니스 로직(API 호츌)이 필요하면 Model에 전달하여 Model에서 핵심 비즈니스 로직을 처리하고 데이터를 다시 ViewModel로 전달해주고 ViewModel에서 UI적인 로직을 처리하여 ViewController에게 상태나 데이터를 전달한다.</li>
</ul>

<h3 id="mvvm-구성">MVVM 구성</h3>

<table>
  <thead>
    <tr>
      <th>구성 요소</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Model</strong></td>
      <td>데이터와 비즈니스 로직 (API 통신, 데이터 가공 등)</td>
    </tr>
    <tr>
      <td><strong>ViewModel</strong></td>
      <td>View에 필요한 상태와 로직을 관리 (UI 상태 결정, 이벤트 처리)</td>
    </tr>
    <tr>
      <td><strong>View (UI)</strong></td>
      <td>사용자 입력, 화면 표시 (이벤트는 ViewModel로 전달)</td>
    </tr>
  </tbody>
</table>

<h3 id="-의존성-방향">🔁 의존성 방향</h3>

<ul>
  <li><strong>View → ViewModel</strong>: View는 ViewModel에 의존 (버튼 클릭 → 메서드 호출 등)</li>
  <li><strong>ViewModel → Model</strong>: ViewModel은 데이터가 필요할 때 Model에 요청</li>
  <li><strong>Model은 아무것도 모름</strong> (하위 계층은 상위 계층을 몰라야 함 = DIP 적용)</li>
  <li>의존성의 방향은 잘 변경되는 쪽이 잘 변경되지 않는 쪽을 바라본다, 즉 각 구성요소가 단방향적인 의존성을 지키고 있다.</li>
</ul>

<h3 id="-solid-원칙-적용-전-mvvm-코드-dip-위반">✅ SOLID 원칙 적용 전 MVVM 코드 (DIP 위반)</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// MARK: - Model</span>
<span class="kd">struct</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="c1">// MARK: - ViewModel (구체 타입에 직접 의존)</span>
<span class="kd">class</span> <span class="kt">UserViewModel</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">user</span><span class="p">:</span> <span class="kt">User</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="kt">User</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">displayName</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="s">"👤 </span><span class="se">\(</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - View (ViewModel의 구체 타입에 의존함 → DIP 위반)</span>
<span class="kd">class</span> <span class="kt">UserView</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">UserViewModel</span>  <span class="c1">// ❌ 구체 클래스에 의존</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="kt">UserViewModel</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">viewModel</span> <span class="o">=</span> <span class="n">viewModel</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">displayName</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - 실행</span>
<span class="k">let</span> <span class="nv">user</span> <span class="o">=</span> <span class="kt">User</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"김동현"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">UserViewModel</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="n">user</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">view</span> <span class="o">=</span> <span class="kt">UserView</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span>
<span class="n">view</span><span class="o">.</span><span class="nf">render</span><span class="p">()</span>
<span class="c1">// 출력: 👤 김동현</span>

</code></pre></div></div>

<h3 id="-solid-원칙-적용-후-mvvm-코드-dip-ocp-등-만족">✅ SOLID 원칙 적용 후 MVVM 코드 (DIP, OCP 등 만족)</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// MARK: - Model</span>
<span class="kd">struct</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="c1">// MARK: - ViewModel 추상화 (DIP 적용)</span>
<span class="kd">protocol</span> <span class="kt">UserViewModelProtocol</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">displayName</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - ViewModel 구현체</span>
<span class="kd">class</span> <span class="kt">UserViewModel</span><span class="p">:</span> <span class="kt">UserViewModelProtocol</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">user</span><span class="p">:</span> <span class="kt">User</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="kt">User</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">displayName</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="s">"👤 </span><span class="se">\(</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - View (프로토콜에 의존함 → DIP 만족)</span>
<span class="kd">class</span> <span class="kt">UserView</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">UserViewModelProtocol</span>  <span class="c1">// ✅ 프로토콜에 의존</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="kt">UserViewModelProtocol</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">viewModel</span> <span class="o">=</span> <span class="n">viewModel</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">displayName</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - 실행</span>
<span class="k">let</span> <span class="nv">user</span> <span class="o">=</span> <span class="kt">User</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"김동현"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">UserViewModel</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="n">user</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">view</span> <span class="o">=</span> <span class="kt">UserView</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span>
<span class="n">view</span><span class="o">.</span><span class="nf">render</span><span class="p">()</span>
<span class="c1">// 출력: 👤 김동현</span>
</code></pre></div></div>

<hr />

<h2 id="interface">Interface</h2>

<p>클린아키텍처를 이해하기위해 인터페이스 개념을 다시 한번 알고 가자.</p>

<h3 id="인터페이스란">인터페이스란?</h3>

<ul>
  <li>우리가 흔이 말하는 앱의 유저 인터페이스(UI)는 사용자가 직접 마주하는 화면을 의미한다.</li>
  <li>어떻게 구성되고, 어떻게 동작하며, 어떤 방식으로 정의한다.</li>
</ul>

<h3 id="️-냉장고로-예시를-들어본다면">❄️ 냉장고로 예시를 들어본다면</h3>

<ul>
  <li>유저 인터페이스(UI): 손잡이, 버튼, 디스플레이</li>
  <li>내부 로직: 온도 조절, 냉각 등 실제 동작</li>
  <li><strong>중요한 포인트</strong>:  <br />
  사용자는 내부 로직을 몰라도, 버튼 하나로 냉장고를 조작할 수 있다.  <br />
  → 즉, <strong>“인터페이스만 알면 사용 가능”</strong>한 구조다.</li>
</ul>

<p><img src="/assets/img/2025-05-24-%5BCleanArchitecture%5D-Clean%20Architecture/image-20250524175041634.png" alt="이미지" width="70%" /></p>

<ul>
  <li>냉장고의 UI는 <code class="language-plaintext highlighter-rouge">ViewController</code>, 내부 로직은 <code class="language-plaintext highlighter-rouge">ViewModel</code>로 비유할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">ViewController</code>는 <strong>“냉장고 온도를 내려주세요”</strong>라고 요청만 한다.</li>
  <li>실제 로직(냉각, 온도 계산 등)은 <code class="language-plaintext highlighter-rouge">ViewModel</code>이 처리한다.</li>
</ul>

<h2 id="인터페이스를-정리하자면">인터페이스를 정리하자면</h2>

<p><img src="/assets/img/2025-05-24-%5BCleanArchitecture%5D-Clean%20Architecture/image-20250524175910967.png" alt="이미지" width="70%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ViewController</code>가 <code class="language-plaintext highlighter-rouge">ViewModel</code>을 <strong>직접 구현이 아닌 인터페이스(Protocol)</strong>에 의존하면,</li>
  <li>내부 로직이 바뀌더라도 ViewController는 수정 없이 그대로 동작할 수 있다.</li>
</ul>

<p>이렇게 <strong>구현을 감추고 필요한 기능만 정의한 것</strong>을 <code class="language-plaintext highlighter-rouge">**추상화**</code>라고 한다.<br />
인터페이스를 사용하는이유 = 의존성을 최소화 하기 위해 = 변경을 대응하기 위함.</p>

<hr />

<h2 id="clean-architecture">Clean Architecture</h2>

<p><img src="/assets/img/2025-03-25-%5BCleanArchitecture%5D-CleanArchitecture/clean1.png" alt="커스텀셀1" width="50%" /><br />
모바일 뿐만 아니라 웹이나 서버 등 여러 곳에서 많이 사용하는 아키텍처이다. 모바일 기준으로는 조금 단순화한 아래 사진을 참고하면 된다.</p>

<p><img src="/assets/img/2025-03-25-%5BCleanArchitecture%5D-CleanArchitecture/clean3.png" alt="커스텀셀" width="50%" /><br />
모바일 기준으로는 크게 3개의 계층(Layer)로 분류한다. Domain Layer, Data Layer, Presentation Layer로 분류한다.</p>

<hr />

<h3 id="domain-layer">Domain Layer</h3>

<p>Domain Layer는 프로젝트의 <strong>가장 핵심적인 영역</strong>이며,  <br />
비즈니스의 규칙과 요구사항을 직접 담고 있는 계층이다.</p>

<h3 id="구성-요소">구성 요소</h3>

<ul>
  <li>Entity - 모델 정의</li>
  <li>UseCase - 핵심적인 비즈니스 로직을 담은 역할
    <ul>
      <li>유저 리스트 불러오기</li>
      <li>유저 상세 데이터 불러오기</li>
      <li>유저를 내부 저장소에 저장하기</li>
    </ul>
  </li>
  <li>Repository Protocol(인터페이스) - UseCase와 Data Layer(서버 API, 로컬 DB)를 연결해주는 중간 다리 역할
    <ul>
      <li><code class="language-plaintext highlighter-rouge">UseCase</code>와 <code class="language-plaintext highlighter-rouge">Data Layer</code> 사이를 연결하는 <strong>추상화 계층</strong></li>
      <li>데이터의 출처가 무엇이든 (API, DB 등) <code class="language-plaintext highlighter-rouge">UseCase</code>는 몰라도 된다</li>
    </ul>
  </li>
</ul>

<h3 id="왜-repository를-사용하는가">왜 Repository를 사용하는가?</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">UseCase</code>는 <strong>데이터가 어디서 오는지 알 필요 없다.</strong>
    <ul>
      <li>API든, CoreData든, Realm이든 전혀 신경 쓰지 않는다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Repository</code>가 데이터의 출처를 감싸서 대신 처리해준다.
    <ul>
      <li>덕분에 <code class="language-plaintext highlighter-rouge">UseCase</code>는 <strong>오직 기능 수행에만 집중 가능</strong></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Repository</code>는 인터페이스만 존재하며, 실제 구현은 <strong>Data Layer</strong>에서 처리한다.</li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="CleanArchitecture" /><summary type="html"><![CDATA[SOLOD, MVVM, CleanArchitecture 클린 아키텍처를 알기 위해서는 MVVM을 알아야 하고 MVVM을 알기 위해서는 SOLID 원칙을 알아야 한다. SOLID 원칙 -&gt; MVVM -&gt; Clean Architecture 순서로 정리하였다. 원칙이란? 원칙을 지키면 시간이 흐른 뒤에는 큰 영향을 가져온다. SOLID 프로그램의 원칙을 지키면 프로젝트 규모가 커질수록 큰 영향을 가져온다. 원칙을 지키지 않는다면 어디서부터 어떻게 고쳐야 할 지 어렵고, 한 부분을 해결하면 다른 부분에서 문제가 발생할 수도 있다. 이렇기 때문에 SOLID 원칙을 지켜야 한다. 이 원칙을 지키면 얻을 수 있는 효과가 유지보수성이다. 유지보수가 쉬운 코드 = 어떤 상황에서도 잘 동작하고 변경에 용이 SOLID원칙 SOLOD원칙은 5가지 원칙을 의미한다. 1. 단일 책임 클래스는 하나의 책임만을 가져야 한다 ex) ViewConntroller의 책임(책임 = 변경이 일어날 때 영향을 받는다라고 가정) UI 그리기 (&lt;- 책임) UI 로직 구현 API 호출 내부 데이터 저장, 불러오기 =&gt; 이 4개중에 하나의 책임만 가져야 한다. 여기서는 UI 그리기가 책임이 된다. 2. 개팡 폐쇄 클래스는 기능의 확장에 있어서 열려 있어야 하고 수정에는 닫혀 있어야 한다. ViewModel에서 User데이터에 대한 타입이 변경되면 ViewModel에 의존하는 ViewController가 영향을 받는다. 하지만 ViewController에서 UI에 대한 코드가 변경되면 안된다. /* MARK: - 개방 폐쇄 원칙 - viewController가 ViewModelProtocol을 의존하므로 ViewModel 내부 구현이 변경되어도 영향이 없다. - ex) FriendUser -&gt; FamilyUser로 바뀌어도 ViewController에서 UI코드 변경 필요 없다. - ViewController 코드를 수정하지 않고 기능을 확장할 수 있다. */ protocol UserProtocol { } protocol ViewModelProtocol { func getUserList() -&gt; [UserProtocol] } struct FriendUser: UserProtocol { } struct FamilyUser: UserProtocol { } class ViewModel: ViewModelProtocol { // ViewController는 각 객체가 어떤 구체 타입인지 몰라도 공통 인터페이스(UserProtocol)로 처리 가능하다. func getUserList() -&gt; [UserProtocol] { return [FriendUser(), FamilyUser()] } } 3. 인터페이스 분리 원칙 사용하지 않는 인터페이스는 쓰지 않아야 한다. 사진과 같이 ViewController가 property1과 func3만 사용한다면 ViewController입장에서 나머지 property2, func1, func2는 필요 없다. 이럴때는 인터페이스를 분리해야 한다. 4. 의존성 역전 원칙 고수준 모듈은 저수준 모듈에 의존해서는 안된다. 둘다 추상화에 의존해야 한다. 저수준은 UI와 같이 잘 바뀌는 코드를 의미하고 고수준은 앱에서 핵심 기능인 잘 안바뀌는 기능을 의미한다.(쇼핑앱에서는 결제 기능과 유사) 즉 쉽게 바뀌는 코드가 쉽게 바뀌지 않는 코드를 의존해야 한다. 참고로 추상화(인터페이스)에 의존해야한다. // MARK: - Model protocol UserProtocol { var name: String { get } } struct FriendUser: UserProtocol { let name: String = "친구 유저" } struct FamilyUser: UserProtocol { let name: String = "가족 유저" } // MARK: - ViewModelProtocol(고수준의 추상화) // 핵심 로직 담당, UserProtocol 추상화에만 의존 protocol ViewModelProtocol { var users: [UserProtocol] { get } } // 고수준 class ViewModel: ViewModelProtocol { var users: [UserProtocol] { return [FriendUser(),FamilyUser()] } } // MARK: - View(저수준) // UI 담당, ViewModel의 추상화(ViewModelProtocol)에만 의존 class View { private let viewModel: ViewModelProtocol // 고수준 추상화에 의존 init(viewModel: ViewModelProtocol) { self.viewModel = viewModel } func render() { for user in viewModel.users { print("👤 이름: \(user.name)") } } } // MARK: - 실행 let viewModel = ViewModel() let view = View(viewModel: viewModel) view.render() 5. 리스코프 치환원칙 자식 클래스는 언제나 자신의 부모 클래스로 교체할 수 있어야 한다. 즉 부모 타입을 사용하는 곳에 자식 타입을 넣어도 정상적으로 작동해야 한다. 리스코프 치환 위반 예시 class Bird { func fly() { print("날아갑니다!") } } class Penguin: Bird { override func fly() { // 펭귄은 날 수 없음 → LSP 위반 fatalError("펭귄은 날 수 없습니다!") } } func letBirdFly(_ bird: Bird) { bird.fly() } letBirdFly(Bird()) // ✅ "날아갑니다!" letBirdFly(Penguin()) // ❌ 런타임 에러! 리스코프 치환 지키는 예시 protocol Bird { func move() } class FlyingBird: Bird { func move() { print("날아갑니다!") } } class WalkingBird: Bird { func move() { print("걸어갑니다!") } } func letBirdMove(_ bird: Bird) { bird.move() } letBirdMove(FlyingBird()) // ✅ 날아갑니다! letBirdMove(WalkingBird()) // ✅ 걸어갑니다! MVVM SOLID 원칙을 지키기 위해 MVVM 패턴을 사용한다. MVVM패턴을 지키면 자연스럽게 SOLID 원칙을 지킬 수 있다. MVVM은 Model, View, ViewModel로 3등분으로 구성된다. 그림 상세내용(참고) View는 UI를 표현하고 버튼 클릭이나 텍스트 입력과 같은 이벤트를 ViewModel으로 전달한다. ViewModel은 View(UI)와 관련한 로직을 모두 처리하거나 상태를 보유한다. 또한 View에서 전달된 이벤트에 따라 바뀐 상태나 바뀐 UI 관련 로직을 처리하고 필요시 ViewController에게 바로 상태를 전달하고, 만약 더 핵심적인 비즈니스 로직(API 호츌)이 필요하면 Model에 전달하여 Model에서 핵심 비즈니스 로직을 처리하고 데이터를 다시 ViewModel로 전달해주고 ViewModel에서 UI적인 로직을 처리하여 ViewController에게 상태나 데이터를 전달한다. MVVM 구성 구성 요소 역할 Model 데이터와 비즈니스 로직 (API 통신, 데이터 가공 등) ViewModel View에 필요한 상태와 로직을 관리 (UI 상태 결정, 이벤트 처리) View (UI) 사용자 입력, 화면 표시 (이벤트는 ViewModel로 전달) 🔁 의존성 방향 View → ViewModel: View는 ViewModel에 의존 (버튼 클릭 → 메서드 호출 등) ViewModel → Model: ViewModel은 데이터가 필요할 때 Model에 요청 Model은 아무것도 모름 (하위 계층은 상위 계층을 몰라야 함 = DIP 적용) 의존성의 방향은 잘 변경되는 쪽이 잘 변경되지 않는 쪽을 바라본다, 즉 각 구성요소가 단방향적인 의존성을 지키고 있다. ✅ SOLID 원칙 적용 전 MVVM 코드 (DIP 위반) // MARK: - Model struct User { let name: String } // MARK: - ViewModel (구체 타입에 직접 의존) class UserViewModel { private let user: User init(user: User) { self.user = user } var displayName: String { "👤 \(user.name)" } } // MARK: - View (ViewModel의 구체 타입에 의존함 → DIP 위반) class UserView { private let viewModel: UserViewModel // ❌ 구체 클래스에 의존 init(viewModel: UserViewModel) { self.viewModel = viewModel } func render() { print(viewModel.displayName) } } // MARK: - 실행 let user = User(name: "김동현") let viewModel = UserViewModel(user: user) let view = UserView(viewModel: viewModel) view.render() // 출력: 👤 김동현 ✅ SOLID 원칙 적용 후 MVVM 코드 (DIP, OCP 등 만족) // MARK: - Model struct User { let name: String } // MARK: - ViewModel 추상화 (DIP 적용) protocol UserViewModelProtocol { var displayName: String { get } } // MARK: - ViewModel 구현체 class UserViewModel: UserViewModelProtocol { private let user: User init(user: User) { self.user = user } var displayName: String { "👤 \(user.name)" } } // MARK: - View (프로토콜에 의존함 → DIP 만족) class UserView { private let viewModel: UserViewModelProtocol // ✅ 프로토콜에 의존 init(viewModel: UserViewModelProtocol) { self.viewModel = viewModel } func render() { print(viewModel.displayName) } } // MARK: - 실행 let user = User(name: "김동현") let viewModel = UserViewModel(user: user) let view = UserView(viewModel: viewModel) view.render() // 출력: 👤 김동현 Interface 클린아키텍처를 이해하기위해 인터페이스 개념을 다시 한번 알고 가자. 인터페이스란? 우리가 흔이 말하는 앱의 유저 인터페이스(UI)는 사용자가 직접 마주하는 화면을 의미한다. 어떻게 구성되고, 어떻게 동작하며, 어떤 방식으로 정의한다. ❄️ 냉장고로 예시를 들어본다면 유저 인터페이스(UI): 손잡이, 버튼, 디스플레이 내부 로직: 온도 조절, 냉각 등 실제 동작 중요한 포인트: 사용자는 내부 로직을 몰라도, 버튼 하나로 냉장고를 조작할 수 있다. → 즉, “인터페이스만 알면 사용 가능”한 구조다. 냉장고의 UI는 ViewController, 내부 로직은 ViewModel로 비유할 수 있다. ViewController는 “냉장고 온도를 내려주세요”라고 요청만 한다. 실제 로직(냉각, 온도 계산 등)은 ViewModel이 처리한다. 인터페이스를 정리하자면 ViewController가 ViewModel을 직접 구현이 아닌 인터페이스(Protocol)에 의존하면, 내부 로직이 바뀌더라도 ViewController는 수정 없이 그대로 동작할 수 있다. 이렇게 구현을 감추고 필요한 기능만 정의한 것을 **추상화**라고 한다. 인터페이스를 사용하는이유 = 의존성을 최소화 하기 위해 = 변경을 대응하기 위함. Clean Architecture 모바일 뿐만 아니라 웹이나 서버 등 여러 곳에서 많이 사용하는 아키텍처이다. 모바일 기준으로는 조금 단순화한 아래 사진을 참고하면 된다. 모바일 기준으로는 크게 3개의 계층(Layer)로 분류한다. Domain Layer, Data Layer, Presentation Layer로 분류한다. Domain Layer Domain Layer는 프로젝트의 가장 핵심적인 영역이며, 비즈니스의 규칙과 요구사항을 직접 담고 있는 계층이다. 구성 요소 Entity - 모델 정의 UseCase - 핵심적인 비즈니스 로직을 담은 역할 유저 리스트 불러오기 유저 상세 데이터 불러오기 유저를 내부 저장소에 저장하기 Repository Protocol(인터페이스) - UseCase와 Data Layer(서버 API, 로컬 DB)를 연결해주는 중간 다리 역할 UseCase와 Data Layer 사이를 연결하는 추상화 계층 데이터의 출처가 무엇이든 (API, DB 등) UseCase는 몰라도 된다 왜 Repository를 사용하는가? UseCase는 데이터가 어디서 오는지 알 필요 없다. API든, CoreData든, Realm이든 전혀 신경 쓰지 않는다. Repository가 데이터의 출처를 감싸서 대신 처리해준다. 덕분에 UseCase는 오직 기능 수행에만 집중 가능 Repository는 인터페이스만 존재하며, 실제 구현은 Data Layer에서 처리한다.]]></summary></entry><entry><title type="html">[UIKit] iOS 푸시알림 FCM, APNS</title><link href="http://localhost:4000/UIKit-FCM/" rel="alternate" type="text/html" title="[UIKit] iOS 푸시알림 FCM, APNS" /><published>2025-05-22T00:00:00+00:00</published><updated>2025-05-22T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-FCM</id><content type="html" xml:base="http://localhost:4000/UIKit-FCM/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="ios-푸시알림-fcm-apns">iOS 푸시알림 FCM, APNS</h2>

<p>iOS에서 푸시 종류는 2가지가 있다.</p>

<ol>
  <li>로컬에서 직접 보내는 알림</li>
  <li>서버에서 보내는 알림
    <ul>
      <li>서버에서 보내는 APNS(Apple Push Notification Service)</li>
      <li>
        <p>FCM(Firebase Cloud Messaging) -&gt; 이번 포스팅에서는 FCM을 활용한 2번 방식을 진행할 예정이다.</p>

        <p>​</p>
      </li>
    </ul>
  </li>
</ol>

<h2 id="apns-란">APNS 란?</h2>

<p><strong>APNS (Apple Push Notification Service)</strong> 는  <br />
iOS의 모든 원격 알림이 반드시 거쳐야 하는 <strong>애플 공식 푸시 전달 서버</strong>이다..</p>

<p>즉, 푸시 메시지를 <strong>내가 직접 사용자 기기로 보내는 게 아니라</strong>  <br />
→ <strong>APNS에 요청</strong>  <br />
→ <strong>APNS가 사용자 기기로 전송</strong>  <br />
하는 방식이다.</p>

<hr />

<h2 id="fcm-란">FCM 란?</h2>

<p><strong>FCM은 Google에서 제공하는 클라우드 기반 메시징 서비스</strong>로,<br />
iOS의 APNS를 포함해 Android, Web 등 다양한 플랫폼에 푸시 메시지를 전송할 수 있도록 <strong>중간 서버 역할</strong>을 해준다.<br />
iOS에서 FCM을 통해 푸시 알림을 보내면, FCM 내부적으로 APNS를 거쳐서 사용자 기기에 도달한다.</p>

<h4 id="fcm이-apns-대신-해주는-것들">FCM이 APNS 대신 해주는 것들</h4>

<ul>
  <li>애플 인증서 등록 및 관리</li>
  <li>APNS에 메시지 전송 요청</li>
  <li>안드로이드, iOS 둘 다 지원 (멀티 플랫폼)</li>
  <li>클라우드 환경에서 손쉽게 운영</li>
</ul>

<h3 id="왜-fcm을-쓰는가">왜 FCM을 쓰는가?</h3>

<ul>
  <li>APNS 서버 직접 구축이 <strong>복잡하고 부담스러울 때</strong></li>
  <li><strong>iOS &amp; Android를 동시에 지원</strong>하는 일관된 환경이 필요할 때</li>
  <li>푸시 알림 시스템을 <strong>빠르게 구축</strong>하고 싶을 때</li>
  <li><strong>Firebase Analytics</strong>, <strong>A/B 테스트</strong> 같은 연계 기능을 활용할 때</li>
</ul>

<hr />

<h2 id="푸시-알림의-기본-동작-흐름">푸시 알림의 기본 동작 흐름</h2>

<ol>
  <li><strong>앱이 APNS에 Device Token 요청</strong>
    <ul>
      <li>이 토큰은 <strong>앱이 설치된 기기의 주소 역할</strong>을 한다.</li>
    </ul>
  </li>
  <li><strong>APNS가 앱에게 Device Token 전달</strong></li>
  <li><strong>앱이 Device Token을 푸시 서버(FCM 등)에 전달</strong>
    <ul>
      <li>이 서버가 실제 푸시 메시지를 보낼 주체이다.</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="apns를-통한-푸시-알림-동작-구조">APNS를 통한 푸시 알림 동작 구조</h2>

<ol>
  <li>푸시 서버(예: FCM)가 메시지와 Device Token을 APNS에 전송
    <ul>
      <li>이때 APNS와 푸시 서버는 <strong>TLS 인증</strong>으로 보안 통신</li>
      <li>서버에는 <strong>APNS 인증 정보(p8 키 or 인증서)</strong>가 등록되어 있어야 함</li>
    </ul>
  </li>
  <li>APNS는 해당 디바이스로 푸시 메시지를 전송</li>
  <li>디바이스에서 푸시 알림 수신</li>
</ol>

<hr />

<h2 id="실습">실습</h2>

<p><img src="/assets/img/2025-05-22-%5BUIKit%5D-FCM/image-20250522235833599.png" alt="이미지" width="100%" /><br />
identifiers에서 해당 프로젝트 누른 후 push notification 체크박스 체크 해준다.</p>

<p><img src="/assets/img/2025-05-22-%5BUIKit%5D-FCM/image-20250523000005112.png" alt="이미지" width="100%" /><br />
keys에서 키를 발급 해준다. 완료하면 Download버튼이 생긴다 이를 통해 p8파일을 다운로드 한다.</p>

<p><img src="/assets/img/2025-05-22-%5BUIKit%5D-FCM/image-20250523000727014.png" alt="이미지" width="100%" /><br />
firebase 프로젝트 -&gt; 프로젝트 설정 -&gt; 클라우드 메시징에서 APNS인증키를 등록해준다.</p>

<p><img src="/assets/img/2025-05-22-%5BUIKit%5D-FCM/image-20250523000908524.png" alt="이미지" width="30%" /><br />
업로드를 눌러서 완료한다.</p>

<table>
  <tr>
    <td><img src="/assets/img/2025-05-22-%5BUIKit%5D-FCM/image-20250523001147940.png" alt="커스텀셀1" width="100%" /></td>
    <td><img src="/assets/img/2025-05-22-%5BUIKit%5D-FCM/image-20250523001324675.png" alt="커스텀셀" width="100%" /></td>
  </tr>
  <tr>
    <td style="text-align:center;">Push Notifications</td>
    <td style="text-align:center;">Background Modes</td>
  </tr>
</table>
<p>xcode -&gt; target -&gt; Push Notifications, Background Mode 추가한다.</p>

<p><img src="/assets/img/2025-05-22-%5BUIKit%5D-FCM/image-20250523001739843.png" alt="이미지" width="100%" /><br />
Remote Notifications 체크해준다.</p>

<hr />

<h2 id="appdelegateswift">AppDelegate.swift</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">FirebaseCore</span>
<span class="kd">import</span> <span class="kt">FirebaseMessaging</span>
<span class="kd">import</span> <span class="kt">UserNotifications</span>

<span class="kd">@main</span>
<span class="kd">class</span> <span class="kt">AppDelegate</span><span class="p">:</span> <span class="kt">UIResponder</span><span class="p">,</span> <span class="kt">UIApplicationDelegate</span> <span class="p">{</span>
    
    <span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">application</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span>
                     <span class="n">didFinishLaunchingWithOptions</span> <span class="nv">launchOptions</span><span class="p">:</span> <span class="p">[</span><span class="kt">UIApplication</span><span class="o">.</span><span class="kt">LaunchOptionsKey</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]?)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        
        <span class="c1">// Firebase 초기화</span>
        <span class="kt">FirebaseApp</span><span class="o">.</span><span class="nf">configure</span><span class="p">()</span>
        
        <span class="c1">// 알림 권한 요청</span>
        <span class="kt">UNUserNotificationCenter</span><span class="o">.</span><span class="nf">current</span><span class="p">()</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
        <span class="kt">UNUserNotificationCenter</span><span class="o">.</span><span class="nf">current</span><span class="p">()</span><span class="o">.</span><span class="nf">requestAuthorization</span><span class="p">(</span>
            <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">alert</span><span class="p">,</span> <span class="o">.</span><span class="n">badge</span><span class="p">,</span> <span class="o">.</span><span class="n">sound</span><span class="p">]</span>
        <span class="p">)</span> <span class="p">{</span> <span class="n">granted</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"✅ 알림 권한 요청 결과: </span><span class="se">\(</span><span class="n">granted</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">granted</span> <span class="p">{</span>
                <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
                    <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">registerForRemoteNotifications</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// FCM 설정</span>
        <span class="kt">Messaging</span><span class="o">.</span><span class="nf">messaging</span><span class="p">()</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
        
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">AppDelegate</span><span class="p">:</span> <span class="kt">UNUserNotificationCenterDelegate</span> <span class="p">{</span>
    
    <span class="c1">// APNs로부터 device token 받았을 때 FCM에 등록</span>
    <span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">application</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span>
                     <span class="n">didRegisterForRemoteNotificationsWithDeviceToken</span> <span class="nv">deviceToken</span><span class="p">:</span> <span class="kt">Data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"📮 APNS Token 수신: </span><span class="se">\(</span><span class="n">deviceToken</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="kt">Messaging</span><span class="o">.</span><span class="nf">messaging</span><span class="p">()</span><span class="o">.</span><span class="n">apnsToken</span> <span class="o">=</span> <span class="n">deviceToken</span>
    <span class="p">}</span>

    <span class="c1">// 앱이 실행 중일 때 알림 수신 (배너로 표시되게 설정)</span>
    <span class="kd">func</span> <span class="nf">userNotificationCenter</span><span class="p">(</span><span class="n">_</span> <span class="nv">center</span><span class="p">:</span> <span class="kt">UNUserNotificationCenter</span><span class="p">,</span>
                                <span class="n">willPresent</span> <span class="nv">notification</span><span class="p">:</span> <span class="kt">UNNotification</span><span class="p">,</span>
                                <span class="n">withCompletionHandler</span> <span class="nv">completionHandler</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">UNNotificationPresentationOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">completionHandler</span><span class="p">([</span><span class="o">.</span><span class="n">list</span><span class="p">,</span> <span class="o">.</span><span class="n">banner</span><span class="p">,</span> <span class="o">.</span><span class="n">sound</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">AppDelegate</span><span class="p">:</span> <span class="kt">MessagingDelegate</span> <span class="p">{</span>
    
    <span class="c1">// FCM 토큰 갱신될 때 호출</span>
    <span class="kd">func</span> <span class="nf">messaging</span><span class="p">(</span><span class="n">_</span> <span class="nv">messaging</span><span class="p">:</span> <span class="kt">Messaging</span><span class="p">,</span> <span class="n">didReceiveRegistrationToken</span> <span class="nv">fcmToken</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"📌 FCM Token: </span><span class="se">\(</span><span class="n">fcmToken</span> <span class="p">??</span> <span class="s">"nil"</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        
        <span class="c1">// 필요 시 NotificationCenter로 다른 컴포넌트에 전달</span>
        <span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">post</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="kt">Notification</span><span class="o">.</span><span class="kt">Name</span><span class="p">(</span><span class="s">"FCMToken"</span><span class="p">),</span>
            <span class="nv">object</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
            <span class="nv">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="s">"token"</span><span class="p">:</span> <span class="n">fcmToken</span> <span class="p">??</span> <span class="s">""</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


</code></pre></div></div>

<ul>
  <li>빌드하면 나오는 FCM을 복사한다.</li>
</ul>

<p>FCM.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">firebase_admin</span>
<span class="kn">from</span> <span class="n">firebase_admin</span> <span class="kn">import</span> <span class="n">credentials</span><span class="p">,</span> <span class="n">messaging</span>

<span class="c1"># 1. 서비스 계정 키 경로 (.json)
</span><span class="n">cred</span> <span class="o">=</span> <span class="n">credentials</span><span class="p">.</span><span class="nc">Certificate</span><span class="p">(</span><span class="sh">"</span><span class="s">파이어베이스 설정 -&gt; 서비스 계정 -&gt; 새 비공키 키 생성시 .json파일 다운 가능 -&gt; 해당 경로 입력</span><span class="sh">"</span><span class="p">)</span>
<span class="n">firebase_admin</span><span class="p">.</span><span class="nf">initialize_app</span><span class="p">(</span><span class="n">cred</span><span class="p">)</span>

<span class="c1"># 2. 대상 유저의 FCM 토큰
</span><span class="n">fcm_token</span> <span class="o">=</span> <span class="sh">"</span><span class="s">빌드하면 나오는 FCM 입력</span><span class="sh">"</span>

<span class="c1"># 3. 전송할 메시지
</span><span class="n">title</span> <span class="o">=</span> <span class="sh">"</span><span class="s">새 댓글이 달렸어요!</span><span class="sh">"</span>
<span class="n">body</span> <span class="o">=</span> <span class="sh">"</span><span class="s">당신의 게시글에 누군가 댓글을 남겼습니다.</span><span class="sh">"</span>

<span class="c1"># 4. 알림 메시지 구성
</span><span class="n">message</span> <span class="o">=</span> <span class="n">messaging</span><span class="p">.</span><span class="nc">Message</span><span class="p">(</span>
    <span class="n">token</span><span class="o">=</span><span class="n">fcm_token</span><span class="p">,</span>
    <span class="n">notification</span><span class="o">=</span><span class="n">messaging</span><span class="p">.</span><span class="nc">Notification</span><span class="p">(</span>
        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
        <span class="n">body</span><span class="o">=</span><span class="n">body</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="c1"># 5. 메시지 전송
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">messaging</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✅ 메시지 전송 성공:</span><span class="sh">"</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">❌ 메시지 전송 실패:</span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
    <td><img src="/assets/img/2025-05-22-%5BUIKit%5D-FCM/image-20250523002353948.png" alt="커스텀셀1" width="100%" /></td>
    <td><img src="/assets/img/2025-05-22-%5BUIKit%5D-FCM/image-20250523002621503.png" alt="커스텀셀" width="100%" /></td>
  </tr>
  <tr>
    <td style="text-align:center;">앱이 종료되어있을 때</td>
    <td style="text-align:center;">앱 실행중일 때</td>
  </tr>
</table>

<h2 id="reference">Reference</h2>

<ul>
  <li>https://bannavi.tistory.com/558</li>
  <li>https://dokit.tistory.com/49</li>
  <li>https://dokit.tistory.com/50</li>
  <li>https://velog.io/@niro/Firebase-Push-Notification-알림-보내기-with-SwiftUI</li>
  <li>https://yagom.net/forums/topic/push-알림을-보낼-때-fcm-과-apns-의-차이점이-있나요/</li>
</ul>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><summary type="html"><![CDATA[iOS 푸시알림 FCM, APNS iOS에서 푸시 종류는 2가지가 있다. 로컬에서 직접 보내는 알림 서버에서 보내는 알림 서버에서 보내는 APNS(Apple Push Notification Service) FCM(Firebase Cloud Messaging) -&gt; 이번 포스팅에서는 FCM을 활용한 2번 방식을 진행할 예정이다. ​ APNS 란? APNS (Apple Push Notification Service) 는 iOS의 모든 원격 알림이 반드시 거쳐야 하는 애플 공식 푸시 전달 서버이다.. 즉, 푸시 메시지를 내가 직접 사용자 기기로 보내는 게 아니라 → APNS에 요청 → APNS가 사용자 기기로 전송 하는 방식이다. FCM 란? FCM은 Google에서 제공하는 클라우드 기반 메시징 서비스로, iOS의 APNS를 포함해 Android, Web 등 다양한 플랫폼에 푸시 메시지를 전송할 수 있도록 중간 서버 역할을 해준다. iOS에서 FCM을 통해 푸시 알림을 보내면, FCM 내부적으로 APNS를 거쳐서 사용자 기기에 도달한다. FCM이 APNS 대신 해주는 것들 애플 인증서 등록 및 관리 APNS에 메시지 전송 요청 안드로이드, iOS 둘 다 지원 (멀티 플랫폼) 클라우드 환경에서 손쉽게 운영 왜 FCM을 쓰는가? APNS 서버 직접 구축이 복잡하고 부담스러울 때 iOS &amp; Android를 동시에 지원하는 일관된 환경이 필요할 때 푸시 알림 시스템을 빠르게 구축하고 싶을 때 Firebase Analytics, A/B 테스트 같은 연계 기능을 활용할 때 푸시 알림의 기본 동작 흐름 앱이 APNS에 Device Token 요청 이 토큰은 앱이 설치된 기기의 주소 역할을 한다. APNS가 앱에게 Device Token 전달 앱이 Device Token을 푸시 서버(FCM 등)에 전달 이 서버가 실제 푸시 메시지를 보낼 주체이다. APNS를 통한 푸시 알림 동작 구조 푸시 서버(예: FCM)가 메시지와 Device Token을 APNS에 전송 이때 APNS와 푸시 서버는 TLS 인증으로 보안 통신 서버에는 APNS 인증 정보(p8 키 or 인증서)가 등록되어 있어야 함 APNS는 해당 디바이스로 푸시 메시지를 전송 디바이스에서 푸시 알림 수신 실습 identifiers에서 해당 프로젝트 누른 후 push notification 체크박스 체크 해준다. keys에서 키를 발급 해준다. 완료하면 Download버튼이 생긴다 이를 통해 p8파일을 다운로드 한다. firebase 프로젝트 -&gt; 프로젝트 설정 -&gt; 클라우드 메시징에서 APNS인증키를 등록해준다. 업로드를 눌러서 완료한다. Push Notifications Background Modes xcode -&gt; target -&gt; Push Notifications, Background Mode 추가한다. Remote Notifications 체크해준다. AppDelegate.swift import UIKit import FirebaseCore import FirebaseMessaging import UserNotifications @main class AppDelegate: UIResponder, UIApplicationDelegate { func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { // Firebase 초기화 FirebaseApp.configure() // 알림 권한 요청 UNUserNotificationCenter.current().delegate = self UNUserNotificationCenter.current().requestAuthorization( options: [.alert, .badge, .sound] ) { granted, error in print("✅ 알림 권한 요청 결과: \(granted)") if granted { DispatchQueue.main.async { UIApplication.shared.registerForRemoteNotifications() } } } // FCM 설정 Messaging.messaging().delegate = self return true } } extension AppDelegate: UNUserNotificationCenterDelegate { // APNs로부터 device token 받았을 때 FCM에 등록 func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { print("📮 APNS Token 수신: \(deviceToken)") Messaging.messaging().apnsToken = deviceToken } // 앱이 실행 중일 때 알림 수신 (배너로 표시되게 설정) func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) { completionHandler([.list, .banner, .sound]) } } extension AppDelegate: MessagingDelegate { // FCM 토큰 갱신될 때 호출 func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) { print("📌 FCM Token: \(fcmToken ?? "nil")") // 필요 시 NotificationCenter로 다른 컴포넌트에 전달 NotificationCenter.default.post( name: Notification.Name("FCMToken"), object: nil, userInfo: ["token": fcmToken ?? ""] ) } } 빌드하면 나오는 FCM을 복사한다. FCM.py import firebase_admin from firebase_admin import credentials, messaging # 1. 서비스 계정 키 경로 (.json) cred = credentials.Certificate("파이어베이스 설정 -&gt; 서비스 계정 -&gt; 새 비공키 키 생성시 .json파일 다운 가능 -&gt; 해당 경로 입력") firebase_admin.initialize_app(cred) # 2. 대상 유저의 FCM 토큰 fcm_token = "빌드하면 나오는 FCM 입력" # 3. 전송할 메시지 title = "새 댓글이 달렸어요!" body = "당신의 게시글에 누군가 댓글을 남겼습니다." # 4. 알림 메시지 구성 message = messaging.Message( token=fcm_token, notification=messaging.Notification( title=title, body=body, ) ) # 5. 메시지 전송 try: response = messaging.send(message) print("✅ 메시지 전송 성공:", response) except Exception as e: print("❌ 메시지 전송 실패:", e) 앱이 종료되어있을 때 앱 실행중일 때 Reference https://bannavi.tistory.com/558 https://dokit.tistory.com/49 https://dokit.tistory.com/50 https://velog.io/@niro/Firebase-Push-Notification-알림-보내기-with-SwiftUI https://yagom.net/forums/topic/push-알림을-보낼-때-fcm-과-apns-의-차이점이-있나요/]]></summary></entry><entry><title type="html">[Baekjoon] 백준 2828 사과 담기 게임</title><link href="http://localhost:4000/Baekjoon-2828/" rel="alternate" type="text/html" title="[Baekjoon] 백준 2828 사과 담기 게임" /><published>2025-05-22T00:00:00+00:00</published><updated>2025-05-22T00:00:00+00:00</updated><id>http://localhost:4000/%5BBaekjoon%5D-2828</id><content type="html" xml:base="http://localhost:4000/Baekjoon-2828/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->
<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="문제">문제</h2>
<p><a href="https://www.acmicpc.net/problem/2828">사과 담기 게임</a></p>

<p><img src="/assets/img/2025-05-22-%5BBaekjoon%5D-2828/image-20250522131128824.png" alt="이미지" width="100%" /><br />
스크린 위에서 사과 여러개가 떨어질 때 바구니로 사과를 담기 위한 이동거리의 최솟값을 구하라</p>

<h2 id="풀이">풀이</h2>
<p>시작지점을 left와 right를 방정식으로 나타낼 수 있다.<br />
left = 1<br />
right = left + m - 1</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 5 1
 3
 1
 5
 3
 */</span>

<span class="k">let</span> <span class="nv">input</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span><span class="o">!.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">Int</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span><span class="o">!</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">n</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c1">// screen</span>
<span class="k">let</span> <span class="nv">m</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>          <span class="c1">// basket</span>
<span class="k">let</span> <span class="nv">j</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="nf">readLine</span><span class="p">()</span><span class="o">!</span><span class="p">)</span><span class="o">!</span> <span class="c1">// count</span>

<span class="k">var</span> <span class="nv">left</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">var</span> <span class="nv">right</span> <span class="o">=</span> <span class="k">left</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// 그냉 m으로 해도 된다</span>
<span class="k">var</span> <span class="nv">totalMove</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">j</span> <span class="p">{</span>
    <span class="c1">// 사과가 떨어지는 위치</span>
    <span class="k">let</span> <span class="nv">pos</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="nf">readLine</span><span class="p">()</span><span class="o">!</span><span class="p">)</span><span class="o">!</span>
    
    <span class="c1">// 사과의 위치가 이미 바구니가 있는 위치이면 아래 바구니 이동 로직을 무시</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="k">left</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="k">right</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
   
    <span class="c1">// 포지션이 바구니 안에 있으면 이동 안함</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="k">left</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">move</span> <span class="o">=</span> <span class="k">left</span> <span class="o">-</span> <span class="n">pos</span>
        <span class="k">left</span> <span class="o">-=</span> <span class="n">move</span>
        <span class="k">right</span> <span class="o">-=</span> <span class="n">move</span>
        <span class="n">totalMove</span> <span class="o">+=</span> <span class="n">move</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="k">right</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">move</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="k">right</span>
        <span class="k">right</span> <span class="o">+=</span> <span class="n">move</span>
        <span class="k">left</span> <span class="o">+=</span> <span class="n">move</span>
        <span class="n">totalMove</span> <span class="o">+=</span> <span class="n">move</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="n">totalMove</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="Baekjoon" /><summary type="html"><![CDATA[문제 사과 담기 게임 스크린 위에서 사과 여러개가 떨어질 때 바구니로 사과를 담기 위한 이동거리의 최솟값을 구하라 풀이 시작지점을 left와 right를 방정식으로 나타낼 수 있다. left = 1 right = left + m - 1 /* 5 1 3 1 5 3 */ let input = readLine()!.split(separator: " ").map { Int($0)! } let n = input[0] // screen let m = input[1] // basket let j = Int(readLine()!)! // count var left = 1 var right = left + m - 1 // 그냉 m으로 해도 된다 var totalMove = 0 for _ in 0..&lt;j { // 사과가 떨어지는 위치 let pos = Int(readLine()!)! // 사과의 위치가 이미 바구니가 있는 위치이면 아래 바구니 이동 로직을 무시 if pos &gt;= left &amp;&amp; pos &lt;= right { continue } // 포지션이 바구니 안에 있으면 이동 안함 if pos &lt; left { let move = left - pos left -= move right -= move totalMove += move } else if pos &gt; right { let move = pos - right right += move left += move totalMove += move } } print(totalMove)]]></summary></entry><entry><title type="html">[Baekjoon] 백준 2910 빈도 정렬</title><link href="http://localhost:4000/Baekjoon-2910/" rel="alternate" type="text/html" title="[Baekjoon] 백준 2910 빈도 정렬" /><published>2025-05-22T00:00:00+00:00</published><updated>2025-05-22T00:00:00+00:00</updated><id>http://localhost:4000/%5BBaekjoon%5D-2910</id><content type="html" xml:base="http://localhost:4000/Baekjoon-2910/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->
<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="문제">문제</h2>
<p><a href="https://www.acmicpc.net/problem/2910">빈도 정렬</a></p>

<p><img src="/assets/img/2025-05-22-%5BBaekjoon%5D-2910/image-20250523012134858.png" alt="이미지" width="100%" /><br />
자주 등장하는 숫자 기준으로 오름차순 정렬하되, 등장횟수가 같다면 먼저 나온 것이 앞에 있어야 한다.</p>

<h2 id="풀이">풀이</h2>

<p>정렬 관련 함수</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 배열</span>
<span class="k">var</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="c1">// 오름차순 정렬</span>
<span class="k">let</span> <span class="nv">ascending</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="nf">sorted</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"오름차순:"</span><span class="p">,</span> <span class="n">ascending</span><span class="p">)</span> <span class="c1">// [1, 2, 3, 5, 8]</span>

<span class="c1">// 내림차순 정렬</span>
<span class="k">let</span> <span class="nv">descending</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="o">&gt;</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"내림차순:"</span><span class="p">,</span> <span class="n">descending</span><span class="p">)</span> <span class="c1">// [8, 5, 3, 2, 1]</span>


<span class="c1">// 딕셔너리</span>
<span class="k">let</span> <span class="nv">scores</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Alice"</span><span class="p">:</span> <span class="mi">88</span><span class="p">,</span> <span class="s">"Bob"</span><span class="p">:</span> <span class="mi">95</span><span class="p">,</span> <span class="s">"Charlie"</span><span class="p">:</span> <span class="mi">72</span><span class="p">]</span>

<span class="c1">// 🔹 value 기준 오름차순 정렬</span>
<span class="k">let</span> <span class="nv">byScoreAsc</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span> <span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"점수 오름차순:"</span><span class="p">,</span> <span class="n">byScoreAsc</span><span class="p">)</span>

<span class="c1">// 🔹 value 기준 내림차순 정렬</span>
<span class="k">let</span> <span class="nv">byScoreDesc</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span> <span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"점수 내림차순:"</span><span class="p">,</span> <span class="n">byScoreDesc</span><span class="p">)</span>

<span class="c1">// 🔹 key 기준 오름차순 정렬</span>
<span class="k">let</span> <span class="nv">byNameAsc</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="nv">$1</span><span class="o">.</span><span class="n">key</span> <span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"이름 오름차순:"</span><span class="p">,</span> <span class="n">byNameAsc</span><span class="p">)</span>

<span class="c1">// 우선순위 기반 정렬 1</span>
<span class="k">let</span> <span class="nv">dic</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">1</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="c1">// 우선순위: 2 &gt; 3 &gt; 1 &gt; 4</span>

<span class="k">let</span> <span class="nv">sortedKeys</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
        <span class="c1">// O(n)</span>
        <span class="k">return</span> <span class="n">order</span><span class="o">.</span><span class="nf">firstIndex</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">key</span><span class="p">)</span><span class="o">!</span> <span class="o">&lt;</span> <span class="n">order</span><span class="o">.</span><span class="nf">firstIndex</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="nv">$1</span><span class="o">.</span><span class="n">key</span><span class="p">)</span><span class="o">!</span> <span class="c1">// &lt;: 인덱스가 낮은 key가 먼저 온다</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span>
<span class="p">}</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">key</span> <span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">sortedKeys</span><span class="p">)</span>

<span class="c1">// 우선순위 기반 정렬 2</span>
<span class="k">let</span> <span class="nv">dic</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">1</span><span class="p">]</span> <span class="c1">// num: count</span>
<span class="k">let</span> <span class="nv">order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
 
<span class="c1">// [2: 0, 3: 1, 1: 2, 4: 3] = num: idx(Order)</span>
<span class="c1">// 우선순위 인덱스를 미리 딕셔너리로 만들어 둔다 (O(1) 접근)</span>
<span class="k">let</span> <span class="nv">priority</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span> <span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Dictionary</span><span class="p">(</span><span class="nv">uniqueKeysWithValues</span><span class="p">:</span> <span class="n">order</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$1</span><span class="p">,</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>

<span class="k">let</span> <span class="nv">sortedKeys</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">priority</span><span class="p">[</span><span class="nv">$0</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">!</span> <span class="o">&lt;</span> <span class="n">priority</span><span class="p">[</span><span class="nv">$1</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">!</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span>
<span class="p">}</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">key</span> <span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="n">sortedKeys</span><span class="p">)</span>

</code></pre></div></div>

<p>처음 접근 방법<br />
딕셔너리의 키를 숫자로 두고 value로 카운팅을 한다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span><span class="o">!.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">Int</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span><span class="o">!</span> <span class="p">}</span> <span class="c1">// [1, 1, 1, 2, 2, 2]</span>
<span class="k">var</span> <span class="nv">dic</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>

<span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
    <span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>       <span class="c1">// [2: 3, 1: 2]</span>

<span class="c1">// value가 많은순으로 키룰 정렬하는 방법</span>
<span class="k">let</span> <span class="nv">sortedKeys</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span>
<span class="p">}</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">key</span> <span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">sortedKeys</span><span class="p">)</span>  <span class="c1">// [2, 1]</span>

<span class="k">var</span> <span class="nv">output</span> <span class="o">=</span> <span class="s">""</span>
<span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">sortedKeys</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">num</span><span class="se">)</span><span class="s"> "</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="c1">// 2 2 2 1 1</span>
</code></pre></div></div>

<p>이러면 1번 예제는 해결이 되지만 만약 동일한 등장횟수면 해당 순서를 보장해줘야 한다.</p>

<h2 id="제출-1">제출 1</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
5 2
2 1 2 1 2
 */</span>
<span class="n">_</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span><span class="o">!.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">Int</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span><span class="o">!</span> <span class="p">}</span>

<span class="c1">// ── 1) 빈도 계산 / 순서 계산 ─────────────────────────────────────</span>
<span class="k">var</span> <span class="nv">dic</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>    <span class="c1">// 숫자:개수</span>
<span class="k">var</span> <span class="nv">order</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>  <span class="c1">// 숫자:우선순위</span>
<span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">in</span> <span class="n">numbers</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="n">order</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span> <span class="c1">// num이 처음 등장한 idx 기록</span>
    <span class="p">}</span>
    <span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1">// [num:value]</span>
<span class="p">}</span>

<span class="c1">// ── 2) 빈도순으로 key 한번씩만 내보내기 ─────────────────────────────────────</span>
<span class="k">let</span> <span class="nv">keysByFreq</span> <span class="o">=</span> <span class="n">dic</span>
    <span class="o">.</span><span class="n">sorted</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span> <span class="p">{</span>
            <span class="c1">// 먼저 나온 key가 앞으로 오도록 정렬</span>
            <span class="k">return</span> <span class="n">order</span><span class="p">[</span><span class="nv">$0</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">!</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">[</span><span class="nv">$1</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">!</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span> <span class="c1">// 내림차순</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">key</span> <span class="p">}</span>                   <span class="c1">// key만 추출</span>

<span class="c1">// ── 3) 빈도순으로 key를 빈도만큼 반복 출력 ─────────────────────────────────────</span>
<span class="k">var</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
<span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">keysByFreq</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">num</span><span class="se">)</span><span class="s"> "</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

</code></pre></div></div>

<h2 id="제출-2">제출 2</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
5 2
2 1 2 1 2

딕셔너리 dic은 다음과 같이 구성
[숫자: (등장 순서, 등장 횟수)]

[예시]
[
  2: (0, 3), // 0번째에 처음 등장, 3번 나옴
  1: (1, 2), // 1번째에 처음 등장, 2번 나옴
]

*/</span>
<span class="n">_</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">dic</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]()</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span><span class="o">!.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">Int</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span><span class="o">!</span> <span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">in</span> <span class="n">numbers</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 숫자 처음 등장시</span>
    <span class="k">if</span> <span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 등장순서, 1번 등장</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">!.</span><span class="mi">1</span> <span class="o">+=</span> <span class="mi">1</span>   <span class="c1">// 이미 등장한 숫자라면 횟수만 추가</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 등장 횟수가 많은 숫자가 먼저 오도록, 같으면 등장순서가 빠른 순으로</span>
<span class="k">let</span> <span class="nv">sorted</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="nv">firstIdx</span><span class="p">,</span> <span class="nv">firstCnt</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span>
    <span class="k">let</span> <span class="p">(</span><span class="nv">secondIdx</span><span class="p">,</span> <span class="nv">secondCnt</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$1</span><span class="o">.</span><span class="n">value</span>
    
    <span class="k">if</span> <span class="n">firstCnt</span> <span class="o">!=</span> <span class="n">secondCnt</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">firstCnt</span> <span class="o">&gt;</span> <span class="n">secondCnt</span> <span class="c1">// 등장 횟수 많은 순</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">firstIdx</span> <span class="o">&lt;</span> <span class="n">secondIdx</span> <span class="c1">// 먼저 등장한 숫자 먼저</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 출력 1</span>
<span class="nf">print</span><span class="p">(</span><span class="n">sorted</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="nv">$0</span><span class="o">.</span><span class="n">key</span><span class="se">)</span><span class="s"> "</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span><span class="o">.</span><span class="nf">joined</span><span class="p">())</span>

<span class="c1">// 출력 2</span>
<span class="k">var</span> <span class="nv">output</span> <span class="o">=</span> <span class="s">""</span>
<span class="k">for</span> <span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span> <span class="k">in</span> <span class="n">sorted</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">number</span><span class="se">)</span><span class="s"> "</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="Baekjoon" /><summary type="html"><![CDATA[문제 빈도 정렬 자주 등장하는 숫자 기준으로 오름차순 정렬하되, 등장횟수가 같다면 먼저 나온 것이 앞에 있어야 한다. 풀이 정렬 관련 함수 // 배열 var numbers = [5, 2, 8, 1, 3] // 오름차순 정렬 let ascending = numbers.sorted() print("오름차순:", ascending) // [1, 2, 3, 5, 8] // 내림차순 정렬 let descending = numbers.sorted(by: &gt;) print("내림차순:", descending) // [8, 5, 3, 2, 1] // 딕셔너리 let scores = ["Alice": 88, "Bob": 95, "Charlie": 72] // 🔹 value 기준 오름차순 정렬 let byScoreAsc = scores.sorted { $0.value &lt; $1.value } print("점수 오름차순:", byScoreAsc) // 🔹 value 기준 내림차순 정렬 let byScoreDesc = scores.sorted { $0.value &gt; $1.value } print("점수 내림차순:", byScoreDesc) // 🔹 key 기준 오름차순 정렬 let byNameAsc = scores.sorted { $0.key &lt; $1.key } print("이름 오름차순:", byNameAsc) // 우선순위 기반 정렬 1 let dic = [1: 2, 2: 5, 3: 5, 4: 1] let order = [2, 3, 1, 4] // 우선순위: 2 &gt; 3 &gt; 1 &gt; 4 let sortedKeys = dic.sorted { if $0.value == $1.value { // O(n) return order.firstIndex(of: $0.key)! &lt; order.firstIndex(of: $1.key)! // &lt;: 인덱스가 낮은 key가 먼저 온다 } return $0.value &gt; $1.value }.map { $0.key } print(sortedKeys) // 우선순위 기반 정렬 2 let dic = [1: 2, 2: 5, 3: 5, 4: 1] // num: count let order = [2, 3, 1, 4] // [2: 0, 3: 1, 1: 2, 4: 3] = num: idx(Order) // 우선순위 인덱스를 미리 딕셔너리로 만들어 둔다 (O(1) 접근) let priority: [Int: Int] = Dictionary(uniqueKeysWithValues: order.enumerated().map { ($1, $0) }) let sortedKeys = dic.sorted { if $0.value == $1.value { return priority[$0.key]! &lt; priority[$1.key]! } return $0.value &gt; $1.value }.map { $0.key } print(sortedKeys) 처음 접근 방법 딕셔너리의 키를 숫자로 두고 value로 카운팅을 한다. _ = readLine() let numbers = readLine()!.split(separator: " ").map { Int($0)! } // [1, 1, 1, 2, 2, 2] var dic: [Int:Int] = [:] for num in numbers { dic[num, default: 0] += 1 } print(dic) // [2: 3, 1: 2] // value가 많은순으로 키룰 정렬하는 방법 let sortedKeys = dic.sorted { return $0.value &gt; $1.value }.map { $0.key } print(sortedKeys) // [2, 1] var output = "" for num in sortedKeys { output += String(repeating: "\(num) ", count: dic[num]!) } print(output) // 2 2 2 1 1 이러면 1번 예제는 해결이 되지만 만약 동일한 등장횟수면 해당 순서를 보장해줘야 한다. 제출 1 /* 5 2 2 1 2 1 2 */ _ = readLine() let numbers = readLine()!.split(separator: " ").map { Int($0)! } // ── 1) 빈도 계산 / 순서 계산 ───────────────────────────────────── var dic: [Int:Int] = [:] // 숫자:개수 var order: [Int:Int] = [:] // 숫자:우선순위 for (idx, num) in numbers.enumerated() { if dic[num] == nil { order[num] = idx // num이 처음 등장한 idx 기록 } dic[num, default: 0] += 1 // [num:value] } // ── 2) 빈도순으로 key 한번씩만 내보내기 ───────────────────────────────────── let keysByFreq = dic .sorted { if $0.value == $1.value { // 먼저 나온 key가 앞으로 오도록 정렬 return order[$0.key]! &lt; order[$1.key]! } else { return $0.value &gt; $1.value // 내림차순 } } .map { $0.key } // key만 추출 // ── 3) 빈도순으로 key를 빈도만큼 반복 출력 ───────────────────────────────────── var output: String = "" for num in keysByFreq { output += String(repeating: "\(num) ", count: dic[num]!) } print(output) 제출 2 /* 5 2 2 1 2 1 2 딕셔너리 dic은 다음과 같이 구성 [숫자: (등장 순서, 등장 횟수)] [예시] [ 2: (0, 3), // 0번째에 처음 등장, 3번 나옴 1: (1, 2), // 1번째에 처음 등장, 2번 나옴 ] */ _ = readLine() var dic = [Int: (Int, Int)]() let numbers = readLine()!.split(separator: " ").map { Int($0)! } for (idx, num) in numbers.enumerated() { // 숫자 처음 등장시 if dic[num] == nil { dic[num] = (idx, 1) // 등장순서, 1번 등장 } else { dic[num]!.1 += 1 // 이미 등장한 숫자라면 횟수만 추가 } } // 등장 횟수가 많은 숫자가 먼저 오도록, 같으면 등장순서가 빠른 순으로 let sorted = dic.sorted { let (firstIdx, firstCnt) = $0.value let (secondIdx, secondCnt) = $1.value if firstCnt != secondCnt { return firstCnt &gt; secondCnt // 등장 횟수 많은 순 } else { return firstIdx &lt; secondIdx // 먼저 등장한 숫자 먼저 } } // 출력 1 print(sorted.map { String(repeating: "\($0.key) ", count: $0.value.1) }.joined()) // 출력 2 var output = "" for (number, (_, cnt)) in sorted { output += String(repeating: "\(number) ", count: cnt) } print(output)]]></summary></entry><entry><title type="html">[Baekjoon] 백준 1992 쿼드트리</title><link href="http://localhost:4000/Baekjoon-1992/" rel="alternate" type="text/html" title="[Baekjoon] 백준 1992 쿼드트리" /><published>2025-05-21T00:00:00+00:00</published><updated>2025-05-21T00:00:00+00:00</updated><id>http://localhost:4000/%5BBaekjoon%5D-1992</id><content type="html" xml:base="http://localhost:4000/Baekjoon-1992/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->
<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="문제">문제</h2>
<p><a href="https://www.acmicpc.net/problem/1992">쿼드트리</a></p>

<p><img src="/assets/img/2025-05-21-%5BBaekjoon%5D-1992/image-20250521124353945.png" alt="이미지" width="100%" /><br />
주어진 영상이 0으로만 이루어져 있다면 결과는 0이 되고 혹은 그 반대면 결과가 1이 된다.  <br />
만약 0과 1이 섞여 있으면 전체를 한번에 나타내지 못하고 4개의 영역으로 나누어 각 영역을 압축한 결과를 차례로 괄호 안에서 묶어서 표현한다.</p>

<h2 id="풀이">풀이</h2>
<p>분할 정복 알고리즘을 사용하여 해결할 수 있다.  <br />
분할 정복은 재귀적으로 큰 문제를 하위 문제로 쪼개어 하위 문제를 해결하고 모아서 상위 문제를 해결하는 방식이다.  <br />
2차원 배열을 같은 숫자로 구성된 4등분 단위로 압축 및 재귀적으로 처리하여 괄호로 묶는다. Stack으로도 구현 가능하다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
┌───┬───┐
│ 1 │ 2 │
├───┼───┤
│ 3 │ 4 │
└───┴───┘
*/</span>
<span class="k">let</span> <span class="nv">n</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="nf">readLine</span><span class="p">()</span><span class="o">!</span><span class="p">)</span><span class="o">!</span>
<span class="k">var</span> <span class="nv">graph</span><span class="p">:</span> <span class="p">[[</span><span class="kt">String</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">n</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">row</span> <span class="o">=</span> <span class="nf">readLine</span><span class="p">()</span><span class="o">!.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">graph</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 분할정복 함수 - (y, x) 위치에서 size 크기의 정사각형 영역 처리</span>
<span class="kd">func</span> <span class="nf">go</span><span class="p">(</span><span class="n">_</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">base</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">ret</span> <span class="o">=</span> <span class="s">""</span>

    <span class="k">for</span> <span class="n">row</span> <span class="k">in</span> <span class="n">y</span><span class="o">..&lt;</span><span class="n">y</span><span class="o">+</span><span class="n">size</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">col</span> <span class="k">in</span> <span class="n">x</span><span class="o">..&lt;</span><span class="n">x</span><span class="o">+</span><span class="n">size</span> <span class="p">{</span>
            <span class="c1">// 입력 조건이 2^k 이므로 0이하로 들어올 가능성이 없기 때문에 기저 사례 필요 x</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="k">return</span> <span class="n">graph</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="p">}</span>

            <span class="c1">// 하나라도 값이 다르다면 4분할하여 재귀적으로 검사</span>
            <span class="k">if</span> <span class="n">base</span> <span class="o">!=</span> <span class="n">graph</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">"("</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="nf">go</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="nf">go</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">size</span><span class="sr">/2, size/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="nf">go</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">size</span><span class="sr">/2, x, size/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="nf">go</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">size</span><span class="sr">/2, x+size/2, size/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">")"</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 모두 같은 값이면 해당 값 반환</span>
    <span class="k">return</span> <span class="n">base</span>
<span class="p">}</span>

<span class="c1">// (0, 0)부터 분할정복 시작</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">go</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="Baekjoon" /><summary type="html"><![CDATA[문제 쿼드트리 주어진 영상이 0으로만 이루어져 있다면 결과는 0이 되고 혹은 그 반대면 결과가 1이 된다. 만약 0과 1이 섞여 있으면 전체를 한번에 나타내지 못하고 4개의 영역으로 나누어 각 영역을 압축한 결과를 차례로 괄호 안에서 묶어서 표현한다. 풀이 분할 정복 알고리즘을 사용하여 해결할 수 있다. 분할 정복은 재귀적으로 큰 문제를 하위 문제로 쪼개어 하위 문제를 해결하고 모아서 상위 문제를 해결하는 방식이다. 2차원 배열을 같은 숫자로 구성된 4등분 단위로 압축 및 재귀적으로 처리하여 괄호로 묶는다. Stack으로도 구현 가능하다. /* ┌───┬───┐ │ 1 │ 2 │ ├───┼───┤ │ 3 │ 4 │ └───┴───┘ */ let n = Int(readLine()!)! var graph: [[String]] = [] for _ in 0..&lt;n { let row = readLine()!.map { String($0) } graph.append(row) } // 분할정복 함수 - (y, x) 위치에서 size 크기의 정사각형 영역 처리 func go(_ y: Int, _ x: Int, _ size: Int) -&gt; String { let base = graph[y][x] var ret = "" for row in y..&lt;y+size { for col in x..&lt;x+size { // 입력 조건이 2^k 이므로 0이하로 들어올 가능성이 없기 때문에 기저 사례 필요 x if size == 1 { return graph[y][x] } // 하나라도 값이 다르다면 4분할하여 재귀적으로 검사 if base != graph[row][col] { ret += "(" ret += go(y, x, size/2) ret += go(y, x+size/2, size/2) ret += go(y+size/2, x, size/2) ret += go(y+size/2, x+size/2, size/2) ret += ")" return ret } } } // 모두 같은 값이면 해당 값 반환 return base } // (0, 0)부터 분할정복 시작 print(go(0, 0, n))]]></summary></entry><entry><title type="html">[Docker] code-server</title><link href="http://localhost:4000/Docker-code-server/" rel="alternate" type="text/html" title="[Docker] code-server" /><published>2025-05-19T00:00:00+00:00</published><updated>2025-05-19T00:00:00+00:00</updated><id>http://localhost:4000/%5BDocker%5D-code-server</id><content type="html" xml:base="http://localhost:4000/Docker-code-server/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Dockerfile</span>

FROM ubuntu:latest

<span class="c"># ----- 기본 패키지 설치 -----</span>
RUN apt-get update <span class="o">&amp;&amp;</span> <span class="se">\</span>
    apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\</span>
        curl <span class="nb">sudo </span>python3 python3-pip default-jdk <span class="se">\</span>
        git wget nano locales <span class="se">\</span>
        libpython3.10 libicu-dev libxml2-dev clang <span class="se">\</span>
        unzip gnupg2 libcurl4-openssl-dev pkg-config <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get clean

<span class="c"># ----- 로케일 설정 -----</span>
RUN locale-gen en_US.UTF-8
ENV <span class="nv">LANG</span><span class="o">=</span>en_US.UTF-8
ENV <span class="nv">LANGUAGE</span><span class="o">=</span>en_US:en
ENV <span class="nv">LC_ALL</span><span class="o">=</span>en_US.UTF-8

<span class="c"># ----- ARG로 외부에서 변수 받기 -----</span>
ARG USER
ARG PASSWORD

<span class="c"># ----- 사용자 생성 및 sudo 권한 부여 -----</span>
RUN useradd <span class="nt">-m</span> <span class="k">${</span><span class="nv">USER</span><span class="k">}</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">USER</span><span class="k">}</span><span class="s2">:</span><span class="k">${</span><span class="nv">PASSWORD</span><span class="k">}</span><span class="s2">"</span> | chpasswd <span class="o">&amp;&amp;</span> adduser <span class="k">${</span><span class="nv">USER</span><span class="k">}</span> <span class="nb">sudo</span>

<span class="c"># ----- code-server 설치 및 작업 디렉토리 생성 -----</span>
ENV <span class="nv">WORKINGDIR</span><span class="o">=</span><span class="s2">"/home/</span><span class="k">${</span><span class="nv">USER</span><span class="k">}</span><span class="s2">/vscode"</span>
RUN curl <span class="nt">-fsSL</span> https://code-server.dev/install.sh | sh <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="k">${</span><span class="nv">WORKINGDIR</span><span class="k">}</span> <span class="o">&amp;&amp;</span> <span class="nb">chown</span> <span class="nt">-R</span> <span class="k">${</span><span class="nv">USER</span><span class="k">}</span>:<span class="k">${</span><span class="nv">USER</span><span class="k">}</span> <span class="k">${</span><span class="nv">WORKINGDIR</span><span class="k">}</span>

<span class="c"># ----- 컨테이너 환경변수로도 유지 -----</span>
ENV <span class="nv">PASSWORD</span><span class="o">=</span><span class="k">${</span><span class="nv">PASSWORD</span><span class="k">}</span>
ENV <span class="nv">USER</span><span class="o">=</span><span class="k">${</span><span class="nv">USER</span><span class="k">}</span>

<span class="c"># ----- 사용자 전환 -----</span>
USER <span class="k">${</span><span class="nv">USER</span><span class="k">}</span>
WORKDIR <span class="k">${</span><span class="nv">WORKINGDIR</span><span class="k">}</span>

<span class="c"># ----- VSCode 확장 설치 -----</span>
RUN code-server <span class="nt">--install-extension</span> ms-python.python <span class="o">&amp;&amp;</span> <span class="se">\</span>
    code-server <span class="nt">--install-extension</span> ms-azuretools.vscode-docker <span class="o">&amp;&amp;</span> <span class="se">\</span>
    code-server <span class="nt">--install-extension</span> formulahendry.code-runner

<span class="c"># ----- 포트 오픈 -----</span>
EXPOSE 8080

<span class="c"># ----- code-server 실행 -----</span>
CMD <span class="o">[</span><span class="s2">"code-server"</span>, <span class="s2">"--bind-addr"</span>, <span class="s2">"0.0.0.0:8080"</span>, <span class="s2">"--auth"</span>, <span class="s2">"password"</span>, <span class="s2">"."</span><span class="o">]</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 터미널로 진입</span>
docker <span class="nb">exec</span> <span class="nt">-it</span> vscode-container bash

<span class="c"># 이동</span>
<span class="nb">cd</span> /home/ec2-user/.local/share/code-server/User

nano settings.json

<span class="o">{</span>
  <span class="s2">"code-runner.executorMap"</span>: <span class="o">{</span>
    <span class="s2">"python"</span>: <span class="s2">"python3 -u"</span>,
    <span class="s2">"swift"</span>: <span class="s2">"/home/ec2-user/.local/share/swiftly/bin/swift"</span>
  <span class="o">}</span>,
  <span class="s2">"code-runner.showExecutionMessage"</span>: <span class="nb">false</span>,
  <span class="s2">"code-runner.clearPreviousOutput"</span>: <span class="nb">true</span>
<span class="o">}</span>

<span class="c"># 저장</span>
ctrl + o
enter
ctrl x

<span class="c"># 나가고 재빌드</span>
<span class="nb">exit
</span>docker compose up <span class="nt">-d</span> <span class="nt">--build</span>
</code></pre></div></div>

<h1 id="swift-추가">swift 추가</h1>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 터미널로 진입</span>
docker <span class="nb">exec</span> <span class="nt">-it</span> vscode-container bash
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. 기존 swiftly 완전 삭제</span>
<span class="nb">rm</span> <span class="nt">-rf</span> ~/.local/share/swiftly
<span class="nb">rm</span> <span class="nt">-f</span> ~/swiftly

<span class="c"># 2. 필수 패키지 설치</span>
<span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> clang libicu-dev wget libpython3-dev

<span class="c"># 3. 최신 swiftly 설치</span>
curl <span class="nt">-O</span> <span class="s2">"https://download.swift.org/swiftly/linux/swiftly-</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-m</span><span class="si">)</span><span class="s2">.tar.gz"</span>
<span class="nb">tar </span>zxf <span class="s2">"swiftly-</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-m</span><span class="si">)</span><span class="s2">.tar.gz"</span>
<span class="nb">chmod</span> +x swiftly
./swiftly init <span class="nt">--quiet-shell-followup</span> <span class="nt">--assume-yes</span>

<span class="c"># 4. 환경 변수 적용</span>
<span class="nb">source</span> ~/.local/share/swiftly/env.sh
<span class="nb">echo</span> <span class="s1">'source ~/.local/share/swiftly/env.sh'</span> <span class="o">&gt;&gt;</span> ~/.bashrc

<span class="c"># 5. Swift 6.1.0 설치 (실제 toolchain 다운로드)</span>
~/.local/share/swiftly/bin/swiftly <span class="nb">install </span>6.1.0 <span class="nt">--assume-yes</span> <span class="nt">--verify</span>

<span class="c"># 6. swift 실행 확인</span>
find ~/.local/share/swiftly/toolchains <span class="nt">-name</span> swift <span class="nt">-type</span> f <span class="nt">-executable</span>
swift <span class="nt">--version</span>
</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="UIComponent" /><summary type="html"><![CDATA[# Dockerfile FROM ubuntu:latest # ----- 기본 패키지 설치 ----- RUN apt-get update &amp;&amp; \ apt-get install -y \ curl sudo python3 python3-pip default-jdk \ git wget nano locales \ libpython3.10 libicu-dev libxml2-dev clang \ unzip gnupg2 libcurl4-openssl-dev pkg-config \ &amp;&amp; apt-get clean # ----- 로케일 설정 ----- RUN locale-gen en_US.UTF-8 ENV LANG=en_US.UTF-8 ENV LANGUAGE=en_US:en ENV LC_ALL=en_US.UTF-8 # ----- ARG로 외부에서 변수 받기 ----- ARG USER ARG PASSWORD # ----- 사용자 생성 및 sudo 권한 부여 ----- RUN useradd -m ${USER} &amp;&amp; echo "${USER}:${PASSWORD}" | chpasswd &amp;&amp; adduser ${USER} sudo # ----- code-server 설치 및 작업 디렉토리 생성 ----- ENV WORKINGDIR="/home/${USER}/vscode" RUN curl -fsSL https://code-server.dev/install.sh | sh &amp;&amp; \ mkdir -p ${WORKINGDIR} &amp;&amp; chown -R ${USER}:${USER} ${WORKINGDIR} # ----- 컨테이너 환경변수로도 유지 ----- ENV PASSWORD=${PASSWORD} ENV USER=${USER} # ----- 사용자 전환 ----- USER ${USER} WORKDIR ${WORKINGDIR} # ----- VSCode 확장 설치 ----- RUN code-server --install-extension ms-python.python &amp;&amp; \ code-server --install-extension ms-azuretools.vscode-docker &amp;&amp; \ code-server --install-extension formulahendry.code-runner # ----- 포트 오픈 ----- EXPOSE 8080 # ----- code-server 실행 ----- CMD ["code-server", "--bind-addr", "0.0.0.0:8080", "--auth", "password", "."] # 컨테이너 터미널로 진입 docker exec -it vscode-container bash # 이동 cd /home/ec2-user/.local/share/code-server/User nano settings.json { "code-runner.executorMap": { "python": "python3 -u", "swift": "/home/ec2-user/.local/share/swiftly/bin/swift" }, "code-runner.showExecutionMessage": false, "code-runner.clearPreviousOutput": true } # 저장 ctrl + o enter ctrl x # 나가고 재빌드 exit docker compose up -d --build swift 추가 # 컨테이너 터미널로 진입 docker exec -it vscode-container bash # 1. 기존 swiftly 완전 삭제 rm -rf ~/.local/share/swiftly rm -f ~/swiftly # 2. 필수 패키지 설치 sudo apt-get update sudo apt-get install -y clang libicu-dev wget libpython3-dev # 3. 최신 swiftly 설치 curl -O "https://download.swift.org/swiftly/linux/swiftly-$(uname -m).tar.gz" tar zxf "swiftly-$(uname -m).tar.gz" chmod +x swiftly ./swiftly init --quiet-shell-followup --assume-yes # 4. 환경 변수 적용 source ~/.local/share/swiftly/env.sh echo 'source ~/.local/share/swiftly/env.sh' &gt;&gt; ~/.bashrc # 5. Swift 6.1.0 설치 (실제 toolchain 다운로드) ~/.local/share/swiftly/bin/swiftly install 6.1.0 --assume-yes --verify # 6. swift 실행 확인 find ~/.local/share/swiftly/toolchains -name swift -type f -executable swift --version]]></summary></entry><entry><title type="html">[TableView] 13. RxTableView</title><link href="http://localhost:4000/UIKit-tableView13/" rel="alternate" type="text/html" title="[TableView] 13. RxTableView" /><published>2025-05-18T00:00:00+00:00</published><updated>2025-05-18T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-tableView13</id><content type="html" xml:base="http://localhost:4000/UIKit-tableView13/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="TableView" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[TableView] UITextView vs UITextField</title><link href="http://localhost:4000/UIKit-UItextField-UITextView/" rel="alternate" type="text/html" title="[TableView] UITextView vs UITextField" /><published>2025-05-18T00:00:00+00:00</published><updated>2025-05-18T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-UItextField-UITextView</id><content type="html" xml:base="http://localhost:4000/UIKit-UItextField-UITextView/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="uitextview-uitextfield--차이">UITextView UITextField  차이</h2>
<p>TextField는 placeholder를 사용할 수 있으나 TextView는 안되는것을 알게 되어 두 컴포넌트의 차이에 대해 알아보고자 정리하게 되었다.</p>

<h1 id="uitextview">UITextView</h1>
<p><a href="https://developer.apple.com/documentation/uikit/uitextview/">공식문서</a>를 살펴보면</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A scrollable, multiline text region
</code></pre></div></div>
<p><strong>1줄 이상으로 이루어진 스크롤 가능한 텍스트 영역</strong>  <br />
placeholder는 제공하지 않기 때문에 직접 구현해야 한다.</p>

<h2 id="placeholder-구현-방법">placeholder 구현 방법</h2>
<p>UITextView는 UITextViewDeleagate 프로토콜을 채택하고 있다. <br />
그 중 textViewDidBeginEditing method를 사용해서 구현해보자.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// init 시 상태를 lazy로 지정</span>
<span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">textView</span><span class="p">:</span> <span class="kt">UITextView</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">tv</span> <span class="o">=</span> <span class="kt">UITextView</span><span class="p">()</span>
    <span class="n">tv</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"입력하세요.."</span>
    <span class="n">tv</span><span class="o">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">secondaryLabel</span>
    <span class="n">tv</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
    <span class="k">return</span> <span class="n">textView</span>
<span class="p">}()</span>
</code></pre></div></div>
<p>init 시 상태를 lazy로 지정해주면서 layout 세팅을 진행하였다.</p>

<h2 id="textviewdidbeginediting">textViewDidBeginEditing</h2>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tells the delegate when editing of the specified text view begins.
</code></pre></div></div>
<p><strong>Optional 설정으로 textView의 수정이 일어나면 실행되는 메서드</strong></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">UploadViewController</span><span class="p">:</span> <span class="kt">UITextViewDelegate</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">textViewDidBeginEditing</span><span class="p">(</span><span class="n">_</span> <span class="nv">textView</span><span class="p">:</span> <span class="kt">UITextView</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">textView</span><span class="o">.</span><span class="n">textColor</span> <span class="o">==</span> <span class="o">.</span><span class="n">secondaryLabel</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="n">textView</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="kc">nil</span>
        <span class="n">textView</span><span class="o">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">label</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>textColor가 .secondaryLabel라는 기본값으로 세팅되어 있으면 return 시키고, 아니라면 text를 비우고 Color도 검정색으로 바꾸어준다.</p>

<h1 id="uitextfield">UITextField</h1>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="UIComponent" /><summary type="html"><![CDATA[UITextView UITextField 차이 TextField는 placeholder를 사용할 수 있으나 TextView는 안되는것을 알게 되어 두 컴포넌트의 차이에 대해 알아보고자 정리하게 되었다. UITextView 공식문서를 살펴보면 A scrollable, multiline text region 1줄 이상으로 이루어진 스크롤 가능한 텍스트 영역 placeholder는 제공하지 않기 때문에 직접 구현해야 한다. placeholder 구현 방법 UITextView는 UITextViewDeleagate 프로토콜을 채택하고 있다. 그 중 textViewDidBeginEditing method를 사용해서 구현해보자. // init 시 상태를 lazy로 지정 private lazy var textView: UITextView = { let tv = UITextView() tv.text = "입력하세요.." tv.textColor = .secondaryLabel tv.delegate = self return textView }() init 시 상태를 lazy로 지정해주면서 layout 세팅을 진행하였다. textViewDidBeginEditing Tells the delegate when editing of the specified text view begins. Optional 설정으로 textView의 수정이 일어나면 실행되는 메서드 extension UploadViewController: UITextViewDelegate { func textViewDidBeginEditing(_ textView: UITextView) { guard textView.textColor == .secondaryLabel else { return } textView.text = nil textView.textColor = .label } } textColor가 .secondaryLabel라는 기본값으로 세팅되어 있으면 return 시키고, 아니라면 text를 비우고 Color도 검정색으로 바꾸어준다. UITextField]]></summary></entry><entry><title type="html">[TableView] 12. 테이블뷰 제네릭 CustomCombineDataSource</title><link href="http://localhost:4000/UIKit-tableView12/" rel="alternate" type="text/html" title="[TableView] 12. 테이블뷰 제네릭 CustomCombineDataSource" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-tableView12</id><content type="html" xml:base="http://localhost:4000/UIKit-tableView12/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="테이블뷰-제네릭-customcombinedatasource">테이블뷰 제네릭 CustomCombineDataSource</h2>
<p>이전 포스팅에서 tableview데이터소스를 combine과 제네릭으로 연결을 했다. <br />
데이터소스는 데이터와 연괸되어있고, 셀의 종류를 정하고, 리스트 개수가 몇개인지 정하는 역할이다 즉 데이터와 관련이 있다.</p>

<p>이전 포스팅에서 커스텀 DataSource를 만들어서 처리하였는데 문제가 있었다. 리스트를 보여줄 때 데이터 타입이 변경되면 받을 수 없고 DummyData타입만 받을 수 있었다. 어떠한 데이터가 오더라도 확장성이 있도록 호출하는 쪽에서 셀의 타입을 정하도록 구현해보자.</p>

<h3 id="customcombinedatasourceswift">CustomCombineDataSource.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">//</span>
 <span class="c1">//  CustomCombineDataSource.swift</span>
 <span class="c1">//  UITableViewTutorial</span>
 <span class="c1">//</span>
 <span class="c1">//  Created by 김동현 on 5/15/25.</span>
 <span class="c1">//</span>
 <span class="c1">// https://www.youtube.com/watch?v=vlJ392OMkoI&amp;list=PLgOlaPUIbynpuq9GKCwAedgWkkPm2Wo8v&amp;index=16</span>
 
 <span class="kd">import</span> <span class="kt">UIKit</span>
 
 <span class="cm">/*
 class CustomCombineDataSource&lt;T, G&gt;: NSObject, UITableViewDataSource {
     
     // 멤버 변수
     var dataList: [T] = []
     
     var testDataList: [G] = []
 */</span>
 
 <span class="kd">class</span> <span class="kt">CustomCombineDataSource</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span> <span class="p">{</span>
     
     <span class="c1">// 셀을 만드는 클로저</span>
     <span class="c1">// 1. let makeCell: (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell</span>
     <span class="c1">// 2. let makeCell: (UITableView, IndexPath, Item) -&gt; UITableViewCell // 위랑 같음</span>
     <span class="c1">// 3.</span>
     <span class="k">var</span> <span class="nv">makeCell</span><span class="p">:</span> <span class="p">((</span><span class="kt">UITableView</span><span class="p">,</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="kt">Item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span> <span class="c1">// 옵셔널로도 가능</span>
     
     <span class="k">var</span> <span class="nv">dataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Item</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
     
     <span class="c1">// 2. 안쪽에서 터트리기 때문에 escaping 해주자</span>
     <span class="cm">/*
     init(makeCell: @escaping (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell) {
         self.makeCell = makeCell
         super.init()
     }
      */</span>
     
     <span class="c1">// 3. 옵셔널로 한다면 escaping 안해도 된다</span>
     <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">makeCell</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">_</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="n">_</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">Item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">self</span><span class="o">.</span><span class="n">makeCell</span> <span class="o">=</span> <span class="n">makeCell</span>
         <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점</span>
 
     <span class="c1">/// 변경된 데이터를 받아서 테이블뷰에 적용한다</span>
     <span class="c1">/// - Parameters:</span>
     <span class="c1">///   - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수</span>
     <span class="c1">///   - tableView: 리로드 대상 테이블뷰</span>
     <span class="kd">func</span> <span class="nf">pushDataList</span><span class="p">(</span><span class="n">_</span> <span class="nv">updatedDataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">Item</span><span class="p">],</span> <span class="n">to</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">tableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="k">self</span>
         <span class="k">self</span><span class="o">.</span><span class="n">dataList</span> <span class="o">=</span> <span class="n">updatedDataList</span>
         <span class="n">tableView</span><span class="o">.</span><span class="nf">reloadData</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 </span>
     
     <span class="c1">/// 하나의 섹션에 몇개의 rows가 있냐</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
         <span class="k">return</span> <span class="n">dataList</span><span class="o">.</span><span class="n">count</span>
     <span class="p">}</span>
 
     <span class="c1">/// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라</span>
     <span class="c1">/// - indexPath: 셀의 위치를 나타내는 인덱스 경로</span>
     <span class="c1">/// - returns: 구성된 UITableViewCell 객체</span>
     <span class="c1">/// 어떤 셀을 보여줄지</span>
     <span class="c1">// 1. 테이블뷰</span>
     <span class="c1">// 2. indexPath 몇번째인지</span>
     <span class="c1">// 3. 셀에 대한 데이터 - 셀에 대한 제네릭 데이터</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
         
         <span class="c1">// 비어있으면 기본 UITableViewCell 반환</span>
         <span class="nf">makeCell</span><span class="p">?(</span><span class="n">tableView</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">dataList</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">])</span> <span class="p">??</span> <span class="kt">UITableViewCell</span><span class="p">()</span>
         
         <span class="c1">//        /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)</span>
         <span class="c1">//        /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell")</span>
         <span class="c1">//</span>
         <span class="c1">//        // [guard let] 방식</span>
         <span class="c1">//        guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {</span>
         <span class="c1">//            return UITableViewCell()</span>
         <span class="c1">//        }</span>
         <span class="c1">//</span>
         <span class="c1">//        if let dataList = dataList as? [DummyData] {</span>
         <span class="c1">//            let cellData: DummyData = dataList[indexPath.row]</span>
         <span class="c1">//</span>
         <span class="c1">//            /// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
         <span class="c1">//            cell.titleLabel.text = cellData.title</span>
         <span class="c1">//</span>
         <span class="c1">//            /// 셀의 서브 타이틀 설정</span>
         <span class="c1">//            cell.bodyLabel.text = cellData.body</span>
         <span class="c1">//</span>
         <span class="c1">//            cell.detailTextLabel?.numberOfLines = 0</span>
         <span class="c1">//        }</span>
         <span class="c1">//</span>
         <span class="c1">//        if let dataList = dataList as? [IndexData] {</span>
         <span class="c1">//            let cellData: IndexData = dataList[indexPath.row]</span>
         <span class="c1">//</span>
         <span class="c1">//            /// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
         <span class="c1">//            cell.titleLabel.text = cellData.title</span>
         <span class="c1">//</span>
         <span class="c1">//            /// 셀의 서브 타이틀 설정</span>
         <span class="c1">//            cell.bodyLabel.text = cellData.body</span>
         <span class="c1">//</span>
         <span class="c1">//            cell.detailTextLabel?.numberOfLines = 0</span>
         <span class="c1">//        }</span>
         <span class="c1">//</span>
         <span class="c1">//        return cell</span>
     <span class="p">}</span>
 <span class="p">}</span>
 
 
 
 
 
</code></pre></div></div>

<p>tableView()의 각 매개변수 tableView, indexPath, 그리고 셀에 대한 데이터 cellData을 조합을 하여 UITableViewCell 즉 셀을 만들자. 기존 tableView() 내부를 전부 주석처리를 하고 주석부분을 만드는 클로저를 두자. 함수 = 클로저 = 논리이다.  즉 논리 = 로직이다. 다시말해 로직을 클로저로 빼자.</p>

<h3 id="uitableviewcombineswift">UITableView+Combine.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  UITableView+Combine.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/15/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="c1">// MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자.</span>
<span class="c1">// public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable</span>
<span class="kd">extension</span> <span class="kt">UITableView</span> <span class="p">{</span>
    <span class="c1">// 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체</span>
    <span class="c1">// (Self.Output) -&gt; Void)</span>
    <span class="c1">// ([DummyData]) -&gt; Void</span>
    <span class="c1">// 데이터소스 바인딩    </span>
    <span class="kd">func</span> <span class="n">customItemsWithCell</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nv">makeCell</span><span class="p">:</span> <span class="p">((</span><span class="kt">UITableView</span><span class="p">,</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="kt">Item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">([</span><span class="kt">Item</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">dataSource</span> <span class="o">=</span> <span class="kt">CustomCombineDataSource</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">(</span><span class="n">makeCell</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span> <span class="p">(</span><span class="nv">updatedDateLisst</span><span class="p">:</span> <span class="p">[</span><span class="kt">Item</span><span class="p">])</span> <span class="k">in</span>
            <span class="n">dataSource</span><span class="o">.</span><span class="nf">pushDataList</span><span class="p">(</span><span class="n">updatedDateLisst</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <span class="c1">// 리로드</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="combinelistviewcontrollerswift">CombineListViewController.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  CombineListViewController.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/13/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">CombineListViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="c1">// Combine 메모리 처리를 위해 생성</span>
    <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="c1">// Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다.</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">dummies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">indexDatas</span><span class="p">:</span> <span class="p">[</span><span class="kt">IndexData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="o">!</span>

   
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="nf">configureTableView</span><span class="p">()</span>
        
        
        <span class="cm">/*
        - sink는 @Published가 수정된 스레드에서 실행된다
        - 그래서 Published변수 수정시 메인 스레드에서 수정해주자
        - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다
         */</span>
        
        <span class="c1">// MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다.</span>
        <span class="c1">// $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨</span>
        <span class="c1">// sink는 구독하는 것이다.</span>
        <span class="c1">// AnyCancellable 구독한다고 한다.</span>
        <span class="c1">// store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다.</span>
        <span class="cm">/*
         기존 방식
         $dummies
             .receive(on: DispatchQueue.main)
             // 데이터 변경시마다 동작
             .sink(receiveValue: { (changedDummies: [DummyData]) in
                 print("changedDummies: \(changedDummies.count)")
                 
                 // sink는 메인스레드에서 동작해서 Dispatch안해도된다
                 self.myTableView.reloadData()
             })
             .store(in: &amp;subscriptions)
         */</span>
        
        <span class="n">$dummies</span><span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">customItemsWithCell</span><span class="p">(</span>
                <span class="c1">// 셀에 대한 종류를 정해주기 위해 바깥으로 뺀 형태 -&gt; makeCell을 데이터 타입마다 다르게 정의할 수 있다</span>
                <span class="nv">makeCell</span><span class="p">:</span> <span class="p">{</span> <span class="n">myTableView</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">cellData</span> <span class="k">in</span>
                
                <span class="c1">// [guard let] 방식</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">myTableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">CodeCell</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()</span>
                <span class="p">}</span>
        
                <span class="n">cell</span><span class="o">.</span><span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">title</span>  <span class="c1">// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">bodyLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">body</span> <span class="c1">// 셀의 서브 타이틀 설정</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">detailTextLabel</span><span class="p">?</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="n">cell</span>
                
            <span class="p">}))</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        
        <span class="c1">// 2초 뒤에 더미데이터 10개 추가</span>
        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="nf">asyncAfter</span><span class="p">(</span><span class="nv">deadline</span><span class="p">:</span> <span class="o">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">execute</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="n">dummies</span> <span class="o">+=</span> <span class="kt">DummyData</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="c1">// self.indexDatas += IndexData.getDumies(10)</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="kd">fileprivate</span> <span class="kd">func</span> <span class="nf">configureTableView</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="c1">// CodeCell에서는 이 줄만 필요</span>
        <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">CodeCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span>
        <span class="c1">// self.myTableView.delegate = self</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="TableView" /><summary type="html"><![CDATA[테이블뷰 제네릭 CustomCombineDataSource 이전 포스팅에서 tableview데이터소스를 combine과 제네릭으로 연결을 했다. 데이터소스는 데이터와 연괸되어있고, 셀의 종류를 정하고, 리스트 개수가 몇개인지 정하는 역할이다 즉 데이터와 관련이 있다. 이전 포스팅에서 커스텀 DataSource를 만들어서 처리하였는데 문제가 있었다. 리스트를 보여줄 때 데이터 타입이 변경되면 받을 수 없고 DummyData타입만 받을 수 있었다. 어떠한 데이터가 오더라도 확장성이 있도록 호출하는 쪽에서 셀의 타입을 정하도록 구현해보자. CustomCombineDataSource.swift // // CustomCombineDataSource.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // // https://www.youtube.com/watch?v=vlJ392OMkoI&amp;list=PLgOlaPUIbynpuq9GKCwAedgWkkPm2Wo8v&amp;index=16 import UIKit /* class CustomCombineDataSource&lt;T, G&gt;: NSObject, UITableViewDataSource { // 멤버 변수 var dataList: [T] = [] var testDataList: [G] = [] */ class CustomCombineDataSource&lt;Item&gt;: NSObject, UITableViewDataSource { // 셀을 만드는 클로저 // 1. let makeCell: (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell // 2. let makeCell: (UITableView, IndexPath, Item) -&gt; UITableViewCell // 위랑 같음 // 3. var makeCell: ((UITableView, IndexPath, Item) -&gt; UITableViewCell)? = nil // 옵셔널로도 가능 var dataList: [Item] = [] // 2. 안쪽에서 터트리기 때문에 escaping 해주자 /* init(makeCell: @escaping (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell) { self.makeCell = makeCell super.init() } */ // 3. 옵셔널로 한다면 escaping 안해도 된다 init(_ makeCell: ((_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell)? = nil) { self.makeCell = makeCell super.init() } // MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점 /// 변경된 데이터를 받아서 테이블뷰에 적용한다 /// - Parameters: /// - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수 /// - tableView: 리로드 대상 테이블뷰 func pushDataList(_ updatedDataList: [Item], to tableView: UITableView) { tableView.dataSource = self self.dataList = updatedDataList tableView.reloadData() } // MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 /// 하나의 섹션에 몇개의 rows가 있냐 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return dataList.count } /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라 /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 /// - returns: 구성된 UITableViewCell 객체 /// 어떤 셀을 보여줄지 // 1. 테이블뷰 // 2. indexPath 몇번째인지 // 3. 셀에 대한 데이터 - 셀에 대한 제네릭 데이터 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { // 비어있으면 기본 UITableViewCell 반환 makeCell?(tableView, indexPath, dataList[indexPath.row]) ?? UITableViewCell() // /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함) // /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell") // // // [guard let] 방식 // guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else { // return UITableViewCell() // } // // if let dataList = dataList as? [DummyData] { // let cellData: DummyData = dataList[indexPath.row] // // /// 셀의 주 텍스트를 더미 데이터에서 가져오기 // cell.titleLabel.text = cellData.title // // /// 셀의 서브 타이틀 설정 // cell.bodyLabel.text = cellData.body // // cell.detailTextLabel?.numberOfLines = 0 // } // // if let dataList = dataList as? [IndexData] { // let cellData: IndexData = dataList[indexPath.row] // // /// 셀의 주 텍스트를 더미 데이터에서 가져오기 // cell.titleLabel.text = cellData.title // // /// 셀의 서브 타이틀 설정 // cell.bodyLabel.text = cellData.body // // cell.detailTextLabel?.numberOfLines = 0 // } // // return cell } } tableView()의 각 매개변수 tableView, indexPath, 그리고 셀에 대한 데이터 cellData을 조합을 하여 UITableViewCell 즉 셀을 만들자. 기존 tableView() 내부를 전부 주석처리를 하고 주석부분을 만드는 클로저를 두자. 함수 = 클로저 = 논리이다. 즉 논리 = 로직이다. 다시말해 로직을 클로저로 빼자. UITableView+Combine.swift // // UITableView+Combine.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // import UIKit import Combine // MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자. // public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable extension UITableView { // 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체 // (Self.Output) -&gt; Void) // ([DummyData]) -&gt; Void // 데이터소스 바인딩 func customItemsWithCell&lt;Item&gt;( makeCell: ((UITableView, IndexPath, Item) -&gt; UITableViewCell)? = nil ) -&gt; ([Item]) -&gt; Void { let dataSource = CustomCombineDataSource&lt;Item&gt;(makeCell) return { (updatedDateLisst: [Item]) in dataSource.pushDataList(updatedDateLisst, to: self) // 리로드 } } } CombineListViewController.swift // // CombineListViewController.swift // UITableViewTutorial // // Created by 김동현 on 5/13/25. // import UIKit import Combine class CombineListViewController: UIViewController { // Combine 메모리 처리를 위해 생성 var subscriptions = Set&lt;AnyCancellable&gt;() // Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다. @Published var dummies: [DummyData] = [] @Published var indexDatas: [IndexData] = [] @IBOutlet weak var myTableView: UITableView! override func viewDidLoad() { super.viewDidLoad() configureTableView() /* - sink는 @Published가 수정된 스레드에서 실행된다 - 그래서 Published변수 수정시 메인 스레드에서 수정해주자 - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다 */ // MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다. // $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨 // sink는 구독하는 것이다. // AnyCancellable 구독한다고 한다. // store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다. /* 기존 방식 $dummies .receive(on: DispatchQueue.main) // 데이터 변경시마다 동작 .sink(receiveValue: { (changedDummies: [DummyData]) in print("changedDummies: \(changedDummies.count)") // sink는 메인스레드에서 동작해서 Dispatch안해도된다 self.myTableView.reloadData() }) .store(in: &amp;subscriptions) */ $dummies.receive(on: DispatchQueue.main) .sink(receiveValue: self.myTableView.customItemsWithCell( // 셀에 대한 종류를 정해주기 위해 바깥으로 뺀 형태 -&gt; makeCell을 데이터 타입마다 다르게 정의할 수 있다 makeCell: { myTableView, indexPath, cellData in // [guard let] 방식 guard let cell = myTableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else { return UITableViewCell() } cell.titleLabel.text = cellData.title // 셀의 주 텍스트를 더미 데이터에서 가져오기 cell.bodyLabel.text = cellData.body // 셀의 서브 타이틀 설정 cell.detailTextLabel?.numberOfLines = 0 return cell })) .store(in: &amp;subscriptions) // 2초 뒤에 더미데이터 10개 추가 DispatchQueue.global().asyncAfter(deadline: .now() + 2, execute: { self.dummies += DummyData.getDumies(10) // self.indexDatas += IndexData.getDumies(10) }) } fileprivate func configureTableView() { // CodeCell에서는 이 줄만 필요 self.myTableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier) // self.myTableView.delegate = self } }]]></summary></entry><entry><title type="html">[TableView] 10. 테이블뷰 Combine CustomDataSource</title><link href="http://localhost:4000/UIKit-tableView10/" rel="alternate" type="text/html" title="[TableView] 10. 테이블뷰 Combine CustomDataSource" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>http://localhost:4000/%5BUIKit%5D-tableView10</id><content type="html" xml:base="http://localhost:4000/UIKit-tableView10/"><![CDATA[<!-- <img src="/assets/img/2025-05-08-[UIKit]-tableView2/1.png" alt="1" width="50%"> -->

<!-- <img src="/assets/img/2025-05-08-%5BUIKit%5D-tableView2/1.png" alt="이미지" width="30%"> -->

<h2 id="테이블뷰-콤바인-커스텀-데이터-소스">테이블뷰 콤바인 커스텀 데이터 소스</h2>

<p>지난 시간에 Combine을 통해 List를 보여주었는데 이번 포스트에서는 Combine에서 구독을 통해 들어오는 데이터 바로 DataSource로 연결하는 방법을 해보자. 클로저에 대한 개념을 알아야 이해하기 쉽다.</p>

<h3 id="customcombinedatasourceswift">CustomCombineDataSource.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">//</span>
 <span class="c1">//  CustomCombineDataSource.swift</span>
 <span class="c1">//  UITableViewTutorial</span>
 <span class="c1">//</span>
 <span class="c1">//  Created by 김동현 on 5/15/25.</span>
 <span class="c1">//</span>
 
 <span class="kd">import</span> <span class="kt">UIKit</span>
 
 <span class="kd">class</span> <span class="kt">CustomCombineDataSource</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span> <span class="p">{</span>
     
     <span class="c1">// 멤버 변수</span>
     <span class="k">var</span> <span class="nv">dataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
     
     <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점</span>
 
     <span class="c1">/// 변경된 데이터를 받아서 테이블뷰에 적용한다</span>
     <span class="c1">/// - Parameters:</span>
     <span class="c1">///   - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수</span>
     <span class="c1">///   - tableView: 리로드 대상 테이블뷰</span>
     <span class="kd">func</span> <span class="nf">pushDataList</span><span class="p">(</span><span class="n">_</span> <span class="nv">updatedDataList</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">],</span> <span class="n">to</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">tableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="k">self</span>
         <span class="k">self</span><span class="o">.</span><span class="n">dataList</span> <span class="o">=</span> <span class="n">updatedDataList</span>
         <span class="n">tableView</span><span class="o">.</span><span class="nf">reloadData</span><span class="p">()</span>
     <span class="p">}</span>
     
     <span class="c1">// MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 </span>
     
     <span class="c1">/// 하나의 섹션에 몇개의 rows가 있냐</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
         <span class="k">return</span> <span class="n">dataList</span><span class="o">.</span><span class="n">count</span>
     <span class="p">}</span>
 
     <span class="c1">/// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라</span>
     <span class="c1">/// - indexPath: 셀의 위치를 나타내는 인덱스 경로</span>
     <span class="c1">/// - returns: 구성된 UITableViewCell 객체</span>
     <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
         <span class="c1">/// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)</span>
         <span class="c1">/// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell")</span>
 
         <span class="c1">// [guard let] 방식</span>
         <span class="k">guard</span> <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">CodeCell</span> <span class="k">else</span> <span class="p">{</span>
             <span class="k">return</span> <span class="kt">UITableViewCell</span><span class="p">()</span>
         <span class="p">}</span>
 
         <span class="k">let</span> <span class="nv">cellData</span><span class="p">:</span> <span class="kt">DummyData</span> <span class="o">=</span> <span class="n">dataList</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>
 
         <span class="c1">/// 셀의 주 텍스트를 더미 데이터에서 가져오기</span>
         <span class="n">cell</span><span class="o">.</span><span class="n">titleLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">title</span>
 
         <span class="c1">/// 셀의 서브 타이틀 설정</span>
         <span class="n">cell</span><span class="o">.</span><span class="n">bodyLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cellData</span><span class="o">.</span><span class="n">body</span>
 
         <span class="n">cell</span><span class="o">.</span><span class="n">detailTextLabel</span><span class="p">?</span><span class="o">.</span><span class="n">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="k">return</span> <span class="n">cell</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>커스텀 데이터소스를 만든다. 멤버변수로 데이터리스트를 보유하도록 하자. 지금은 DummyData이지만 다음 포스팅에서 제네릭으로 변경할 예정이다.  DataSource에서 변경이 된 데이터와 테이블뷰 리로드를 위한 테이블뷰 접근을 관리하기 위해 pushDataList()를 만들어주자. 그리고 기존 ViewController에서 관리하던 UITableViewDataSource 관련 프로토콜 로직을 CustomCombineDataSource로 그대로 옮겨준다.  왜냐하면 원래 dataSource의 주요 역할이 어떤 셀의 종류를 보여줄지, 리스트 개수가 몇개일지를 관여하기 때문이다. 즉 기존 ViewController의 비즈니스 로직을 CustomDataSource로 옮긴 것이다. 이제 CustomDataSource를 만들었으니 적용하기 위해 클로저를 만들어주자.</p>

<h3 id="uitableviewcombineswift">UITableView+Combine.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  UITableView+Combine.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/15/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="c1">// MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자.</span>
<span class="c1">// public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable</span>
<span class="kd">extension</span> <span class="kt">UITableView</span> <span class="p">{</span>
    <span class="c1">// 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체</span>
    <span class="c1">// (Self.Output) -&gt; Void)</span>
    <span class="c1">// ([DummyData]) -&gt; Void</span>
    <span class="c1">// 데이터소스 바인딩</span>
    <span class="kd">func</span> <span class="nf">customItems</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">([</span><span class="kt">DummyData</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">dataSource</span> <span class="o">=</span> <span class="kt">CustomCombineDataSource</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span> <span class="p">(</span><span class="nv">updatedDateLisst</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">])</span> <span class="k">in</span>
            <span class="n">dataSource</span><span class="o">.</span><span class="nf">pushDataList</span><span class="p">(</span><span class="n">updatedDateLisst</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <span class="c1">// 리로드</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>기존 ViewController에서 sink로 받는 것을 보면 제네릭 형태인데 Sink로 이벤트(Publisker)가 들어온 데이터를 매개변수로 가지고 반환이 없는 형태의 클로저이다. (Self.Output) -&gt; Void)</p>

<p>이 (Self.Output) -&gt; Void) 형태로 반환을 만족하는 함수를 만들어주자. 지금은 들어오는 형태가 [DummyData] 이므로 func customItems() -&gt; ([DummyData]) -&gt; Void로 해주면 된다.</p>

<p>SInk를 통해 들어오는게 [DummyData]로 들어오게 되고 return { input in } 에 input 부분으로 들어오게 된다.<br />
그럼 pushDataList를 통해 변경이 된 이벤트를 나자신에게 넣어준다.</p>

<h3 id="combinelistviewcontrollerswift">CombineListViewController.swift</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  CombineListViewController.swift</span>
<span class="c1">//  UITableViewTutorial</span>
<span class="c1">//</span>
<span class="c1">//  Created by 김동현 on 5/13/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">CombineListViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="c1">// Combine 메모리 처리를 위해 생성</span>
    <span class="k">var</span> <span class="nv">subscriptions</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="c1">// Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다.</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">dummies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DummyData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">myTableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="o">!</span>

   
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="nf">configureTableView</span><span class="p">()</span>
        
        
        <span class="cm">/*
        - sink는 @Published가 수정된 스레드에서 실행된다
        - 그래서 Published변수 수정시 메인 스레드에서 수정해주자
        - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다
         */</span>
        
        <span class="c1">// MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다.</span>
        <span class="c1">// $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨</span>
        <span class="c1">// sink는 구독하는 것이다.</span>
        <span class="c1">// AnyCancellable 구독한다고 한다.</span>
        <span class="c1">// store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다.</span>
        <span class="n">$dummies</span>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveValue</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">customItems</span><span class="p">())</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">subscriptions</span><span class="p">)</span>
        
        <span class="cm">/*
         기존 방식
         $dummies
             .receive(on: DispatchQueue.main)
             // 데이터 변경시마다 동작
             .sink(receiveValue: { (changedDummies: [DummyData]) in
                 print("changedDummies: \(changedDummies.count)")
                 
                 // sink는 메인스레드에서 동작해서 Dispatch안해도된다
                 self.myTableView.reloadData()
             })
             .store(in: &amp;subscriptions)
         */</span>
        
        <span class="c1">// 2초 뒤에 더미데이터 10개 추가</span>
        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="nf">asyncAfter</span><span class="p">(</span><span class="nv">deadline</span><span class="p">:</span> <span class="o">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">execute</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="n">dummies</span> <span class="o">+=</span> <span class="kt">DummyData</span><span class="o">.</span><span class="nf">getDumies</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="kd">fileprivate</span> <span class="kd">func</span> <span class="nf">configureTableView</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="c1">// CodeCell에서는 이 줄만 필요</span>
        <span class="k">self</span><span class="o">.</span><span class="n">myTableView</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="kt">CodeCell</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="kt">CodeCell</span><span class="o">.</span><span class="n">reuseIdentifier</span><span class="p">)</span>
        <span class="c1">// self.myTableView.delegate = self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>결국 Combine 데이터 변경되었을 때 즉 Publisher가 들어올 때 바로 tableview의 dataSource도 설정하고, 바로 데이터를 꽂아줄 수 있다. 하지만 지금 customItems() 형태가 DummyData로 고정되어있기 때문에 서버에서 받을 수 있는 여러 타입을 모두 반영하기 위해 제네릭으로 변환하는 포스팅을 작성할 예정이다.</p>]]></content><author><name>Dong Hyeon</name></author><category term="UIKit" /><category term="TableView" /><summary type="html"><![CDATA[테이블뷰 콤바인 커스텀 데이터 소스 지난 시간에 Combine을 통해 List를 보여주었는데 이번 포스트에서는 Combine에서 구독을 통해 들어오는 데이터 바로 DataSource로 연결하는 방법을 해보자. 클로저에 대한 개념을 알아야 이해하기 쉽다. CustomCombineDataSource.swift // // CustomCombineDataSource.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // import UIKit class CustomCombineDataSource: NSObject, UITableViewDataSource { // 멤버 변수 var dataList: [DummyData] = [] override init() { super.init() } // MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점 /// 변경된 데이터를 받아서 테이블뷰에 적용한다 /// - Parameters: /// - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수 /// - tableView: 리로드 대상 테이블뷰 func pushDataList(_ updatedDataList: [DummyData], to tableView: UITableView) { tableView.dataSource = self self.dataList = updatedDataList tableView.reloadData() } // MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적 /// 하나의 섹션에 몇개의 rows가 있냐 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return dataList.count } /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라 /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 /// - returns: 구성된 UITableViewCell 객체 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함) /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "MyCell") // [guard let] 방식 guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else { return UITableViewCell() } let cellData: DummyData = dataList[indexPath.row] /// 셀의 주 텍스트를 더미 데이터에서 가져오기 cell.titleLabel.text = cellData.title /// 셀의 서브 타이틀 설정 cell.bodyLabel.text = cellData.body cell.detailTextLabel?.numberOfLines = 0 return cell } } 커스텀 데이터소스를 만든다. 멤버변수로 데이터리스트를 보유하도록 하자. 지금은 DummyData이지만 다음 포스팅에서 제네릭으로 변경할 예정이다. DataSource에서 변경이 된 데이터와 테이블뷰 리로드를 위한 테이블뷰 접근을 관리하기 위해 pushDataList()를 만들어주자. 그리고 기존 ViewController에서 관리하던 UITableViewDataSource 관련 프로토콜 로직을 CustomCombineDataSource로 그대로 옮겨준다. 왜냐하면 원래 dataSource의 주요 역할이 어떤 셀의 종류를 보여줄지, 리스트 개수가 몇개일지를 관여하기 때문이다. 즉 기존 ViewController의 비즈니스 로직을 CustomDataSource로 옮긴 것이다. 이제 CustomDataSource를 만들었으니 적용하기 위해 클로저를 만들어주자. UITableView+Combine.swift // // UITableView+Combine.swift // UITableViewTutorial // // Created by 김동현 on 5/15/25. // import UIKit import Combine // MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자. // public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable extension UITableView { // 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체 // (Self.Output) -&gt; Void) // ([DummyData]) -&gt; Void // 데이터소스 바인딩 func customItems() -&gt; ([DummyData]) -&gt; Void { let dataSource = CustomCombineDataSource() return { (updatedDateLisst: [DummyData]) in dataSource.pushDataList(updatedDateLisst, to: self) // 리로드 } } } 기존 ViewController에서 sink로 받는 것을 보면 제네릭 형태인데 Sink로 이벤트(Publisker)가 들어온 데이터를 매개변수로 가지고 반환이 없는 형태의 클로저이다. (Self.Output) -&gt; Void) 이 (Self.Output) -&gt; Void) 형태로 반환을 만족하는 함수를 만들어주자. 지금은 들어오는 형태가 [DummyData] 이므로 func customItems() -&gt; ([DummyData]) -&gt; Void로 해주면 된다. SInk를 통해 들어오는게 [DummyData]로 들어오게 되고 return { input in } 에 input 부분으로 들어오게 된다. 그럼 pushDataList를 통해 변경이 된 이벤트를 나자신에게 넣어준다. CombineListViewController.swift // // CombineListViewController.swift // UITableViewTutorial // // Created by 김동현 on 5/13/25. // import UIKit import Combine class CombineListViewController: UIViewController { // Combine 메모리 처리를 위해 생성 var subscriptions = Set&lt;AnyCancellable&gt;() // Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다. @Published var dummies: [DummyData] = [] @IBOutlet weak var myTableView: UITableView! override func viewDidLoad() { super.viewDidLoad() configureTableView() /* - sink는 @Published가 수정된 스레드에서 실행된다 - 그래서 Published변수 수정시 메인 스레드에서 수정해주자 - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다 */ // MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다. // $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨 // sink는 구독하는 것이다. // AnyCancellable 구독한다고 한다. // store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다. $dummies .receive(on: DispatchQueue.main) .sink(receiveValue: self.myTableView.customItems()) .store(in: &amp;subscriptions) /* 기존 방식 $dummies .receive(on: DispatchQueue.main) // 데이터 변경시마다 동작 .sink(receiveValue: { (changedDummies: [DummyData]) in print("changedDummies: \(changedDummies.count)") // sink는 메인스레드에서 동작해서 Dispatch안해도된다 self.myTableView.reloadData() }) .store(in: &amp;subscriptions) */ // 2초 뒤에 더미데이터 10개 추가 DispatchQueue.global().asyncAfter(deadline: .now() + 2, execute: { self.dummies += DummyData.getDumies(10) }) } fileprivate func configureTableView() { // CodeCell에서는 이 줄만 필요 self.myTableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier) // self.myTableView.delegate = self } } 결국 Combine 데이터 변경되었을 때 즉 Publisher가 들어올 때 바로 tableview의 dataSource도 설정하고, 바로 데이터를 꽂아줄 수 있다. 하지만 지금 customItems() 형태가 DummyData로 고정되어있기 때문에 서버에서 받을 수 있는 여러 타입을 모두 반영하기 위해 제네릭으로 변환하는 포스팅을 작성할 예정이다.]]></summary></entry></feed>