<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[SwiftUI] 프로젝트에서 UserDBRepository, UserService, ViewModel 계층의 역할과 사용법 - DongHyeon Kim’s Blog</title>
<meta name="description" content="1. SwiftUI 프로젝트에서 UserDBRepository, UserService, ViewModel 계층의 역할과 사용법  목차    UserDBRepository와 UserService의 개념 및 역할   계층을 나눈 이유   데이터 모델(User vs UserObject)의 차이점   비즈니스 로직 정의와 예시   Mermaid 다이어그램   코드 예시   UserDBRepository UserDBRepository는 데이터베이스에 직접적으로 접근하는 계층이다.   Firebase Realtime Database와 같은 외부 데이터베이스와의 통신을 담당하며, 데이터 추가 ,조회, 업데이트, 삭제 등의 CRUD 작업을 제공한다  주요 역할    Firebase와의 직접 통신: Firebase 데이터베이스를 호출하여 데이터를 가져오거나 저장한다.   데이터 변환: 앱의 모델 데이터를 JSON 형식으로 변환하거나, 데이터베이스에서 가져온 데이터를 앱에서 사용할 수 있는 모델로 변환한다.   비동기 처리: Combine이나 async/await를 통해 비동기 작업을 처리한다   코드 예시 func getUser(userId: String) async throws -&gt; UserObject {     guard let value = try await self.db.child(DBKey.Users).child(userId).getData().value else {         throw DBError.emptyValue     }     let data = try JSONSerialization.data(withJSONObject: value)     return try JSONDecoder().decode(UserObject.self, from: data) }     UserService UserService는 앱의 비즈니스 로직을 담당하며, 뷰모델(ViewModel)과 데이터베이스 리포지토리(Repository) 사이의 중간 계층 역할을 한다. UserDBRepository에서 데이터를 가져와 가공하거나, 데이터를 업데이트 하기 전에 추가적인 로직을 처리한다.  주요 역할    비즈니스 로직 처리: Repository에서 데이터를 가져온 후 추가적인 가공 또는 검증 로직을 수행한다.   모델 변환: 앱에서 사용하는 데이터 모델(User)와 데이터베이스 객체(UserObject)간의 변환을 수행한다.   의존성 주입: Repository를 주입받아 느슨한 결합(Lose Coupling)을 유지한다.   2. UserDBRepository, UserService 계층을 나눈 이유    책임 분리            UserDBRepository는 데이터베이스에 직접 통신하는 역할을, UserService는 비즈니스 로직 처리를 담당한다.       데이터베이스와 비즈니스 로직 간의 의존성을 줄여 각각 독립적으로 개발, 수정이 가능하다           테스트 용이성            UserService는 데이터베이스와 독립적으로 동작하므로, 단위 테스트에서 Mock이나 Stub을 사용해 테스트하기 용이하다.           유연성 확보            데이터베이스가 Firebase에서 다른 데이터베이스로 변경되더라도 UserDBRepository만 수정하면 된다.       UserService와 ViewModel은 변경에 영향을 받지 않는다.           3. 앱에서 사용하는 데이터 모델(User)과 데이터베이스 객체(UserObject)차이 UserObject:    데이터베이스와 직접적으로 관련된 구조이다. 데이터베이스에 저장하거나 가져오는 형태로 디자인되어있다.   데이터베이스와의 의존성이 있는 구조체로, 데이터 저장 형식(JSON, Dictionary등)에 최적화되어있다.   예를 들어 Firebase Realtime Database는 Json 기반으로 데이터를 저장하므로, UserObject는 이러한 데이터 포멧을 고려한 구조를 가진다.   ex) Double 타입으로 변환된 createdAt 값을 사용.   // 데이터베이스와 통신하기 위해 설계된 데이터 모델 // 데이터베이스(Firebase 등)의 JSON 형식에 맞게 데이터를 저장하거나 읽어오기 위해 존재 // 단순하고 직렬화 가능(Codable)하도록 설계  // -&gt; Codable 프로토콜을 사용해 JSON과 UserObject 간 변환을 쉽게 처리 struct UserObject: Codable {     var id: String     var name: String     var description: String     var createdAt: Double // Firebase timestamp }   User    앱 내부에서 사용되는 모델로, UI와 비즈니스 로직에 맞게 설계되어 있다.   데이터베이스와 무관하며, 앱의 화면 및 로직 처리에 필요한 형태와 속성을 가진다.   ex) Date 타입으로 변환된 createdAt 값을 사용.   // UserObject에는 없는 추가적인 계산이나 데이터를 포함할 수 있다 // ex) 사용자 이름을 &quot;Mr. DongHyeon Kim&quot;형태로 가공하여 표시 가능 struct User {     var id: String     var name: String     var description: String     var createdAt: Date // Swift의 Date 객체 }     차이점 요약    책임 분리            UserObject는 데이터베이스와 통신하며, User는 앱의 비즈니스 로직 및 UI에 사용된다.           유연성과 확장성            데이터베이스 변경 시 UserObject만 수정하면 되고, User는 변경되지 않는다.           타입 안정성            JSON 데이터를 다루는 UserObject는 Firebase와의 호환성을, User는 앱에서의 타입 안전성을 보장한다.             4. 비즈니스 로직 정의와 예시  비즈니스 로직이란? 비즈니스 로직은 소프트웨어에서 특정 도메인의 요구사항을 처리하기 위한 규칙, 절차, 계산, 데이터 처리 및 제약 조건을 정의하고 실행하는 코드이다.     역할:            단순 데이터 저장 및 읽기 이상의 추가 처리(가공, 검증 등)를 담당.       특정 도메인의 요구사항을 반영하여 데이터를 처리.             UserService에서의 비즈니스 로직 예시  예 1: 사용자 상태 메시지 검증 사용자가 상태 메시지를 입력할 때 길이가 140자를 초과하지 않도록 제한. func validateStatusMessage(_ message: String) -&gt; Bool {     return message.count &lt;= 140 }   예 2: Firebase 시간 데이터를 로컬 시간으로 변환 Firebase에서 저장된 UTC 시간을 사용자의 로컬 시간으로 변환. func convertToUserLocalTime(utcTimestamp: Double) -&gt; Date {     let date = Date(timeIntervalSince1970: utcTimestamp)     let userTimeZone = TimeZone.current     let secondsFromGMT = userTimeZone.secondsFromGMT(for: date)     return date.addingTimeInterval(Double(secondsFromGMT)) }   예 3: 데이터 업데이트 로직 상태 메시지를 업데이트하기 전에 비즈니스 검증 로직을 추가. func updateDescription(userId: String, description: String) async throws {     guard validateStatusMessage(description) else {         throw ValidationError.invalidMessage     }     try await dbRepository.updateUser(userid: userId, key: &quot;description&quot;, value: description) }     5. Mermaid 다이어그램 sequenceDiagram     participant View as MyProfileView     participant ViewModel as MyProfileViewModel     participant Service as UserService     participant Repository as UserDBRepository     participant Firebase as Firebase      View-&gt;&gt;ViewModel: .task { await getUser() }     ViewModel-&gt;&gt;Service: getUser(userId)     Service-&gt;&gt;Repository: getUser(userId)     Repository-&gt;&gt;Firebase: 데이터 조회     Firebase--&gt;&gt;Repository: UserObject     Repository--&gt;&gt;Service: UserObject 변환     Service--&gt;&gt;ViewModel: User     ViewModel--&gt;&gt;View: userInfo 업데이트   6. 코드 예시 데이터 모델 변환 extension UserObject {     func toModel() -&gt; User {         return User(             id: self.id,             name: self.name,             description: self.description,             createdAt: Date(timeIntervalSince1970: self.createdAt)         )     } }  extension User {     func toObject() -&gt; UserObject {         return UserObject(             id: self.id,             name: self.name,             description: self.description,             createdAt: self.createdAt.timeIntervalSince1970         )     } }     결론 UserDBRepository와 UserService는 데이터베이스와 비즈니스 로직을 명확히 분리하여 코드의 유지보수성과 확장성을 높인다.   비즈니스 로직은 데이터를 검증하거나 변환하여 UI와 사용자 경험의 품질을 보장한다.">


  <meta name="author" content="Dong Hyeon">
  
  <meta property="article:author" content="Dong Hyeon">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="DongHyeon Kim's Blog">
<meta property="og:title" content="[SwiftUI] 프로젝트에서 UserDBRepository, UserService, ViewModel 계층의 역할과 사용법">
<meta property="og:url" content="http://localhost:4000/SwiftUI-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-UserDBRepository-,-UserService-,-ViewModel-%EA%B3%84%EC%B8%B5%EC%9D%98-%EC%97%AD%ED%95%A0%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95/">


  <meta property="og:description" content="1. SwiftUI 프로젝트에서 UserDBRepository, UserService, ViewModel 계층의 역할과 사용법  목차    UserDBRepository와 UserService의 개념 및 역할   계층을 나눈 이유   데이터 모델(User vs UserObject)의 차이점   비즈니스 로직 정의와 예시   Mermaid 다이어그램   코드 예시   UserDBRepository UserDBRepository는 데이터베이스에 직접적으로 접근하는 계층이다.   Firebase Realtime Database와 같은 외부 데이터베이스와의 통신을 담당하며, 데이터 추가 ,조회, 업데이트, 삭제 등의 CRUD 작업을 제공한다  주요 역할    Firebase와의 직접 통신: Firebase 데이터베이스를 호출하여 데이터를 가져오거나 저장한다.   데이터 변환: 앱의 모델 데이터를 JSON 형식으로 변환하거나, 데이터베이스에서 가져온 데이터를 앱에서 사용할 수 있는 모델로 변환한다.   비동기 처리: Combine이나 async/await를 통해 비동기 작업을 처리한다   코드 예시 func getUser(userId: String) async throws -&gt; UserObject {     guard let value = try await self.db.child(DBKey.Users).child(userId).getData().value else {         throw DBError.emptyValue     }     let data = try JSONSerialization.data(withJSONObject: value)     return try JSONDecoder().decode(UserObject.self, from: data) }     UserService UserService는 앱의 비즈니스 로직을 담당하며, 뷰모델(ViewModel)과 데이터베이스 리포지토리(Repository) 사이의 중간 계층 역할을 한다. UserDBRepository에서 데이터를 가져와 가공하거나, 데이터를 업데이트 하기 전에 추가적인 로직을 처리한다.  주요 역할    비즈니스 로직 처리: Repository에서 데이터를 가져온 후 추가적인 가공 또는 검증 로직을 수행한다.   모델 변환: 앱에서 사용하는 데이터 모델(User)와 데이터베이스 객체(UserObject)간의 변환을 수행한다.   의존성 주입: Repository를 주입받아 느슨한 결합(Lose Coupling)을 유지한다.   2. UserDBRepository, UserService 계층을 나눈 이유    책임 분리            UserDBRepository는 데이터베이스에 직접 통신하는 역할을, UserService는 비즈니스 로직 처리를 담당한다.       데이터베이스와 비즈니스 로직 간의 의존성을 줄여 각각 독립적으로 개발, 수정이 가능하다           테스트 용이성            UserService는 데이터베이스와 독립적으로 동작하므로, 단위 테스트에서 Mock이나 Stub을 사용해 테스트하기 용이하다.           유연성 확보            데이터베이스가 Firebase에서 다른 데이터베이스로 변경되더라도 UserDBRepository만 수정하면 된다.       UserService와 ViewModel은 변경에 영향을 받지 않는다.           3. 앱에서 사용하는 데이터 모델(User)과 데이터베이스 객체(UserObject)차이 UserObject:    데이터베이스와 직접적으로 관련된 구조이다. 데이터베이스에 저장하거나 가져오는 형태로 디자인되어있다.   데이터베이스와의 의존성이 있는 구조체로, 데이터 저장 형식(JSON, Dictionary등)에 최적화되어있다.   예를 들어 Firebase Realtime Database는 Json 기반으로 데이터를 저장하므로, UserObject는 이러한 데이터 포멧을 고려한 구조를 가진다.   ex) Double 타입으로 변환된 createdAt 값을 사용.   // 데이터베이스와 통신하기 위해 설계된 데이터 모델 // 데이터베이스(Firebase 등)의 JSON 형식에 맞게 데이터를 저장하거나 읽어오기 위해 존재 // 단순하고 직렬화 가능(Codable)하도록 설계  // -&gt; Codable 프로토콜을 사용해 JSON과 UserObject 간 변환을 쉽게 처리 struct UserObject: Codable {     var id: String     var name: String     var description: String     var createdAt: Double // Firebase timestamp }   User    앱 내부에서 사용되는 모델로, UI와 비즈니스 로직에 맞게 설계되어 있다.   데이터베이스와 무관하며, 앱의 화면 및 로직 처리에 필요한 형태와 속성을 가진다.   ex) Date 타입으로 변환된 createdAt 값을 사용.   // UserObject에는 없는 추가적인 계산이나 데이터를 포함할 수 있다 // ex) 사용자 이름을 &quot;Mr. DongHyeon Kim&quot;형태로 가공하여 표시 가능 struct User {     var id: String     var name: String     var description: String     var createdAt: Date // Swift의 Date 객체 }     차이점 요약    책임 분리            UserObject는 데이터베이스와 통신하며, User는 앱의 비즈니스 로직 및 UI에 사용된다.           유연성과 확장성            데이터베이스 변경 시 UserObject만 수정하면 되고, User는 변경되지 않는다.           타입 안정성            JSON 데이터를 다루는 UserObject는 Firebase와의 호환성을, User는 앱에서의 타입 안전성을 보장한다.             4. 비즈니스 로직 정의와 예시  비즈니스 로직이란? 비즈니스 로직은 소프트웨어에서 특정 도메인의 요구사항을 처리하기 위한 규칙, 절차, 계산, 데이터 처리 및 제약 조건을 정의하고 실행하는 코드이다.     역할:            단순 데이터 저장 및 읽기 이상의 추가 처리(가공, 검증 등)를 담당.       특정 도메인의 요구사항을 반영하여 데이터를 처리.             UserService에서의 비즈니스 로직 예시  예 1: 사용자 상태 메시지 검증 사용자가 상태 메시지를 입력할 때 길이가 140자를 초과하지 않도록 제한. func validateStatusMessage(_ message: String) -&gt; Bool {     return message.count &lt;= 140 }   예 2: Firebase 시간 데이터를 로컬 시간으로 변환 Firebase에서 저장된 UTC 시간을 사용자의 로컬 시간으로 변환. func convertToUserLocalTime(utcTimestamp: Double) -&gt; Date {     let date = Date(timeIntervalSince1970: utcTimestamp)     let userTimeZone = TimeZone.current     let secondsFromGMT = userTimeZone.secondsFromGMT(for: date)     return date.addingTimeInterval(Double(secondsFromGMT)) }   예 3: 데이터 업데이트 로직 상태 메시지를 업데이트하기 전에 비즈니스 검증 로직을 추가. func updateDescription(userId: String, description: String) async throws {     guard validateStatusMessage(description) else {         throw ValidationError.invalidMessage     }     try await dbRepository.updateUser(userid: userId, key: &quot;description&quot;, value: description) }     5. Mermaid 다이어그램 sequenceDiagram     participant View as MyProfileView     participant ViewModel as MyProfileViewModel     participant Service as UserService     participant Repository as UserDBRepository     participant Firebase as Firebase      View-&gt;&gt;ViewModel: .task { await getUser() }     ViewModel-&gt;&gt;Service: getUser(userId)     Service-&gt;&gt;Repository: getUser(userId)     Repository-&gt;&gt;Firebase: 데이터 조회     Firebase--&gt;&gt;Repository: UserObject     Repository--&gt;&gt;Service: UserObject 변환     Service--&gt;&gt;ViewModel: User     ViewModel--&gt;&gt;View: userInfo 업데이트   6. 코드 예시 데이터 모델 변환 extension UserObject {     func toModel() -&gt; User {         return User(             id: self.id,             name: self.name,             description: self.description,             createdAt: Date(timeIntervalSince1970: self.createdAt)         )     } }  extension User {     func toObject() -&gt; UserObject {         return UserObject(             id: self.id,             name: self.name,             description: self.description,             createdAt: self.createdAt.timeIntervalSince1970         )     } }     결론 UserDBRepository와 UserService는 데이터베이스와 비즈니스 로직을 명확히 분리하여 코드의 유지보수성과 확장성을 높인다.   비즈니스 로직은 데이터를 검증하거나 변환하여 UI와 사용자 경험의 품질을 보장한다.">







  <meta property="article:published_time" content="2024-11-13T00:00:00+00:00">





  

  


<link rel="canonical" href="http://localhost:4000/SwiftUI-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-UserDBRepository-,-UserService-,-ViewModel-%EA%B3%84%EC%B8%B5%EC%9D%98-%EC%97%AD%ED%95%A0%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "indextrown",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->

<!-- 여기에 analytics 추가 -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="DongHyeon Kim's Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



<!--JQ cloud-->
<link rel="stylesheet" href="/assets/css/jqcloud.min.css">

<!-- pseudocode.js -->
<script src="/assets/pseudocode.js-2.4.1/pseudocode.js" type="text/javascript"></script>
<link rel="stylesheet" href="/assets/pseudocode.js-2.4.1/pseudocode.css">
    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-square-neo.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-gothic-coding.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
    
  <script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
    <script src="https://code.jquery.com/jquery-3.4.1.js"></script>

    <!-- Mermaid.js를 로드 기능 추가 - [index] -->
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<script src="https://unpkg.com/ionicons@4.5.10-0/dist/ionicons.js"></script>

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <!-- <a class="site-logo" href="/">
          <img src="/assets/logos/logo.svg" alt="DongHyeon Kim's Blog"></a> -->
        <a class="site-title" href="/">
          @dong_h_kim
          <span class="site-subtitle">iOS Developer Blog</span>
        </a>
        <!-- Dark mode toggle -->
        <!-- <input type="checkbox" id="switch" name="theme">
        <label for="switch" class="switch_label">
          <span class="onf_btn"></span>
        </label> -->
        <script src="https://code.iconify.design/1/1.0.4/iconify.min.js">   </script>
<label class="switch_label">
<input class='toggle-checkbox' type='checkbox'></input>
<div class='toggle-slot'>
    <div class='sun-icon-wrapper'>
    <div class="iconify sun-icon" data-icon="feather-sun" data-inline="false"></div>
    </div>
    <div class='toggle-button'></div>
    <div class='moon-icon-wrapper'>
    <div class="iconify moon-icon" data-icon="feather-moon" data-inline="false"></div>
    </div>
</div>
</label>
  

  
<style>

.toggle-checkbox {
  position: absolute;
  opacity: 0;
  cursor: pointer;
  height: 0;
  width: 0;
}

.toggle-slot {
  position: relative;
  height: 35px; /* Adjusted height for PC */
  width: 70px; /* Adjusted width for PC */
  border: 5px solid #e4e7ec;
  border-radius: 35px; /* Adjusted border-radius for PC */
  background-color: white;
  /* box-shadow: 0px 10px 25px #e4e7ec; */
  transition: background-color 250ms;
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-slot {
    height: 25px; /* Adjusted height for mobile */
    width: 50px; /* Adjusted width for mobile */
    border-radius: 25px; /* Adjusted border-radius for mobile */
    border: 3px solid #e4e7ec;
  }
}

.toggle-checkbox:checked ~ .toggle-slot {
  background-color: #374151;
}

.toggle-button {
  transform: translate(35px, 4px); /* Adjusted position for PC */
  position: absolute;
  height: 17.5px; /* Adjusted height for PC */
  width: 17.5px; /* Adjusted width for PC */
  border-radius: 50%;
  background-color: #ffeccf;
  box-shadow: inset 0px 0px 0px 3.5px #ffbb52; /* Adjusted box-shadow for PC */
  transition: background-color 250ms, border-color 250ms, transform 500ms;
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-button {
    transform: translate(27px, 3.5px); /* Adjusted position for mobile */
    height: 12.5px; /* Adjusted height for mobile */
    width: 12.5px; /* Adjusted width for mobile */
    box-shadow: inset 0px 0px 0px 2.5px #ffbb52; /* Adjusted box-shadow for mobile */
  }
}

.toggle-checkbox:checked ~ .toggle-slot .toggle-button {
  background-color: #485367;
  box-shadow: inset 0px 0px 0px 3.5px white; /* Adjusted box-shadow for PC */
  transform: translate(7px, 4px); /* Adjusted position for PC */
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-checkbox:checked ~ .toggle-slot .toggle-button {
    box-shadow: inset 0px 0px 0px 2.5px white; /* Adjusted box-shadow for mobile */
    transform: translate(4px, 3.5px); /* Adjusted position for mobile */
  }
}

.sun-icon {
  position: absolute;
  height: 18px; /* Adjusted height for PC */
  width: 18px; /* Adjusted width for PC */
  color: #ffbb52;
}

.sun-icon-wrapper {
  position: absolute;
  top: 10%;
  height: 18px; /* Adjusted height for PC */
  width: 18px; /* Adjusted width for PC */
  opacity: 1;
  transform: translate(5px, 1px) rotate(15deg); /* Adjusted position for PC */
  transform-origin: 50% 50%;
  transition: opacity 150ms, transform 500ms;
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .sun-icon,
  .sun-icon-wrapper {
    height: 11px; /* Adjusted height for mobile */
    width: 11px; /* Adjusted width for mobile */
    transform: translate(5px, 3px) rotate(15deg); /* Adjusted position for mobile */
  }
}

.toggle-checkbox:checked ~ .toggle-slot .sun-icon-wrapper {
  opacity: 0;
  transform: translate(0px, 1px) rotate(0deg); /* Adjusted position for PC */
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-checkbox:checked ~ .toggle-slot .sun-icon-wrapper {
    transform: translate(2px, 2.5px) rotate(0deg); /* Adjusted position for mobile */
  }
}

.moon-icon {
  position: absolute;
  height: 18px; /* Adjusted height for PC */
  width: 18px; /* Adjusted width for PC */
  color: white;
}

.moon-icon-wrapper {
  position: absolute;
  top: 10%;
  height: 18px; /* Adjusted height for PC */
  width: 18px; /* Adjusted width for PC */
  opacity: 0;
  transform: translate(30px, 1px) rotate(0deg); /* Adjusted position for PC */
  transform-origin: 50% 50%;
  transition: opacity 150ms, transform 500ms;
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .moon-icon,
  .moon-icon-wrapper {
    height: 11px; /* Adjusted height for mobile */
    width: 11px; /* Adjusted width for mobile */
    transform: translate(25px, 2.5px) rotate(0deg); /* Adjusted position for mobile */
  }
}

.toggle-checkbox:checked ~ .toggle-slot .moon-icon-wrapper {
  opacity: 1;
  transform: translate(35px, 1px) rotate(-15deg); /* Adjusted position for PC */
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-checkbox:checked ~ .toggle-slot .moon-icon-wrapper {
    transform: translate(28px, 2.5px) rotate(-15deg); /* Adjusted position for mobile */
  }
}


</style>

<script>
var checkbox = document.querySelector('.toggle-checkbox');

// 페이지 로드 시 로컬 스토리지에서 테마 설정을 불러옵니다.
if (localStorage.getItem('theme') === 'dark') {
  checkbox.checked = true;
  document.body.classList.add('dark');
} else {
  checkbox.checked = false;
  document.body.classList.remove('dark');
}

checkbox.addEventListener('change', function() {
  // 테마를 토글하고 로컬 스토리지에 저장합니다.
  // trans();
  document.body.classList.toggle('dark');
  localStorage.setItem('theme', this.checked ? 'dark' : 'light');
});
</script>

        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li><li class="masthead__menu-item">
              <a href="/posts/">Articles</a>
            </li><li class="masthead__menu-item">
              <a href="/projects/">Projects</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

<script>
  $(function(){
  var $header = $('masthead'); //헤더를 변수에 넣기
  var $page = $('.initial-content'); //색상이 변할 부분
  var $window = $(window);
  var pageOffsetTop = $page.offset().top;//색상 변할 부분의 top값 구하기
  
  $window.resize(function(){ //반응형을 대비하여 리사이즈시 top값을 다시 계산
    pageOffsetTop = $page.offset().top;
  });
  
  $window.on('scroll', function(){ //스크롤시
    var scrolled = $window.scrollTop() >= pageOffsetTop; //스크롤된 상태; true or false
    $header.toggleClass('down', scrolled); //클래스 토글
  });
});

// var menuToggleButton = document.querySelector("button.toggle");
// var menuTarget = document.querySelector(".side-menu");
// var menuBlock = document.querySelector("menu");

// function toggleMenuVisibility(){
// 	menuTarget.classList.toggle("side-menu--active");
// 	animateCSS(".menu", "fadeIn");
// }

// function animateCSS(element, animationName, callback) {
//     var node = document.querySelector(element)
//     node.classList.add('animated', animationName)

//     function handleAnimationEnd() {
//         node.classList.remove('animated', animationName)
//         node.removeEventListener('animationend', handleAnimationEnd)

//         if (typeof callback === 'function') callback()
//     }

//     node.addEventListener('animationend', handleAnimationEnd)
// }

// menuToggleButton.addEventListener('click', toggleMenuVisibility);

// Dark mode toggle

var checkbox = document.querySelector('input[name=theme]');

// 페이지 로드 시 로컬 스토리지에서 테마 설정을 불러옵니다.
if (localStorage.getItem('theme') === 'dark') {
  checkbox.checked = true;
  document.body.classList.add('dark');
} else {
  checkbox.checked = false;
  document.body.classList.remove('dark');
}

checkbox.addEventListener('change', function() {
  // 테마를 토글하고 로컬 스토리지에 저장합니다.
  // trans();
  document.body.classList.toggle('dark');
  localStorage.setItem('theme', this.checked ? 'dark' : 'light');
});


// let trans = () => {
//   document.documentElement.classList.add('transition');
//   window.setTimeout(() => {
//     document.documentElement.classList.remove('transition');
//   }, 500);
// }
</script>

    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[SwiftUI] 프로젝트에서 UserDBRepository, UserService, ViewModel 계층의 역할과 사용법">
    <meta itemprop="description" content="1. SwiftUI 프로젝트에서 UserDBRepository, UserService, ViewModel 계층의 역할과 사용법목차  UserDBRepository와 UserService의 개념 및 역할  계층을 나눈 이유  데이터 모델(User vs UserObject)의 차이점  비즈니스 로직 정의와 예시  Mermaid 다이어그램  코드 예시UserDBRepositoryUserDBRepository는 데이터베이스에 직접적으로 접근하는 계층이다.  Firebase Realtime Database와 같은 외부 데이터베이스와의 통신을 담당하며, 데이터 추가 ,조회, 업데이트, 삭제 등의 CRUD 작업을 제공한다주요 역할  Firebase와의 직접 통신: Firebase 데이터베이스를 호출하여 데이터를 가져오거나 저장한다.  데이터 변환: 앱의 모델 데이터를 JSON 형식으로 변환하거나, 데이터베이스에서 가져온 데이터를 앱에서 사용할 수 있는 모델로 변환한다.  비동기 처리: Combine이나 async/await를 통해 비동기 작업을 처리한다코드 예시func getUser(userId: String) async throws -&gt; UserObject {    guard let value = try await self.db.child(DBKey.Users).child(userId).getData().value else {        throw DBError.emptyValue    }    let data = try JSONSerialization.data(withJSONObject: value)    return try JSONDecoder().decode(UserObject.self, from: data)}UserServiceUserService는 앱의 비즈니스 로직을 담당하며, 뷰모델(ViewModel)과 데이터베이스 리포지토리(Repository) 사이의 중간 계층 역할을 한다. UserDBRepository에서 데이터를 가져와 가공하거나, 데이터를 업데이트 하기 전에 추가적인 로직을 처리한다.주요 역할  비즈니스 로직 처리: Repository에서 데이터를 가져온 후 추가적인 가공 또는 검증 로직을 수행한다.  모델 변환: 앱에서 사용하는 데이터 모델(User)와 데이터베이스 객체(UserObject)간의 변환을 수행한다.  의존성 주입: Repository를 주입받아 느슨한 결합(Lose Coupling)을 유지한다.2. UserDBRepository, UserService 계층을 나눈 이유  책임 분리          UserDBRepository는 데이터베이스에 직접 통신하는 역할을, UserService는 비즈니스 로직 처리를 담당한다.      데이터베이스와 비즈니스 로직 간의 의존성을 줄여 각각 독립적으로 개발, 수정이 가능하다        테스트 용이성          UserService는 데이터베이스와 독립적으로 동작하므로, 단위 테스트에서 Mock이나 Stub을 사용해 테스트하기 용이하다.        유연성 확보          데이터베이스가 Firebase에서 다른 데이터베이스로 변경되더라도 UserDBRepository만 수정하면 된다.      UserService와 ViewModel은 변경에 영향을 받지 않는다.      3. 앱에서 사용하는 데이터 모델(User)과 데이터베이스 객체(UserObject)차이UserObject:  데이터베이스와 직접적으로 관련된 구조이다. 데이터베이스에 저장하거나 가져오는 형태로 디자인되어있다.  데이터베이스와의 의존성이 있는 구조체로, 데이터 저장 형식(JSON, Dictionary등)에 최적화되어있다.  예를 들어 Firebase Realtime Database는 Json 기반으로 데이터를 저장하므로, UserObject는 이러한 데이터 포멧을 고려한 구조를 가진다.  ex) Double 타입으로 변환된 createdAt 값을 사용.// 데이터베이스와 통신하기 위해 설계된 데이터 모델// 데이터베이스(Firebase 등)의 JSON 형식에 맞게 데이터를 저장하거나 읽어오기 위해 존재// 단순하고 직렬화 가능(Codable)하도록 설계 // -&gt; Codable 프로토콜을 사용해 JSON과 UserObject 간 변환을 쉽게 처리struct UserObject: Codable {    var id: String    var name: String    var description: String    var createdAt: Double // Firebase timestamp}User  앱 내부에서 사용되는 모델로, UI와 비즈니스 로직에 맞게 설계되어 있다.  데이터베이스와 무관하며, 앱의 화면 및 로직 처리에 필요한 형태와 속성을 가진다.  ex) Date 타입으로 변환된 createdAt 값을 사용.// UserObject에는 없는 추가적인 계산이나 데이터를 포함할 수 있다// ex) 사용자 이름을 &quot;Mr. DongHyeon Kim&quot;형태로 가공하여 표시 가능struct User {    var id: String    var name: String    var description: String    var createdAt: Date // Swift의 Date 객체}차이점 요약  책임 분리          UserObject는 데이터베이스와 통신하며, User는 앱의 비즈니스 로직 및 UI에 사용된다.        유연성과 확장성          데이터베이스 변경 시 UserObject만 수정하면 되고, User는 변경되지 않는다.        타입 안정성          JSON 데이터를 다루는 UserObject는 Firebase와의 호환성을, User는 앱에서의 타입 안전성을 보장한다.      4. 비즈니스 로직 정의와 예시비즈니스 로직이란?비즈니스 로직은 소프트웨어에서 특정 도메인의 요구사항을 처리하기 위한 규칙, 절차, 계산, 데이터 처리 및 제약 조건을 정의하고 실행하는 코드이다.  역할:          단순 데이터 저장 및 읽기 이상의 추가 처리(가공, 검증 등)를 담당.      특정 도메인의 요구사항을 반영하여 데이터를 처리.      UserService에서의 비즈니스 로직 예시예 1: 사용자 상태 메시지 검증사용자가 상태 메시지를 입력할 때 길이가 140자를 초과하지 않도록 제한.func validateStatusMessage(_ message: String) -&gt; Bool {    return message.count &lt;= 140}예 2: Firebase 시간 데이터를 로컬 시간으로 변환Firebase에서 저장된 UTC 시간을 사용자의 로컬 시간으로 변환.func convertToUserLocalTime(utcTimestamp: Double) -&gt; Date {    let date = Date(timeIntervalSince1970: utcTimestamp)    let userTimeZone = TimeZone.current    let secondsFromGMT = userTimeZone.secondsFromGMT(for: date)    return date.addingTimeInterval(Double(secondsFromGMT))}예 3: 데이터 업데이트 로직상태 메시지를 업데이트하기 전에 비즈니스 검증 로직을 추가.func updateDescription(userId: String, description: String) async throws {    guard validateStatusMessage(description) else {        throw ValidationError.invalidMessage    }    try await dbRepository.updateUser(userid: userId, key: &quot;description&quot;, value: description)}5. Mermaid 다이어그램sequenceDiagram    participant View as MyProfileView    participant ViewModel as MyProfileViewModel    participant Service as UserService    participant Repository as UserDBRepository    participant Firebase as Firebase    View-&gt;&gt;ViewModel: .task { await getUser() }    ViewModel-&gt;&gt;Service: getUser(userId)    Service-&gt;&gt;Repository: getUser(userId)    Repository-&gt;&gt;Firebase: 데이터 조회    Firebase--&gt;&gt;Repository: UserObject    Repository--&gt;&gt;Service: UserObject 변환    Service--&gt;&gt;ViewModel: User    ViewModel--&gt;&gt;View: userInfo 업데이트6. 코드 예시데이터 모델 변환extension UserObject {    func toModel() -&gt; User {        return User(            id: self.id,            name: self.name,            description: self.description,            createdAt: Date(timeIntervalSince1970: self.createdAt)        )    }}extension User {    func toObject() -&gt; UserObject {        return UserObject(            id: self.id,            name: self.name,            description: self.description,            createdAt: self.createdAt.timeIntervalSince1970        )    }}결론UserDBRepository와 UserService는 데이터베이스와 비즈니스 로직을 명확히 분리하여 코드의 유지보수성과 확장성을 높인다.  비즈니스 로직은 데이터를 검증하거나 변환하여 UI와 사용자 경험의 품질을 보장한다.">
    <meta itemprop="datePublished" content="2024-11-13T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="http://localhost:4000/SwiftUI-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-UserDBRepository-,-UserService-,-ViewModel-%EA%B3%84%EC%B8%B5%EC%9D%98-%EC%97%AD%ED%95%A0%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95/" class="u-url" itemprop="url">[SwiftUI] 프로젝트에서 <code class="language-plaintext highlighter-rouge">UserDBRepository</code>, <code class="language-plaintext highlighter-rouge">UserService</code>, <code class="language-plaintext highlighter-rouge">ViewModel</code> 계층의 역할과 사용법
</a>
          </h1>
          <footer class="page__meta">
            
  



  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags : </strong>
    <span class="archive__item-tags">
    
    
    
      <a class="posttag tagged" href="/posts/?tag=SwiftUI">SwiftUI</a>
    
    
    </span>  
  </p>



<!--  -->
            

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Date :</strong> <time class="dt-published" datetime="2024-11-13T00:00:00+00:00">November 13, 2024</time></p>

          </footer>
        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <h2 id="1-swiftui-프로젝트에서-userdbrepository-userservice-viewmodel-계층의-역할과-사용법">1. SwiftUI 프로젝트에서 <code class="language-plaintext highlighter-rouge">UserDBRepository</code>, <code class="language-plaintext highlighter-rouge">UserService</code>, <code class="language-plaintext highlighter-rouge">ViewModel</code> 계층의 역할과 사용법</h2>

<h2 id="목차">목차</h2>
<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">UserDBRepository</code>와 <code class="language-plaintext highlighter-rouge">UserService</code>의 개념 및 역할</strong></li>
  <li><strong>계층을 나눈 이유</strong></li>
  <li><strong>데이터 모델(User vs UserObject)의 차이점</strong></li>
  <li><strong>비즈니스 로직 정의와 예시</strong></li>
  <li><strong>Mermaid 다이어그램</strong></li>
  <li><strong>코드 예시</strong></li>
</ol>

<h2 id="userdbrepository">UserDBRepository</h2>
<p><code class="language-plaintext highlighter-rouge">UserDBRepository</code>는 데이터베이스에 직접적으로 접근하는 계층이다.  <br />
Firebase Realtime Database와 같은 외부 데이터베이스와의 통신을 담당하며, 데이터 추가 ,조회, 업데이트, 삭제 등의 CRUD 작업을 제공한다</p>

<h4 id="주요-역할">주요 역할</h4>
<ul>
  <li><strong>Firebase와의 직접 통신:</strong> Firebase 데이터베이스를 호출하여 데이터를 가져오거나 저장한다.</li>
  <li><strong>데이터 변환:</strong> 앱의 모델 데이터를 JSON 형식으로 변환하거나, 데이터베이스에서 가져온 데이터를 앱에서 사용할 수 있는 모델로 변환한다.</li>
  <li><strong>비동기 처리:</strong> Combine이나 async/await를 통해 비동기 작업을 처리한다</li>
</ul>

<h4 id="코드-예시">코드 예시</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">getUser</span><span class="p">(</span><span class="nv">userId</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UserObject</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="k">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="nf">child</span><span class="p">(</span><span class="kt">DBKey</span><span class="o">.</span><span class="kt">Users</span><span class="p">)</span><span class="o">.</span><span class="nf">child</span><span class="p">(</span><span class="n">userId</span><span class="p">)</span><span class="o">.</span><span class="nf">getData</span><span class="p">()</span><span class="o">.</span><span class="n">value</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">DBError</span><span class="o">.</span><span class="n">emptyValue</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">JSONSerialization</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">withJSONObject</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">UserObject</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="userservice">UserService</h3>
<p><code class="language-plaintext highlighter-rouge">UserService</code>는 앱의 비즈니스 로직을 담당하며, 뷰모델(ViewModel)과 데이터베이스 리포지토리(Repository) 사이의 중간 계층 역할을 한다. <code class="language-plaintext highlighter-rouge">UserDBRepository</code>에서 데이터를 가져와 가공하거나, 데이터를 업데이트 하기 전에 추가적인 로직을 처리한다.</p>

<h4 id="주요-역할-1">주요 역할</h4>
<ul>
  <li><strong>비즈니스 로직 처리:</strong> Repository에서 데이터를 가져온 후 추가적인 가공 또는 검증 로직을 수행한다.</li>
  <li><strong>모델 변환:</strong> 앱에서 사용하는 데이터 모델(User)와 데이터베이스 객체(UserObject)간의 변환을 수행한다.</li>
  <li><strong>의존성 주입:</strong> Repository를 주입받아 느슨한 결합(Lose Coupling)을 유지한다.</li>
</ul>

<h2 id="2-userdbrepository-userservice-계층을-나눈-이유">2. <code class="language-plaintext highlighter-rouge">UserDBRepository</code>, <code class="language-plaintext highlighter-rouge">UserService</code> 계층을 나눈 이유</h2>
<ol>
  <li><strong>책임 분리</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">UserDBRepository</code>는 데이터베이스에 직접 통신하는 역할을, <code class="language-plaintext highlighter-rouge">UserService</code>는 비즈니스 로직 처리를 담당한다.</li>
      <li>데이터베이스와 비즈니스 로직 간의 의존성을 줄여 각각 독립적으로 개발, 수정이 가능하다</li>
    </ul>
  </li>
  <li><strong>테스트 용이성</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">UserService</code>는 데이터베이스와 독립적으로 동작하므로, 단위 테스트에서 Mock이나 Stub을 사용해 테스트하기 용이하다.</li>
    </ul>
  </li>
  <li><strong>유연성 확보</strong>
    <ul>
      <li>데이터베이스가 Firebase에서 다른 데이터베이스로 변경되더라도 <code class="language-plaintext highlighter-rouge">UserDBRepository</code>만 수정하면 된다.</li>
      <li><code class="language-plaintext highlighter-rouge">UserService</code>와 <code class="language-plaintext highlighter-rouge">ViewModel</code>은 변경에 영향을 받지 않는다.</li>
    </ul>
  </li>
</ol>

<h2 id="3-앱에서-사용하는-데이터-모델user과-데이터베이스-객체userobject차이">3. 앱에서 사용하는 데이터 모델(User)과 데이터베이스 객체(UserObject)차이</h2>
<p><strong>UserObject:</strong></p>
<ul>
  <li>데이터베이스와 직접적으로 관련된 구조이다. 데이터베이스에 저장하거나 가져오는 형태로 디자인되어있다.</li>
  <li>데이터베이스와의 의존성이 있는 구조체로, 데이터 저장 형식(JSON, Dictionary등)에 최적화되어있다.</li>
  <li>예를 들어 Firebase Realtime Database는 Json 기반으로 데이터를 저장하므로, UserObject는 이러한 데이터 포멧을 고려한 구조를 가진다.</li>
  <li>ex) Double 타입으로 변환된 createdAt 값을 사용.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 데이터베이스와 통신하기 위해 설계된 데이터 모델</span>
<span class="c1">// 데이터베이스(Firebase 등)의 JSON 형식에 맞게 데이터를 저장하거나 읽어오기 위해 존재</span>
<span class="c1">// 단순하고 직렬화 가능(Codable)하도록 설계 </span>
<span class="c1">// -&gt; Codable 프로토콜을 사용해 JSON과 UserObject 간 변환을 쉽게 처리</span>
<span class="kd">struct</span> <span class="kt">UserObject</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">createdAt</span><span class="p">:</span> <span class="kt">Double</span> <span class="c1">// Firebase timestamp</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>User</strong></p>
<ul>
  <li>앱 내부에서 사용되는 모델로, UI와 비즈니스 로직에 맞게 설계되어 있다.</li>
  <li>데이터베이스와 무관하며, 앱의 화면 및 로직 처리에 필요한 형태와 속성을 가진다.</li>
  <li>ex) Date 타입으로 변환된 createdAt 값을 사용.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// UserObject에는 없는 추가적인 계산이나 데이터를 포함할 수 있다</span>
<span class="c1">// ex) 사용자 이름을 "Mr. DongHyeon Kim"형태로 가공하여 표시 가능</span>
<span class="kd">struct</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">createdAt</span><span class="p">:</span> <span class="kt">Date</span> <span class="c1">// Swift의 Date 객체</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="차이점-요약">차이점 요약</h2>
<ol>
  <li><strong>책임 분리</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">UserObject</code>는 데이터베이스와 통신하며, <code class="language-plaintext highlighter-rouge">User</code>는 앱의 비즈니스 로직 및 UI에 사용된다.</li>
    </ul>
  </li>
  <li><strong>유연성과 확장성</strong>
    <ul>
      <li>데이터베이스 변경 시 <code class="language-plaintext highlighter-rouge">UserObject</code>만 수정하면 되고, <code class="language-plaintext highlighter-rouge">User</code>는 변경되지 않는다.</li>
    </ul>
  </li>
  <li><strong>타입 안정성</strong>
    <ul>
      <li>JSON 데이터를 다루는 <code class="language-plaintext highlighter-rouge">UserObject</code>는 Firebase와의 호환성을, <code class="language-plaintext highlighter-rouge">User</code>는 앱에서의 타입 안전성을 보장한다.</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="4-비즈니스-로직-정의와-예시">4. 비즈니스 로직 정의와 예시</h2>

<h3 id="비즈니스-로직이란">비즈니스 로직이란?</h3>
<p><strong>비즈니스 로직</strong>은 소프트웨어에서 특정 도메인의 요구사항을 처리하기 위한 규칙, 절차, 계산, 데이터 처리 및 제약 조건을 정의하고 실행하는 코드이다.</p>

<ul>
  <li><strong>역할</strong>:
    <ul>
      <li>단순 데이터 저장 및 읽기 이상의 추가 처리(가공, 검증 등)를 담당.</li>
      <li>특정 도메인의 요구사항을 반영하여 데이터를 처리.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="userservice에서의-비즈니스-로직-예시">UserService에서의 비즈니스 로직 예시</h3>

<h4 id="예-1-사용자-상태-메시지-검증">예 1: 사용자 상태 메시지 검증</h4>
<p>사용자가 상태 메시지를 입력할 때 길이가 140자를 초과하지 않도록 제한.</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">validateStatusMessage</span><span class="p">(</span><span class="n">_</span> <span class="nv">message</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">message</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">140</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="예-2-firebase-시간-데이터를-로컬-시간으로-변환">예 2: Firebase 시간 데이터를 로컬 시간으로 변환</h4>
<p>Firebase에서 저장된 UTC 시간을 사용자의 로컬 시간으로 변환.</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">convertToUserLocalTime</span><span class="p">(</span><span class="nv">utcTimestamp</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Date</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">date</span> <span class="o">=</span> <span class="kt">Date</span><span class="p">(</span><span class="nv">timeIntervalSince1970</span><span class="p">:</span> <span class="n">utcTimestamp</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">userTimeZone</span> <span class="o">=</span> <span class="kt">TimeZone</span><span class="o">.</span><span class="n">current</span>
    <span class="k">let</span> <span class="nv">secondsFromGMT</span> <span class="o">=</span> <span class="n">userTimeZone</span><span class="o">.</span><span class="nf">secondsFromGMT</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">date</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">date</span><span class="o">.</span><span class="nf">addingTimeInterval</span><span class="p">(</span><span class="kt">Double</span><span class="p">(</span><span class="n">secondsFromGMT</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="예-3-데이터-업데이트-로직">예 3: 데이터 업데이트 로직</h4>
<p>상태 메시지를 업데이트하기 전에 비즈니스 검증 로직을 추가.</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">updateDescription</span><span class="p">(</span><span class="nv">userId</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="nf">validateStatusMessage</span><span class="p">(</span><span class="n">description</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">ValidationError</span><span class="o">.</span><span class="n">invalidMessage</span>
    <span class="p">}</span>
    <span class="k">try</span> <span class="k">await</span> <span class="n">dbRepository</span><span class="o">.</span><span class="nf">updateUser</span><span class="p">(</span><span class="nv">userid</span><span class="p">:</span> <span class="n">userId</span><span class="p">,</span> <span class="nv">key</span><span class="p">:</span> <span class="s">"description"</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="n">description</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="5-mermaid-다이어그램">5. Mermaid 다이어그램</h2>
<pre><code class="language-mermaid">sequenceDiagram
    participant View as MyProfileView
    participant ViewModel as MyProfileViewModel
    participant Service as UserService
    participant Repository as UserDBRepository
    participant Firebase as Firebase

    View-&gt;&gt;ViewModel: .task { await getUser() }
    ViewModel-&gt;&gt;Service: getUser(userId)
    Service-&gt;&gt;Repository: getUser(userId)
    Repository-&gt;&gt;Firebase: 데이터 조회
    Firebase--&gt;&gt;Repository: UserObject
    Repository--&gt;&gt;Service: UserObject 변환
    Service--&gt;&gt;ViewModel: User
    ViewModel--&gt;&gt;View: userInfo 업데이트
</code></pre>

<h3 id="6-코드-예시">6. 코드 예시</h3>
<h4 id="데이터-모델-변환">데이터 모델 변환</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">UserObject</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">toModel</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">User</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">User</span><span class="p">(</span>
            <span class="nv">id</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="nv">name</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="nv">description</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="nv">createdAt</span><span class="p">:</span> <span class="kt">Date</span><span class="p">(</span><span class="nv">timeIntervalSince1970</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">createdAt</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">toObject</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UserObject</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">UserObject</span><span class="p">(</span>
            <span class="nv">id</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="nv">name</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="nv">description</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="nv">createdAt</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">createdAt</span><span class="o">.</span><span class="n">timeIntervalSince1970</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="결론">결론</h2>
<p><code class="language-plaintext highlighter-rouge">UserDBRepository</code>와 <code class="language-plaintext highlighter-rouge">UserService</code>는 데이터베이스와 비즈니스 로직을 명확히 분리하여 코드의 유지보수성과 확장성을 높인다.  <br />
비즈니스 로직은 데이터를 검증하거나 변환하여 UI와 사용자 경험의 품질을 보장한다.</p>

        
      </section>

      

      
  <nav class="pagination">
    
      <a href="/Combine-Framework/" class="pagination--pager" title="[Combine] 개념 및 예제
">Previous</a>
    
    
      <a href="/SwiftUI-calendar/" class="pagination--pager" title="[SwiftUI] Calendar 구현
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/indextrown" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 indextrown. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

<script src="/assets/js/jqcloud.min.js" charset="utf-8"></script>
      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>



    <script>
  'use strict';

  var theme = localStorage.getItem('theme');

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'indextrown/indextrown.github.io');
    script.setAttribute('issue-term', 'pathname');
    

    if (theme === 'dark') {
      script.setAttribute('theme', 'github-dark');
    } else {
      script.setAttribute('theme', 'github-light');
    }
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





    <aside class="sidebar__home">
      <a href="/posts">
        <div style="font-size: 0.5rem;"><i class="fas fa-h-square fa-5x"></i></div>
      </a>
    </aside>

    <aside class="sidebar__top">
      <a href="#site-nav">
        <div style="font-size: 0.5rem;"><i class="fas fa-caret-square-up fa-5x"></i></div>
      </a>
    </aside>

    <aside class="sidebar__bottom">
      <a href="#footer">
        <div style="font-size: 0.5rem;"><i class="fas fa-caret-square-down fa-5x"></i></div>
      </a>
    </aside>

  </body>
</html>
