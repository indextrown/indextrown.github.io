var store = [{
        "title": "[ReactiveX] 1. 반응형 프로그래밍이란?",
        "excerpt":"   1. 반응형 프로그래밍이란?  데이터의 흐름 및 변경사항을 전파하는 데 중점을 둔 프로그래밍 패러다임이다.     이 패러다임을 사용할 경우, 주변 환경/데이터 변화가 생길 때 연결된 실행 모델들이 이 이벤트를 받아 동작하도록 설계하는 방식이다.      선(→) : 데이터가 흐르는 경로이며, Observable이라고 부른다.   점(●) : 시간에 따라 발생하는 이벤트(Event) 하나를 의미한다.   debounce 박스 : 이벤트를 필터링하는 Operator(연산자)로, 너무 잦은 이벤트를 제어한다.   아래쪽 선 : debounce 이후 실제로 구독자에게 전달되는 결과 흐름을 보여준다.   비유로 설명  자동차(Event)들이 도로(Ovservable)를 따라 달리고 있을 때,  교통경찰 역할을 하는 debounce가 너무 많은 차를 제어해준다.    지나치게 빠르게 지나가는 차들은 걸러내고, 일정 시간 동안 마지막으로 지나간 차(이벤트)만 통과시킨다.    즉 이벤트가 여러 번 발생하더라도 debounce를 통과한 이벤트만 최종적으로 전달한다.   2. RxSwift란?  Reactive Extension/Programming + Swift로, 관찰 가능한 시퀀스를 사용하여 비동기 및 이벤트 기반 프로그램을 구성하기 위한 라이브러리다.   Swift는 함수형 프로그래밍(Functional Programming) 패러다임을 강조하는 언어이다.     이에 RxSwift는 반응형 프로그래밍(Reactive Programming)을 더하여, Swift에서 FRP(Functional Reactive Programming)을 따를 수 있도록 한다.    즉 Swift를 반응형 프로그래밍 하는 것이다.   예시  Observable     .combineLatest(firstName.rx.text, lastName.rx.text) {  $0 + \" \" $1 }     .map { \"Greetings, \\(#0)\" }     .bind(to: greetingLabel.rx.text)     .disposed(by: DisposeBag)     comBineLatest나 map을 RxSwift에서 Operator라고 부른다.   이러한 연산자를 사용해서 이벤트의 값을 여러 형태로 조합하거나 변경할 수 있다.   또한 MVVM패턴을 적용할 때 View와 ViewModel을 연결해주는, 데이터 바인딩을 수행해야 한다.    이때 bind(정확히 말하자면 bind는 RxCocoa이다) 연산자를 사용하여 쉽게 바인딩이 가능하다.     DisoatchQueue에서 직접 조정해야 했던 작업들을 자동으로 처리해준다.   3. RxSwift 사용 목적  func doSomethingIncredible(forWho: String) throws -&gt; IncredibleThing  // 재시도 doSomethingIncredible(\"me\")     .retry(3)     API 통신을 하다보면, 성공할 때도 있지만 실패할 때도 분명 존재한다.   실패시 단순히 끝나는게 아니라 3번 정도 재시도 할 수 있다면 좋겠지만 재시도 코드는 많이 복잡하고, 재사용하기도 어렵다.   RxSwift를 사용하면 retry연산자를 사용해 쉽게 재시도 코드를 작성할 수 있다.   4. Combine도 같은 개념이다   Swift에서 RxSwift와 동일한 반응형 프로그래밍을 지원하는 Apple 공식 프레임워크가 Combine이다.  Cimbine은 iOS 13부터 내장되어 있으며, RxSwift와 거의 동일한 비동기 이벤트 스트림을 처리할 수 있다.                  개념       RxSwift       Combine                       데이터 스트림       Observable       Publisher                 구독       subscribe()       sink()                 데이터 조작       map, filter, flatMap, combineLatest 등       동일                 메모리 해제       DisposeBag       AnyCancellable (store in Set)                 비동기 이벤트 처리       가능       가능           import Combine  // 텍스트 필드 두 개를 결합해서 라벨에 표시 Publishers.CombineLatest(firstNamePublisher, lastNamePublisher)     .map { \"Greetings, \\($0) \\($1)\" }     .sink { [weak self] in self?.greetingLabel.text = $0 }     .store(in: &amp;cancellables)    Reference     https://velog.io/@gnwjd309/RxSwift-1   https://reactivex.io/intro.html   https://github.com/ReactiveX/RxSwift   https://babbab2.tistory.com/182   https://ios-development.tistory.com/95  ","categories": [],
        "tags": ["ReactiveX","RxSwift","Combine"],
        "url": "/ReactiveX-ReactiveX-1/",
        "teaser": "/assets/img/2025-03-25-%5BRxSwift%5D-RxSwift-1/image.png"
      },{
        "title": "[Combine] 2. 개념 및 예제",
        "excerpt":"  Combine이란  2019년에 Apple에서 출시한 비동기처리 이벤트를 처리하기 위한 first-party 프레임워크이다.    Combine은 앱 내에서 일어나는 이벤트들의 진행 결과 등을 선언적으로 코딩할 수 있게끔 도와준다.    어떠한 이벤트를 추적할 때 Delegate패턴을 사용하거나, Completion 클로저를 사용하는 대신 Combine을 활용해볼 수 있다.   Combine 주요 개념  Stream     데이터의 흐름이라고도 부르며 시간에 따라 순차적으로 전달되는 값들의 흐름이다   이 데이터는 비동기적으로 전달가능하다   전달 과정에서 변환, 필터링, 결합 등이 가능하다   Publisher     데이터를 만들어내고 이를 스트림 형태로 방출한다   값을 방출하거나 성공적으로 완료하거나 오류로 실패한다   Subscriber     Publisher로부터 완료 신호를 수신하는 역할을 한다   Publisher가 방출하는 값을 처리하고, 완료나 실패 이벤트를 받으면 스트림을 정리한다   Operator     Publisher가 생성하는 이벤트를 변환하거나 처리하는 데 사용된다   map, filter, reduce등의 연산자가 존재한다   연산자를 사용하면 복잡한 비동기 작업을 쉽게 구성할 수 있다   sink     Combine 퍼블리셔(Publisher)에서 방출된 데이터를 소비(consume)하기 위해 사용하는 구독자(Subscriber)이다   퍼블리셔가 내보내는 데이터를 받아서 처리하는 역할을 한다   sink를 호출하면 퍼블리셔를 구독한다   sink 메서드는 두 가지 클로저를 전달받는다   receiveCompletion: 스트림이 종료될 때(완료 또는 에러 발생 시) 호출되는 클로저   receiveValue: 스트림에서 방출된 값을 처리하는 클로저   receiveCompletion     sink 메서드의 첫번째 클로저   스트림이 종료(completion) 또는 에러 발생시 호출   두가지 상태를 처리한다   finished(스트림 정상 종료)   failure(스트림에서 에러가 발생하여 종료)   receiveValue     sink메서드의 두번째 클로저   퍼블리셔가 방출한 값을 받을 때 호출   여기서 값을 처리하거나 화면에 표시하는 등의 작업을 수행   .store(in: &amp;cancellables)     sink 연산자로 반환된 AnyCancellable 객체를 cancellables에 저장한다   스트림이 종료되거나 cancellables가 해제되면 자동으로 구독이 취소된다   cancellables:     Set 타입의 저장소이다   여기 저장된 AnyCancellable 객체는 구독이 유지되는 동안 메모리에서 해제되지 않도록 보장한다   스트림의 중요한 특징     시간 기반(스트림은 데이터가 시간에 따라 순차적으로 흘러가는 형태)   비동기 처리(스트림은 데이터가 준비될 때마다 이벤트 발생시키므로 비동기 작업과 어울림)   연속성(데이터가 중단되지 않고 계속 흐를 수도 있고, 완료(completion) 또는 에러(error)가 발생하여 종료될 수 있다   예제   예제 1) sink     AnyCancellable 객체를 반환한다   퍼블리셔와 구독자의 생명주기를 관리하는 데 사용된다   구독 취소 전까지 스트림이 유지된다   AnyCancellable을 저장하지 않으면 구독이 즉시 해제되어 데이터 스트림이 동작하지 않는다   // AnyCancellable을 저장할 곳 var cancellables = Set&lt;AnyCancellable&gt;()          // 퍼블리셔 let stream = [1, 2, 3].publisher  stream     .sink { completion in         print(\"스트림 완료: \\(completion)\")     } receiveValue: { value in         print(\"받은 값: \\(value)\")     }     // 구독 저장(반환된 AnyCancellable 저장)     .store(in: &amp;cancellables)  /* 받은 값: 1 받은 값: 2 받은 값: 3 스트림 완료: finished */  예제 2) Fail  // 커스텀 에러 타입 정의 enum MyError: Error {     case testError }  // AnyCancellable을 저장할 곳 var cancellables = Set&lt;AnyCancellable&gt;()  // 퍼블리셔 let publisher = Fail&lt;Int, MyError&gt;(error: .testError)  publisher     .sink { completion in         switch completion {         case .finished:             print(\"스트림 완료\")         case .failure(let error):             print(\"스트림 에러 (항상)발생: \\(error)\")         }     } receiveValue: { value in         print(\"받은 값: \\(value)\")     }     .store(in: &amp;cancellables)  // 스트림 에러 (항상)발생: testError   예제 3) Just     단 하나의 값을 방출하는 Publisher   값을 방출한 후 즉시 완료(finished)된다   실패하지 않는다(Failure 타입이 Never)   var cancellables = Set&lt;AnyCancellable&gt;()          let justPublisher = Just(100)  let subscription = justPublisher.sink { completion in     print(\"완료: \\(completion)\") } receiveValue: { value in     print(\"받은 값: \\(value)\") }  /* 받은 값: 100 완료: finished */   예제 4) Empty     값을 생성하지 않고 완료만 하는 Publisher   에러 없이(failure == Never) 종료한다   주로 기본값이 없거나, 특정 조건에서 Publisher를 반환해야 할 때 사용된다   var cancellables = Set&lt;AnyCancellable&gt;()          let emptyPublisher = Empty&lt;Int, Never&gt;()  emptyPublisher.sink { completion in     print(\"완료: \\(completion)\") } receiveValue: { value in     print(\"받은 값: \\(value)\") }.store(in: &amp;cancellables)  // 완료: finished  예제 5) Future     비동기 작업을 처리할 때 유용   ex) 네트워크 요청, 파일 읽기, 데이터베이스 작업   한번만 값을 방출(Just와 유사하지만 비동기적으로 동작)   성공(.success(value)) 또는 실패(.failure(error))로 완료됨   import Combine import SwiftUI  func fetchData() -&gt; Future&lt;String, Error&gt; {     return Future { promise in         DispatchQueue.global().asyncAfter(deadline: .now() + 2) {             // let success = Bool.random()             let success = false                          if success {                 promise(.success(\"데이터 가져오기 성공\"))             } else {                 promise(.failure(URLError(.badServerResponse)))             }         }     } }  // AnyCancellable을 저장할 곳 var cancellables = Set&lt;AnyCancellable&gt;()  let cancellable = fetchData()     .sink { completion in         switch completion {         case .finished:             print(\"스트림 완료\")         case .failure(let error):             print(\"에러 발생: \\(error)\")         }     } receiveValue: { value in         print(\"받은 값: \\(value)\")     }.store(in: &amp;cancellables)  // RunLoop를 사용해 비동기 작업 대기 RunLoop.main.run(until: Date(timeIntervalSinceNow: 5))   // 1. 구독 저장소 var cancellables = Set&lt;AnyCancellable&gt;()  // 2. 비동기 작업을 수행하는 Future Publisher 생성 let futurePublisher = Future&lt;Int, Error&gt; { promise in     DispatchQueue.global().asyncAfter(deadline: .now() + 1) {         let result = 42 // 비동기 작업 결과         promise(.success(result)) // 성공적으로 값을 방출     } }  // 3. 구독 시작 및 결과 처리 futurePublisher     .sink { completion in         switch completion {         case .finished:             print(\"스트림 완료\")         case .failure(let error):             print(\"에러 발생: \\(error.localizedDescription)\")         }     } receiveValue: { value in         print(\"받은 값: \\(value)\")     }     .store(in: &amp;cancellables) // 구독 유지  // RunLoop를 사용해 비동기 작업 대기 RunLoop.main.run(until: Date(timeIntervalSinceNow: 2))    ","categories": [],
        "tags": ["ReactiveX","Combine"],
        "url": "/Combine-Framework/",
        "teaser": "/assets/img/Combine/Combine.png"
      },{
        "title": "[SwiftUI] 프로젝트에서 `UserDBRepository`, `UserService`, `ViewModel` 계층의 역할과 사용법",
        "excerpt":"1. SwiftUI 프로젝트에서 UserDBRepository, UserService, ViewModel 계층의 역할과 사용법   목차     UserDBRepository와 UserService의 개념 및 역할   계층을 나눈 이유   데이터 모델(User vs UserObject)의 차이점   비즈니스 로직 정의와 예시   Mermaid 다이어그램   코드 예시   UserDBRepository  UserDBRepository는 데이터베이스에 직접적으로 접근하는 계층이다.    Firebase Realtime Database와 같은 외부 데이터베이스와의 통신을 담당하며, 데이터 추가 ,조회, 업데이트, 삭제 등의 CRUD 작업을 제공한다   주요 역할     Firebase와의 직접 통신: Firebase 데이터베이스를 호출하여 데이터를 가져오거나 저장한다.   데이터 변환: 앱의 모델 데이터를 JSON 형식으로 변환하거나, 데이터베이스에서 가져온 데이터를 앱에서 사용할 수 있는 모델로 변환한다.   비동기 처리: Combine이나 async/await를 통해 비동기 작업을 처리한다   코드 예시  func getUser(userId: String) async throws -&gt; UserObject {     guard let value = try await self.db.child(DBKey.Users).child(userId).getData().value else {         throw DBError.emptyValue     }     let data = try JSONSerialization.data(withJSONObject: value)     return try JSONDecoder().decode(UserObject.self, from: data) }     UserService  UserService는 앱의 비즈니스 로직을 담당하며, 뷰모델(ViewModel)과 데이터베이스 리포지토리(Repository) 사이의 중간 계층 역할을 한다. UserDBRepository에서 데이터를 가져와 가공하거나, 데이터를 업데이트 하기 전에 추가적인 로직을 처리한다.   주요 역할     비즈니스 로직 처리: Repository에서 데이터를 가져온 후 추가적인 가공 또는 검증 로직을 수행한다.   모델 변환: 앱에서 사용하는 데이터 모델(User)와 데이터베이스 객체(UserObject)간의 변환을 수행한다.   의존성 주입: Repository를 주입받아 느슨한 결합(Lose Coupling)을 유지한다.   2. UserDBRepository, UserService 계층을 나눈 이유     책임 분리            UserDBRepository는 데이터베이스에 직접 통신하는 역할을, UserService는 비즈니스 로직 처리를 담당한다.       데이터베이스와 비즈니스 로직 간의 의존성을 줄여 각각 독립적으로 개발, 수정이 가능하다           테스트 용이성            UserService는 데이터베이스와 독립적으로 동작하므로, 단위 테스트에서 Mock이나 Stub을 사용해 테스트하기 용이하다.           유연성 확보            데이터베이스가 Firebase에서 다른 데이터베이스로 변경되더라도 UserDBRepository만 수정하면 된다.       UserService와 ViewModel은 변경에 영향을 받지 않는다.           3. 앱에서 사용하는 데이터 모델(User)과 데이터베이스 객체(UserObject)차이  UserObject:     데이터베이스와 직접적으로 관련된 구조이다. 데이터베이스에 저장하거나 가져오는 형태로 디자인되어있다.   데이터베이스와의 의존성이 있는 구조체로, 데이터 저장 형식(JSON, Dictionary등)에 최적화되어있다.   예를 들어 Firebase Realtime Database는 Json 기반으로 데이터를 저장하므로, UserObject는 이러한 데이터 포멧을 고려한 구조를 가진다.   ex) Double 타입으로 변환된 createdAt 값을 사용.   // 데이터베이스와 통신하기 위해 설계된 데이터 모델 // 데이터베이스(Firebase 등)의 JSON 형식에 맞게 데이터를 저장하거나 읽어오기 위해 존재 // 단순하고 직렬화 가능(Codable)하도록 설계  // -&gt; Codable 프로토콜을 사용해 JSON과 UserObject 간 변환을 쉽게 처리 struct UserObject: Codable {     var id: String     var name: String     var description: String     var createdAt: Double // Firebase timestamp }   User     앱 내부에서 사용되는 모델로, UI와 비즈니스 로직에 맞게 설계되어 있다.   데이터베이스와 무관하며, 앱의 화면 및 로직 처리에 필요한 형태와 속성을 가진다.   ex) Date 타입으로 변환된 createdAt 값을 사용.   // UserObject에는 없는 추가적인 계산이나 데이터를 포함할 수 있다 // ex) 사용자 이름을 \"Mr. DongHyeon Kim\"형태로 가공하여 표시 가능 struct User {     var id: String     var name: String     var description: String     var createdAt: Date // Swift의 Date 객체 }     차이점 요약     책임 분리            UserObject는 데이터베이스와 통신하며, User는 앱의 비즈니스 로직 및 UI에 사용된다.           유연성과 확장성            데이터베이스 변경 시 UserObject만 수정하면 되고, User는 변경되지 않는다.           타입 안정성            JSON 데이터를 다루는 UserObject는 Firebase와의 호환성을, User는 앱에서의 타입 안전성을 보장한다.             4. 비즈니스 로직 정의와 예시   비즈니스 로직이란?  비즈니스 로직은 소프트웨어에서 특정 도메인의 요구사항을 처리하기 위한 규칙, 절차, 계산, 데이터 처리 및 제약 조건을 정의하고 실행하는 코드이다.      역할:            단순 데이터 저장 및 읽기 이상의 추가 처리(가공, 검증 등)를 담당.       특정 도메인의 요구사항을 반영하여 데이터를 처리.             UserService에서의 비즈니스 로직 예시   예 1: 사용자 상태 메시지 검증  사용자가 상태 메시지를 입력할 때 길이가 140자를 초과하지 않도록 제한.  func validateStatusMessage(_ message: String) -&gt; Bool {     return message.count &lt;= 140 }   예 2: Firebase 시간 데이터를 로컬 시간으로 변환  Firebase에서 저장된 UTC 시간을 사용자의 로컬 시간으로 변환.  func convertToUserLocalTime(utcTimestamp: Double) -&gt; Date {     let date = Date(timeIntervalSince1970: utcTimestamp)     let userTimeZone = TimeZone.current     let secondsFromGMT = userTimeZone.secondsFromGMT(for: date)     return date.addingTimeInterval(Double(secondsFromGMT)) }   예 3: 데이터 업데이트 로직  상태 메시지를 업데이트하기 전에 비즈니스 검증 로직을 추가.  func updateDescription(userId: String, description: String) async throws {     guard validateStatusMessage(description) else {         throw ValidationError.invalidMessage     }     try await dbRepository.updateUser(userid: userId, key: \"description\", value: description) }     5. Mermaid 다이어그램  sequenceDiagram     participant View as MyProfileView     participant ViewModel as MyProfileViewModel     participant Service as UserService     participant Repository as UserDBRepository     participant Firebase as Firebase      View-&gt;&gt;ViewModel: .task { await getUser() }     ViewModel-&gt;&gt;Service: getUser(userId)     Service-&gt;&gt;Repository: getUser(userId)     Repository-&gt;&gt;Firebase: 데이터 조회     Firebase--&gt;&gt;Repository: UserObject     Repository--&gt;&gt;Service: UserObject 변환     Service--&gt;&gt;ViewModel: User     ViewModel--&gt;&gt;View: userInfo 업데이트   6. 코드 예시  데이터 모델 변환  extension UserObject {     func toModel() -&gt; User {         return User(             id: self.id,             name: self.name,             description: self.description,             createdAt: Date(timeIntervalSince1970: self.createdAt)         )     } }  extension User {     func toObject() -&gt; UserObject {         return UserObject(             id: self.id,             name: self.name,             description: self.description,             createdAt: self.createdAt.timeIntervalSince1970         )     } }     결론  UserDBRepository와 UserService는 데이터베이스와 비즈니스 로직을 명확히 분리하여 코드의 유지보수성과 확장성을 높인다.    비즈니스 로직은 데이터를 검증하거나 변환하여 UI와 사용자 경험의 품질을 보장한다.  ","categories": [""],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-UserDBRepository-,-UserService-,-ViewModel-%EA%B3%84%EC%B8%B5%EC%9D%98-%EC%97%AD%ED%95%A0%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[SwiftUI] Calendar 구현",
        "excerpt":"SwiftUI에서 제공하는 캘린더   SwiftUI에서 제공하는 DatePicker를 사용하여 간단한 캘린더를 구현할 수 있습니다.             import SwiftUI  struct ProfileView: View {     @State private var selectedDate = Date()          var body: some View {         VStack {             Text(\"선택한 날짜: \\(selectedDate, formatter: dateFormatter)\")                 .padding()                          DatePicker(                 \"Start Date\",                 selection: $selectedDate,                 displayedComponents: [.date]                    // 날짜만 표시 (시간은 제외)             )             .datePickerStyle(GraphicalDatePickerStyle())        // 그래픽 스타일             .environment(\\.locale, Locale(identifier: \"ko_KR\")) // 한국 로케일 설정                          Spacer()         }     }          // 날짜 형식을 지정하기 위한 Formatter    private var dateFormatter: DateFormatter {        let formatter = DateFormatter()        formatter.dateStyle = .medium        return formatter    } }  #Preview {     ProfileView() }                              위 코드와 이미지를 참고하여 SwiftUI에서 제공하는 DatePicker의 기본적인 사용법을 익혀보세요.   ","categories": [""],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-calendar/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[SwiftUI] Animation 구현",
        "excerpt":"SwiftUI에서 제공하는 애니메이션             import SwiftUI  // MARK: - 애니메이션 struct AnimationView: View {     @State var currentTab: Int  // 현재 선택된 탭의 인덱스          // MARK: - NAMESPACE     @Namespace var namespace          let text = [\"hello\", \"world\", \"my\", \"name\", \"is\", \"index\"]     var body: some View {         HStack(spacing: -50) {             ForEach(text.indices, id: \\.self) { index in                 let title = text[index]                 UnderBarItem(currentTab: $currentTab,                               title: title,                              tab: index,                              namespace: namespace                 )             }         }     } }  struct UnderBarItem: View {     @Binding var currentTab: Int    // 부모 뷰에서 전달받은 선택된 탭의 인덱스     var title: String     var tab: Int                    // 각 버튼이 고유하게 가지는 인덱스          // MARK: - NAMESPACE     let namespace: Namespace.ID          var body: some View {         Button {             currentTab = tab        // SwuftUI는 currentTab변경을 감지하여 뷰를 다시 렌더링 한다         } label: {             VStack {                 Text(title)                 if currentTab == tab {  // 터치된 버튼이면 언더바 표시                     Color.black                         .frame(height: 2)                         .padding(.horizontal, 30)                         // MARK: - NAMESPACE                         .matchedGeometryEffect(id: \"underline\", in: namespace.self)                 } else {                     Color.clear                         .frame(height: 2)                         .padding(.horizontal, 30)                 }             }             // response: 애니메이션의 지속 시간.             // dampingFraction: 감속의 강도 (0에 가까울수록 많이 진동).             // blendDuration: 애니메이션이 다른 변경 사항과 섞이는 데 걸리는 시간.             .animation(.spring(response: 0.5, dampingFraction: 0.7, blendDuration: 0.5), value: currentTab)             //.animation(.spring(), value: currentTab)    // value가 변할 때 애니메이션 적용         }     } }  #Preview {     AnimationView(currentTab: 0) }                               위 코드와 이미지를 참고하여 SwiftUI에서 제공하는 애니메이션의 기본적인 사용법을 익혀보세요.   ","categories": [""],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-Animation/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[SwiftUI] List + 기본 TextField 문제점",
        "excerpt":"📌 1. 기존 문제 원인 분석 (SwiftUI List + 기본 TextField)   ✅ 원인 1: SwiftUI TextField가 List와 충돌     List는 UIKit의 UITabView를 래핑한 SwiftUI 컴포넌트이다.   SwiftUI의 TextField는 입력시 상태 @Binding var text가 변경될 때마다 전체 List를 다시 그릴 수 있다.   이 과정에서 SwiftUI가 배경을 다시 렌더링하면서 검은색 잔상이 나타나게 된다.     ➡ 즉, List가 자동으로 다시 그려지면서 백그라운드 깜빡임이 발생한다       struct ErrorMainTabView: View {     @State var searchText: String     var body: some View {                  ZStack {             Color.mainBlack                 .ignoresSafeArea()                          VStack {                 TextField(\"검색\", text: $searchText)                     .padding()                     .background(Color.subBlack)                     .cornerRadius(10)                     .padding()                                  List {                     Section(header:                         Text(\"Numbers\")                         .foregroundColor(Color.mainGreen)                         .font(.system(size: 17, weight: .bold))                         .padding(.leading, -10)                     ) {                         ForEach(0...5, id: \\.self) { memo in                             Button {                                                              } label: {                                 Text(String(memo))                                     .foregroundColor(.white) // ✅ 텍스트 색상                                     .frame(maxWidth: .infinity, alignment: .leading) // ✅ 왼쪽 정렬                                                              }                             .listRowBackground(Color.subBlack) // ✅ 각 행의 배경색 지정                             .listRowSeparatorTint(Color.gray.opacity(0.4), edges: .bottom) // ✅ 구분선 색상 지정                         }                     }                 }                 .scrollContentBackground(.hidden) // ✅ 리스트 기본 배경 제거                 .background(Color.mainBlack) // ✅ 전체 리스트 배경 변경             }         }     } }   📌 2. 커스텀 UITextField를 사용했을 때 해결   ✅ 해결된 원인 1: UITextField는 List를 리렌더링하지 않음     UITextField는 UIKit 기반이므로, 입력 시 List를 다시 렌더링하지 않음.   SwiftUI의 TextField와 달리, @Binding 값이 바뀌어도 SwiftUI 전체 뷰를 다시 그리지 않음.   즉, UITextField를 사용하면서 List의 불필요한 리렌더링이 사라짐.     ➡ 커스텀 UITextField를 사용하면 SwiftUI의 TextField가 가지던 불필요한 리렌더링 문제를 방지할 수 있다.      struct CustomTextField: UIViewRepresentable {  @Binding var text: String  var placeholder: String  var horizontalPadding: CGFloat = 15 // ✅ 좌우 패딩 값을 하나의 변수로 추가   final class Coordinator: NSObject, UITextFieldDelegate {      var parent: CustomTextField       init(parent: CustomTextField) {          self.parent = parent      }       func textFieldDidChangeSelection(_ textField: UITextField) {          parent.text = textField.text ?? \"\"      }       func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {          textField.resignFirstResponder() // ✅ 엔터 누르면 키보드 닫기          return true      }  }   func makeCoordinator() -&gt; Coordinator {      return Coordinator(parent: self)  }   func makeUIView(context: Context) -&gt; UITextField {      let textField = UITextField()      textField.delegate = context.coordinator      textField.placeholder = placeholder      textField.backgroundColor = UIColor(Color.subBlack)      textField.layer.cornerRadius = 10      textField.textColor = .white      textField.returnKeyType = .done       // ✅ 좌측 패딩 추가      let leftPaddingView = UIView(frame: CGRect(x: 0, y: 0, width: horizontalPadding, height: textField.frame.height))      textField.leftView = leftPaddingView      textField.leftViewMode = .always       // ✅ 우측 패딩 추가      let rightPaddingView = UIView(frame: CGRect(x: 0, y: 0, width: horizontalPadding, height: textField.frame.height))      textField.rightView = rightPaddingView      textField.rightViewMode = .always       textField.addTarget(context.coordinator, action: #selector(Coordinator.textFieldDidChangeSelection(_:)), for: .editingChanged)      return textField  }   func updateUIView(_ uiView: UITextField, context: Context) {      uiView.text = text      uiView.placeholder = placeholder  }       // ✅ 외부 터치 시 키보드를 닫는 메서드 추가  static func hideKeyboard() {      UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)  } }          ","categories": [],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-List-+-%EA%B8%B0%EB%B3%B8-TextField-%EB%AC%B8%EC%A0%9C%EC%A0%90/",
        "teaser": "/assets/img/Swift/SwiftWhite.png"
      },{
        "title": "[SwiftUI] TabView",
        "excerpt":"기본 TabView     사용목적: 여러 개의 화면을 탭으로 관리할 수 있다.   제약사항: TabView에는 자체적으로 배경색을 변경할 수 있는 modifier가 없다.   UITabBar.appearance().backgroundColor = .white 같은 UIKit 코드를 사용해야 한다.   원하는 디자인을 만들기 위해 번거러운 작업이 필요하다.         import SwiftUI  struct ContentView: View {     @State private var selectedTab = 0      var body: some View {         TabView(selection: $selectedTab) {             Text(\"홈 화면\")                 .tabItem {                     Image(systemName: \"house.fill\")                     Text(\"홈\")                 }                 .tag(0)                  Text(\"검색 화면\")                 .tabItem {                     Image(systemName: \"magnifyingglass\")                     Text(\"검색\")                 }                 .tag(1)                  Text(\"설정 화면\")                 .tabItem {                     Image(systemName: \"gearshape.fill\")                     Text(\"설정\")                 }                 .tag(2)         }     } }                   커스텀 탭뷰   커스텁 탭뷰 타입  enum MainTabType: CaseIterable {     case csView     case iosView     case aosView     case profileView          var title: String {         switch self {         case .csView:             return \"CS\"         case .iosView:             return \"iOS\"         case .aosView:             return \"aOS\"         case .profileView:             return \"profile\"         }     }          func imageName(isSelected: Bool) -&gt; String {         switch self {         case .csView:             return isSelected ? \"desktopcomputer\" : \"desktopcomputer\"         case .iosView:             return isSelected ? \"apple.logo\" : \"apple.logo\"         case .aosView:             return isSelected ? \"smartphone\" : \"smartphone\"         case .profileView:             return isSelected ? \"person.fill\" : \"person\"         }     } }  커스텀 탭뷰  struct CustomMaintabView: View {          @State private var selectedTab: MainTabType = .csView          var body: some View {         ZStack {             Color.black                          VStack(spacing: 0) {                 switch selectedTab {                 case .csView:                     CSView()                 case .iosView:                     iOSView()                 case .aosView:                     AosView()                 case .profileView:                     ProfileView()                 }             }              VStack(spacing: 0) {                 Spacer()                                  Rectangle()                     .fill(Color.gray.opacity(0.3))                     .frame(height: 1)                                  HStack {                     ForEach(MainTabType.allCases, id: \\.self) { tab in                                                  Spacer()                             .frame(width: 10)                                                  VStack {                             Spacer()                                 .frame(height: 5)                             Image(systemName: tab.imageName(isSelected: selectedTab == tab))                                 .font(.system(size: 24))                                 .foregroundColor(selectedTab == tab ? .white : .gray)                             Text(tab.title)                                 .font(.caption2)                                 .foregroundColor(selectedTab == tab ? .white : .gray)                             Spacer()                                 .frame(height: 20)                         }                         .padding(.horizontal, 20) // 좌우 터치 영역 추가                         .frame(maxWidth: .infinity)                         .contentShape(Rectangle()) // 터치 가능한 영역을 명시적으로 지정                         .onTapGesture {                             // 진동 발생                             let generator = UIImpactFeedbackGenerator(style: .medium)                             generator.impactOccurred()                             selectedTab = tab                         }                         Spacer()                             .frame(width: 10)                     }                     .frame(height: 100) // 고정 높이                 }                 .background(.black)             }         }         .ignoresSafeArea(edges: .all)     } }  ","categories": [],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-TabView/",
        "teaser": "/assets/img/Swift/SwiftWhite.png"
      },{
        "title": "[Firebase] cloud functions",
        "excerpt":"Cloud Functions     Cloud Functions는 Firebase의 기능과 HTTP 요청에 의해서 Trigger 되는 이벤트에 응답하여 백엔드 코드를 자동으로 실행시켜주는 서버리스 프레임워크   ✅ 1. Firebase Cloud Functions 설정     먼저 Firebase CLI를 설치하고 프로젝트에 Cloud Functions를 추가   # Firebase CLI 설치 (설치 안 되어 있다면) brew install firebase-cli  # 설치가 끝나면 아래 명령어로 정상적으로 설치되었는지 확인 firebase --version  # Firebase 로그인 firebase login  # Firebase Functions 초기화 firebase init functions  # 환경변수 추가 (필요할 경우) echo 'export PATH=\"/opt/homebrew/bin:$PATH\"' &gt;&gt; ~/.zshrc source ~/.zshrc   ✅ 2. (Gmail + Nodemailer 사용)     Google 앱 비밀번호에서 비밀번호를 생성   Gmail -&gt; 설정 -&gt; 전달 및 POP/IMAP -&gt; IMAP 사용   ✅ 3. Cloud Functions 코드 작성 (index.js)     Gmail + Nodemailer를 활용   ✅ 닉네임이 처음 생성될 때만 이메일 전송 + 구글 시트 추가   ✅ 닉네임이 변경되거나 다른 정보가 변경될 경우, 이메일 없이 시트만 업데이트   ✅ 유저가 삭제되면 ‘탈퇴’로 표시   const { onValueUpdated, onValueDeleted } = require(\"firebase-functions/v2/database\"); const admin = require(\"firebase-admin\"); const { google } = require(\"googleapis\"); const nodemailer = require(\"nodemailer\");  admin.initializeApp();  // ✅ Gmail 설정 (앱 비밀번호 사용) const GMAIL_EMAIL = \"indextrown@gmail.com\"; const GMAIL_PASSWORD = \"\";  // ✅ Nodemailer 설정 const transporter = nodemailer.createTransport({     host: \"smtp.gmail.com\",     port: 465,     secure: true,     auth: {         user: GMAIL_EMAIL,         pass: GMAIL_PASSWORD     },     tls: {         rejectUnauthorized: false     } });  // ✅ Google Sheets API 설정 const SHEET_ID = \"\"; const SCOPES = [\"https://www.googleapis.com/auth/spreadsheets\"]; const keyFilePath = \"/workspace/codeloungeusers-a47a950f7b06.json\";  async function getGoogleSheetsClient() {     const auth = new google.auth.GoogleAuth({         keyFile: keyFilePath,         scopes: SCOPES     });     return google.sheets({ version: \"v4\", auth }); }  // ✅ 유저 정보를 구글 시트에 업데이트 (닉네임 변경 시 이메일 전송 X) async function updateUserInGoogleSheet(userData) {     try {         const sheets = await getGoogleSheetsClient();                  const readRes = await sheets.spreadsheets.values.get({             spreadsheetId: SHEET_ID,             range: \"Users!A:G\"         });          let values = readRes.data.values || [];         let userRowIndex = values.findIndex(row =&gt; row[1] === userData.id);          if (userRowIndex !== -1) {             // ✅ 기존 행 업데이트             values[userRowIndex] = [                 userData.nickname,                 userData.id,                 userData.loginPlatform,                 userData.gender,                 userData.birthdayDate,                 userData.registerDate,                 \"\" // 탈퇴 여부 비움             ];              await sheets.spreadsheets.values.update({                 spreadsheetId: SHEET_ID,                 range: `Users!A${userRowIndex + 1}:G${userRowIndex + 1}`,                 valueInputOption: \"RAW\",                 resource: { values: [values[userRowIndex]] }             });             console.log(`✅ 구글 시트 업데이트 완료: ${userData.id}`);         } else {             console.log(`⚠️ 업데이트할 유저를 찾을 수 없음: ${userData.id}`);         }     } catch (error) {         console.error(\"❌ 구글 시트 업데이트 오류:\", error);     } }  // ✅ 유저가 처음 닉네임을 설정할 때 이메일 전송 &amp; 시트에 추가 async function addUserToGoogleSheet(userData) {     try {         const sheets = await getGoogleSheetsClient();          await sheets.spreadsheets.values.append({             spreadsheetId: SHEET_ID,             range: \"Users!A:G\",             valueInputOption: \"RAW\",             resource: { values: [[                 userData.nickname,                 userData.id,                 userData.loginPlatform,                 userData.gender,                 userData.birthdayDate,                 userData.registerDate,                 \"\" // 신규 가입이므로 탈퇴 X             ]] }         });         console.log(`✅ 새로운 유저 추가: ${userData.id}`);          // ✅ 관리자에게 이메일 전송         const mailOptions = {             from: GMAIL_EMAIL,             to: \"indextrown@gmail.com\",             subject: \"[코드라운지] 새 사용자가 가입했습니다.\",             text: `📢 새 사용자 정보: 닉네임: ${userData.nickname} ID: ${userData.id} 플랫폼: ${userData.loginPlatform} 성별: ${userData.gender} 생일: ${userData.birthdayDate} 가입 날짜: ${userData.registerDate}`         };          await transporter.sendMail(mailOptions);         console.log(\"✅ 관리자에게 메일 전송 성공!\");     } catch (error) {         console.error(\"❌ 유저 추가 오류:\", error);     } }  // ✅ 유저 삭제 감지 → 구글 시트에서 \"탈퇴\"로 표시 async function markUserAsDeleted(userId) {     try {         const sheets = await getGoogleSheetsClient();                  const readRes = await sheets.spreadsheets.values.get({             spreadsheetId: SHEET_ID,             range: \"Users!A:G\"         });          let values = readRes.data.values || [];         let userRowIndex = values.findIndex(row =&gt; row[1] === userId);          if (userRowIndex !== -1) {             values[userRowIndex][6] = \"탈퇴\";               await sheets.spreadsheets.values.update({                 spreadsheetId: SHEET_ID,                 range: `Users!A${userRowIndex + 1}:G${userRowIndex + 1}`,                 valueInputOption: \"RAW\",                 resource: { values: [values[userRowIndex]] }             });             console.log(`🚨 유저 삭제 감지 - 탈퇴 처리 완료: ${userId}`);         } else {             console.log(`⚠️ 삭제된 유저를 찾을 수 없음: ${userId}`);         }     } catch (error) {         console.error(\"❌ 구글 시트 탈퇴 처리 오류:\", error);     } }  // ✅ 닉네임이 처음 생성될 때만 이메일 전송 &amp; 시트 추가 exports.addNewUser = onValueUpdated(\"/Users/{userId}\", async (event) =&gt; {     const beforeData = event.data.before.val();     const afterData = event.data.after.val();      if (!afterData) return console.error(\"❌ 오류: 데이터 없음\");      // ✅ 닉네임이 처음 설정될 때만 이메일 발송     if ((!beforeData || !beforeData.nickname) &amp;&amp; afterData.nickname) {         console.log(`📢 새로운 닉네임 생성 감지: ${afterData.nickname}`);         await addUserToGoogleSheet(afterData);     } else {         console.log(`ℹ️ 기존 유저 정보 업데이트 감지: ${afterData.id}`);         await updateUserInGoogleSheet(afterData);     } });  // ✅ 유저 삭제 감지 (삭제되면 \"탈퇴\"로 업데이트) exports.markUserDeletedInSheet = onValueDeleted(\"/Users/{userId}\", async (event) =&gt; {     const userId = event.params.userId;     console.log(`🚨 유저 삭제 감지: ${userId}`);      await markUserAsDeleted(userId); });   ✅ 4. 버전 문제 해결     firebase –version   npm list firebase-functions   functions@ /Users/kimdonghyeon/functions └── firebase-functions@4.3.0 // firebase-functions@4.3.0이면 2nd Gen (v4.x) 사용 중 // firebase-functions@3.26.0이면 1st Gen (v3.x) 사용 중   ✅ 5. 구글 스프레드 시트  5-1     googleapis 모듈 설치 필요   # nvm을 사용하여 Node.js 22로 변경 brew install nvm  # 터미널 재시작 후 Node.js 22 설치 nvm install 22  # Node.js 22로 버전 변경 nvm use 22  # 현재 버전 확인 node -v  # googleapis 설치 npm install googleapis   📌 Firebase 환경 변수에 JSON 키 저장  firebase functions:config:set google_sheets.service_account_json=\"$(cat service-account.json)\"     ⚠️ Firebase 환경 변수 업데이트 후 Functions를 다시 배포해야 함     firebase deploy --only functions           📌 설정이 정상적으로 저장되었는지 확인하는 방법:     firebase functions:config:get           ✅ 6. 구글 시트 연동 및 api(json)발급은 아래 링크 참고     https://velog.io/@junsugi/Google-Sheet-연동하기-feat.-Google-API  ","categories": [],
        "tags": ["Firebase"],
        "url": "/Firebase-Cloud-Function/",
        "teaser": "/assets/img/Swift/SwiftWhite.png"
      },{
        "title": "[알고리즘] 그래프 이론",
        "excerpt":"정점과 간선   정점(Vertex)      노드라고 불리며 그래프를 형성하는 기본 단위다.   분할할 수 없는 객체이자 점으로 표현되는 위치, 사람, 물건 등이 될 수 있다.   간선(Edge)      정점을 잇는 선을 의미한다.   관계 경로 등이 될 수 있다.   예시      “어떠한 위치나 어떠한 사람(정점)” 으로부터 “무언가를 통해(간선)“간다.   Index(정점)가 길(간선)을 걸어 아파트로(정점) 간다   단방향 간선      남자가 여자를 좋아한다. 여자는 남자를 좋아하지 않는다.(짝사랑)   양방향 간선      남자와 여자가 서로 좋아한다.   그래프 이론에서 일반적으로 사용되는 기호      u - 시작점(from)   v - 도착점(to)   indegree &amp; outdegree           U에서 V로 가는 경로가 3가지가 있을 때 표현 방법  -&gt; u의 outdegree(나가는 간선) = 3개            V에서 U로 가는 경로가 7가지 있을 때 표현 방법  -&gt; u의 indegree(들어오는  간선) = 7개       가중치      정점과 정점 사이에 드는 비용을 의미한다   1번노드에서 2번노드까지 가는 비용이 한칸이면 가중치는 한칸이다.   그래프      정점과 간선으로 이루어진 집합이다.   트리      자식노드와 부모노드로 이루어진 계층적인 구조를 가지며 무방향 그래프의 일종이자 사이클이 없는 자료구조를 의미한다.   트리의 특징      부모, 자식 계층구조를 가진다. 같은 경로 상에서 어떤 노드보다 위에 있으면 부모, 아래에 있으면 자식 노드가 된다.   E = V - 1 이다. 간선수 = 노드수 - 1   임의의 두 노드 사이의 경로는 반드시 있으며 하나밖에 없다.  ","categories": [],
        "tags": ["Algorithm"],
        "url": "/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%B4%EB%A1%A0/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[알고리즘] 깊이우선탐색(DFS)",
        "excerpt":"깊이우선탐색(Depth First Search)  그래프를 탐색할 때 쓰는 알고리즘으로 어떤 노드부터 시작해 인접한 노드들을 재귀적으로 방문하며 방문한 정점은 다시 반복하지 않고 각 분기마다 가능한 가장 멀리 있는 노드까지 탐색하는 알고리즘이다.   DFS PseudoCode  DFS(u, adj)     u.visited = true     for each v ∈ adj[u]         if v.visited == false             DFS(v, adj)     어떠한 정점 U의 visited를 참으로 바꾸고 연결되어있는 V지점을 탐색한다.   이 때 방문되지 않은 노드에 대해 재귀적으로 DFS를 호출한다.   DFS 탐색 예제   graph TD;     1((1)) --&gt; 2((2));     2((2)) --&gt; 4((4));     1((1)) --&gt; 3((3));     2((2)) --&gt; 5((5));     4((4)) --&gt; 2((2));  style 1 stroke:#333,stroke-width:3px,font-size:30px style 2 stroke:#333,stroke-width:3px,font-size:30px style 3 stroke:#333,stroke-width:3px,font-size:30px style 4 stroke:#333,stroke-width:3px,font-size:30px style 5 stroke:#333,stroke-width:3px,font-size:30px     1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3   let n: Int = 6 var adj: [[Int]] = Array(repeating: [Int](), count: n) var visited: [Bool] = Array(repeating: false, count: n)  func dfs(_ here: Int) {     visited[here] = true     print(here, terminator: \" \")          for there in adj[here] {         if visited[there] { continue }         dfs(there)     } }  @main struct Main {     static func main() {         adj[1].append(2)         adj[1].append(3)         adj[2].append(4)         adj[4].append(2)         adj[2].append(5)         dfs(1)     } }  // 결과: 1 2 3 4 5 3  ","categories": [],
        "tags": ["Algorithm"],
        "url": "/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B9%8A%EC%9D%B4%EC%9A%B0%EC%84%A0%ED%83%90%EC%83%89(DFS)/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Blog] 깃블로그 이미지 편하게 작성하는법",
        "excerpt":"깃블로그 이미지 편하게 작성하는법           Typora 다운            실행 후 좌측 상단바 Typora -&gt; 설정 -&gt; 이미지 -&gt; 사용자 정의 폴더로 이미지복사            ../assets/img/${filename} 지정            가능하다면 상대적 위치 사용 체크            post 상단에 typora-root-url: ../ 추가          ","categories": [],
        "tags": ["Blog"],
        "url": "/Blog-%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%8E%B8%ED%95%98%EA%B2%8C-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94%EB%B2%95/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[SwiftUI] 이미지 캐시 구현",
        "excerpt":"iOS file System      sandbox   iOS는 보안을 위해 앱 설치시 os내부 설치 프로그램이 그 앱에 자체 독립 공간(sandbox)을 생성한다.  (sandbox) 내부에는 각 역할을 가진 컨테이너 디렉터리들이 생성된다. 즉 각 iOS App은 자체 독립돈 공간 (sandbox)를 가지고 이 공간에서 앱 data와 파일을 관리하고, 다른 App에서 Access 하지 못하도록 보장한다. 각 App의 file, data는 App의 Container 내에서만 Access 가능한다. 또한 iOS는 특정 메커니즘을 사용해 앱 사이의 통신을 지원하며, 제한된 방식으로 상호작용 할 수 있다.(ex: url Scheme)  또한 root 권한이 없는 상태에서 App이 실행되므로 보안을 높이는 역할을 하고, 사용자에게 권한 요청을 통해(연락처 요청..) 승인이 안될 시 해당 기능을 사용할 수 없다.   특징      앱 격리   파일 시스템 제한   앱 간 통신   보안성   권한 관리   Bundle Container   앱의 번들을 소유하고 있다. 앱과 앱을 실핼할 수 있는 이미지, icon, storyboard등 리소스들이 모두 포함되어 있다. 이 폴더는 읽기 전용이라 쓰기가 불가능하며 변조 방지를 위해 이 디렉토리는 설치 시 서명된다.   Data Contaier   App과 사용자를 위한 데이터를 담고 있다.      Cache   기기 안에 자주 사용되는 데이터나 값을 미리 저장하여, 빠르게 접근 가능한 임시 저장소다. 네트워크를 통해 이미지를 받고 뷰를 그리고, 갱신이 된다면 네트워크를 통해 다시 불필요한 리소스를 사용하게 되는데 이러한 자원 낭비를 해결하기 위해 이미지 캐시는 앱개발에서 필수적이다.   이미지 캐시 구현      url을 통해 이미지를 받아오면 이미지를 캐시로 저장하여 view를 다시 그릴 때 네트워크를 통해 이미지 데이터를 불러올 필요 없도록 개발 진행.   Memory storage와 Disk storage를 생성  -&gt; Memory storage(NSCache): iOS에서 지원해주는 캐시, key, value 쌍을 저장,  기기 전원을 종료하면 사라진다.   Disk Storage  -&gt; Cache Directory로 폴더를 만들어서 사용.   플로우      Memory storage(NSCache)에 해당 이미지가 존재하는지 확인 후 없으면 Disk Storage에 해당 경로에 이미지가 있는지 체크를 한 후 네트워크 통신을 하여 가져오고, 각 Storage에 저장한다.   ","categories": [],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%BA%90%EC%8B%9C-%EA%B5%AC%ED%98%84/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] Swift 비동기 처리방식",
        "excerpt":"📝 Swift 비동기 처리방식   1. NSThread      Object-C 시절부터 사용되었다   직접 스레드를 셍성하고 괸리해야 한다.   수동으로 동기화 해야하다.   GCD나 OperationQueue에 비해 사용성이 떨어진다.        ❌ 현재 사용 여부: 현재 거의 사용되지 않는다.       let thread = Thread {     print(\"Background 작업 실행\") }    thread.start()           2. OperationQueue (iOS 2.0/2008)      GCD보다 객체 지향적이고 세밀한 제어 가능하다.   여러 작업을 동시에 실행 가능하다.   의존성(Dependency) 설절 가능하다.        ✅ 현재 사용 여부: 여러 작업 간 의존성이 있는 경우 사용된다.       let queue = OperationQueue() let operation = BlockOperation {     print(\"Background 작업 실행\") } queue.addOperation(operation)           3. GCD(Grand Central Dispatch) (iOS 4.0/2010)      백그라운드 실행이 간편하다.   성능 최적화된 C 기반 API이다.   메인 스레드에서 UI 업데이트 가능하다.        ✅ 현재 사용 여부: 많이 사용된다. (백그라운드 처리, UI 업데이트)       DispatchQueue.gloal(qos: .background).async {     // Background 작업 실행     let result = heavyTask()           DispatchQueue.main.async {         updateUI(with: result)     } }           4. RxSwift (ReactiveX)      오픈소스 라이브러리이다.   리액티브 프로그래밍을 위한 강력한 프레임워크다.   비동기 데이터 스트림을 선언적으로 처리 가능하다.   Obserable과 Observer 패턴 사용한다.        ✅ 현재 사용 여부: 많이 사용된다. (MVVM 아키텍쳐에서 활용됨)       import RxSwift    let disposeBag = DisposeBag() let observable = Observable.just(\"Background 작업 실행\")    observable.subscribe(onNext: { value in     print(value) }).disposed(by: disposeBag)           5. Combine (iOS 13.0/2019)      리액티브 프로그래밍 프레임워크이다.   데이터 스트림을 다룰 때 유용하다.   Publisher와 Subscriber 패턴을 사용한다.        ✅ 현재 사용 여부: 특정 상황에서 사용된다. (API 응답, 데이터 스트림 처리 등)       import Combine    let publisher = Just(\"Background 작업 실행\") let cancellable = publisher.sink { value in     print(value)                                 }           6. Async/await (Switt Concurrency) (iOS 15.0/2021/Swift5.5)      가독성이 뛰어난 최신 비동기 처리 방식이다.   동기 코드처럼 작성 가능하다   Task를 활용해 SwiftUI에서도 사용 가능하다.   ✅ 현재 사용 여부: 가장 추천되는 방식이다. (Swift 5.5+ 환경에서 최적의 선택)     func fetchData() async -&gt; String {     // Background 작업 실행     try await Task.sleep(nanoseconds: 1_000_000_000) // 1초 대기     return \"Fetched Data\" }  Task {     let data = await fetchData()     print(data) }           ✅ 정리 (비동기 처리 방식 비교)                  도입 순서       비동기 방식       특징       현재 사용 여부                       1       NSThread       직접 스레드 관리, 수동 동기화 필요       거의 안 씀 ❌                 2       OperationQueue       객체 지향적, 작업 의존성 설정 가능       사용됨 ✅                 3       GCD (DispatchQueue)       백그라운드 처리, UI 업데이트 가능       많이 사용됨 ✅                 4       RxSwift       리액티브 프로그래밍, Observable 활용       많이 사용됨 ✅                 5       Combine       데이터 스트림을 다루는 리액티브 프로그래밍       특정 상황에서 사용됨 ✅                 6       async/await       최신 Swift 비동기 처리 방식, 가독성이 좋음       가장 추천됨 🚀✅          ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-01-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%8B%9D/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 변수와 상수 그리고 타입",
        "excerpt":"1. 변수(Variable) var          데이터를 담을 수 있는 공간름            프로그래밍 동작의 첫번째 단계: 변수 선언       // 변수를 선언하면서 저장 // 3이라는 숫자를 a라는 공간에 저장한다 var a = 3\t var b = 7    // 변수를 여러개 한꺼번에 선언 var x = 1, y = 2, z = 3    // 새로운 공간을 만들고 값을 복사(Copy)해서 저장 var newSpace = a           String Interpolation (문자열 보간법)           변수를 문자열 안에서 출력방법       // \\(변수이름)    var name = \"Index\" print(\"Hello \\(name)\")           2. 상수(constants) let           변하지 않는 데이터를 담을 수 있는 공간            식별자(한 영역에 유일한 이름만 사용): 상수의 이름       let name = \"Index\" print(\"Hello \\(name)\")           3. 타입(Type)   Swift 기본 타입                  타입(키워드 = 약속어)       내용       예시                       Int       정수(8바이트)       1, 2, 3                 Float       부동소수(4바이트), 6자리       3.14                 Double       부동소수(8바이트), 15자리       3.14                 Character       문자       “I”                 String       문자열       “Hello Index”                 Bool       참/거짓       true, false                 기타       UInt                   Swift 변수 특징                  종류       설명       예시                       타입 주석 (Type annotation)       변수를 선언하면서 타입을 명시적으로 선언하는 방법.       var name: String = “Index”                 타입 추론       데이터 타입을 명시하지 않아도 컴파일러가 타입을 유추해서 알맞는 타입으로 저장하는 방법.       var name = “Index”                 타입 안전성       어떤 변수가 특정 타입으로 선언되면 그 변수에는 해당 타입만 담을 수 있다.       var number = 1  number=3.14(❌ 컴파일 에러)           ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-01-%EB%B3%80%EC%88%98%EC%99%80-%EC%83%81%EC%88%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%ED%83%80%EC%9E%85/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 기본 연산자",
        "excerpt":"1. 기본 연산자  ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-02-%EA%B8%B0%EB%B3%B8-%EC%97%B0%EC%82%B0%EC%9E%90/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 프로그래밍 기본 원리와 조건문",
        "excerpt":"1. 프로그래밍 기본 원리      순차   조건   반복   순차           개발자가 정한 규칙으로 실행한다.       print(\"1\") print(\"2\") print(\"3\")           조건(if)           조건이 참이면 {}를 실행하고 거짓이면 아무 직업도 하지 않는다.            참과 거짓을 판단할 수 있는 문장을 조건이라고 부르고, 조건을 콤마로 여러개 연결 가능하다(and연산자이다).            ⚠️ if문에서 ,(콤마)는 and 역할이다.       if 참과 거짓을 판단할 수 있는 문장 {    }       조건(switch)      if문보다 한정적인 상황에서 사용한다.   각각의 case 에 break을 사용할 필요 없다.   가능한 모든 경우의 수를 다루어야 한다.   반드시 default문이 있어야 한다. (모든 케이스를 빠짐없이 봐야하기 때문)   default문에는 일을 안한다면 break문을 써야 한다.   fallthrough: 무조건 아래 문장 실행해라.   범위 연산자/패턴 매칭 연산자를 사용해라.   ⚠️ switch문에서 ,(콤마)는 or 역할이다.   ⚠️ case에서 부등식을 사용할 수 없다 범위 연산자로 만들어진 범위 값으로 케이스를 정의해야 한다.        기본 방식       switch 변수 { case 값1:     // code case 값2, 값3:     // code case 값4:     // code default:   \tbreak // 실행하려는 코드가 없으면 반드시 break 입력 }                패턴 매칭       switch age { case 10...19:\t// 10...19 ~= age   \t// code case 20...29:   \t// code case 30...39:   \t// code default:   \tbreak }                case를 조건에 따라 처리하는 경우       switch num { case let x where x%2==0:\t\t// num변수를 x 상수에 바인딩 후, where 조건절에서 케이스가 조건에 해당하는지 여부 확인     print(\"짝수 숫자: \\(x)\") default:     print(\"홀수 숫자: \\(num)\") }           범위 연산자           … 연산자       0...50  // 0부터 50까지 0..&lt;5\t  // 0, 1, 2, 3 ,4 ..&lt;0\t\t  // 정수의 범위에서 가장 낮은 숫자부터 0까지           패턴 매칭 연산자           ~= 연산자            오른쪽 변수가 왼쪽 범위에 포함되는지에 따라 참과 거짓을 알려주는 연산자       0...50 ~= num // 0~50 범위내에 num이 속한다면 Bool 타입으로 알려주는 기호                          if       switch                       조건 2개 사용가능 및 응용 범위가 넓다       if문보다 가독성이 좋다 실제 앱개발 시 분기처리에 많이 사용한다                                     2. 연습문제   연습문제1   /* 가위 / 바위 / 보 게임을 if문을 사용해서 구현해 봅니다. 컴퓨터는 가 위, 바위, 보 중에서 랜덤(무작위)으로 선택하게 되고, 당신은 한가지 를 고릅니다. 그리고 결과적으로  “무승부입니다.”, “당신은 졌습니다.”, “당신이 이겼습니다.” 이 셋 중에 한가지가 출력되도록 합니다. 가위: 0 바위: 1 보: 2 */  // 컴퓨터가 무작위로 선택(0, 1, 2) // 사용자: 0, 1, 2 중 입력  print(\"(가위: 0, 바위: 1, 보: 2)입력: \", terminator: \"\") let comNum: Int = Int.random(in: 0...2) let user: String = readLine()!  if let userNum = Int(user) {     if 0...2~=userNum {         if userNum == 0, comNum == 0 {             print(\"무승부\")         } else if userNum == 0, comNum == 1 {             print(\"패배\")         } else if userNum == 0, comNum == 2 {             print(\"승리\")         }          else if userNum == 1, comNum == 0 {             print(\"승리\")         }         else if userNum == 1, comNum == 1 {             print(\"무승부\")         }         else if userNum == 1, comNum == 2 {             print(\"패배\")         }          else if userNum == 2, comNum == 0 {             print(\"패배\")         }         else if userNum == 2, comNum == 1 {             print(\"승리\")         }         else if userNum == 2, comNum == 2 {             print(\"무승부\")         }      } else {         print(\"0~2 사이의 값을 입력하세요\")     } } else {     print(\"숫자를 입력해주세요\") }    개선1   @main struct Main {     static func main() {         let comNum: Int = Int.random(in: 0...2)          print(\"(가위: 0, 바위: 1, 보: 2) 입력: \", terminator: \"\")                  // 안전한 입력 처리         guard let userInput = readLine(), let userNum = Int(userInput), (0...2).contains(userNum) else {             print(\"❌ 0~2 사이의 숫자를 입력하세요.\")             return         }                  // 승패 판별 로직 (배열 활용)         let resultMatrix = [             [\"무승부\", \"패배\", \"승리\"],  // userNum == 0 (가위)             [\"승리\", \"무승부\", \"패배\"],  // userNum == 1 (바위)             [\"패배\", \"승리\", \"무승부\"]   // userNum == 2 (보)         ]                  let result = resultMatrix[userNum][comNum]         print(\"컴퓨터: \\(comNum) → 결과: \\(result)\")     } }   개선2   @main struct Main {     static func main() {         let comNum = Int.random(in: 0...2)  // 0: 가위, 1: 바위, 2: 보          print(\"(가위: 0, 바위: 1, 보: 2) 입력: \", terminator: \"\")          // 안전한 입력 처리         guard let userInput = readLine(), let userNum = Int(userInput), (0...2).contains(userNum) else {             print(\"❌ 0~2 사이의 숫자를 입력하세요.\")             return         }          print(\"컴퓨터: \\(comNum), 사용자: \\(userNum)\")          // 승패 판별 로직 (switch 문 활용)         switch (userNum, comNum) {         case let (u, c) where u == c:             print(\"무승부\")         case (0, 1), (1, 2), (2, 0):  // 사용자가 졌을 경우             print(\"패배\")         case (0, 2), (1, 0), (2, 1):  // 사용자가 이긴 경우             print(\"승리\")         default:             print(\"오류 발생\")         }     } }   연습문제2   /* 컴퓨터가 1부터 10사이의 정수에서 랜덤 값을 선택하고, 저장하 도록 합니다. 그리고 당신은 1부터 10사이의 정수를 선택합니다. 컴퓨터가 선택한 랜덤값과 당신의 값을 비교하고 당신의 숫자가 더 높은 경우는 “Down”, 당신의 숫자가 더 낮은 경우는 “Up”, 당신의 숫자와 동일한 경우 “Bingo”가 출력되도록 합니다. */  while true {     print(\"1부터 10 사이 원하는 숫자를 입력하세요(힌트: \\(comNum)): \", terminator: \"\")     let userNum = readLine()!      if let userNum = Int(userNum) {         // if !(0...10).contains(userNum) {}          /*          switch userNum {          case let x where !(0...10).contains(x):          print(\"❌ 1부터 10 사이의 숫자를 입력하세요.\")          default:          print(\"✅ 입력한 숫자: \\(userNum)\")          }          */          /*          switch userNum {          case 0...10:          // print(\"🎉 입력한 숫자: \\(userNum), 컴퓨터 숫자: \\(comNum)\")          default:          print(\"❌ 1부터 10 사이의 숫자를 입력하세요.\")          }          */          switch userNum {         case let x where x == comNum:             print(\"Bingo\")             return         case let x where x &gt; comNum:             print(\"Down\")         case let x where x &lt; comNum:             print(\"Up\")         default:             print(\"❌ 1부터 10 사이의 숫자를 입력하세요.\")         }     } }   ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-03-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%A1%B0%EA%B1%B4%EB%AC%B8/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 튜플(Tuple)",
        "excerpt":"1. 튜플      원하는 연관된 데이터의 조합으로 만들 수 있는 타입이다.        변수를 선언과 동시에 해당 멤버(데이터의 종류 및 개수)가 결정되므로 추가/삭제는 불가능하다.       // 좌표 let position: (Int, Int) = (1, 2)   print(position.0)   print(position.1)    // 3차원 공간 let position3D: (Int, Int, Int) = (1, 2, 3) print(position3D.0) print(position3D.1) print(position3D.2)    // 태입 앨리어스를 이용하여 튜플의 묶음값을 치환해서 사용가능(이 자체가 하나의 타입) typealias GridPoint = (Int, Int)\t let grid: GridPoint = (1, 2) print(grid.0) print(grid.1)              Named Tuple(이름이 매겨진 튜플)           데이터의 각 요소에 이름을 붙일 수 있다.       let iOS = (\"Swift\", \"6.0\") let iOS2 = (language: \"Swift\", version: \"6.0\")    print(iOS.0, iOS.1) print(iOS2.0, iOS2.1) print(iOS2.language, iOS2.version)    // Swift 6.0 // Swift 6.0 // Swift 6.0              Decomposition(튜플의 분해)      튜플의 각 요소를 상수/변수화 가능하다. (바인딩)        특징: 데이터를 분해해서 활용할 수 있다.       let (name, age, address) = (\"홍길동\", 20, \"서울\") print(name) print(address)           튜플과 조건문 활용           if문 활용       let iOS = (\"Swift\", \"6.0\")    if iOS.0 == \"Swift\" &amp;&amp; iOS.1 == \"6.0\" {   \tprint(\"Swift 버전 \\(iOS.1)\") }            switch문 활용        변수의 케이스에 따라 구분할 때 주로 사용한다.       switch iOS { case (\"Swift\", 5):     print(\"스위프트 버전 5\") case (\"Swift\", 6):   \tprint(\"스위프트 버전 6\") default:     break }           튜플의 switch문 바인딩        각 케이스 내에서 튜플의 각 요소를 활용할 때 주로 사용한다.       switch coordinate { case (let x, let y):     print(\"좌표는 (\\(x), \\(y)) 입니다.\") default:     break }           튜플의 switch문 바인딩/where절        특정 조건에 따라 튜플 케이스를 처리하고 싶을 때 주로 사용한다.       switch coordinate { case let (x, y) where x == y:     print(\"좌표는 (\\(x), \\(y)) 입니다.\") default:     break }           튜플을 사용하는 이유 with function      함수는 원칙적으로 리턴값이 하나만 존재하여 여러 값을 반환할 수 없다.        하지만 튜플을 리턴하면 묶음 값으로 반화할 수 있다.       func tuple() -&gt; (String, Int) {     return (\"Index\", 26) } print(tuple())           ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-04-%ED%8A%9C%ED%94%8C/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] (삼항/범위/패턴매칭)연산자",
        "excerpt":"1. 삼항연산자(Ternary Conditional Operator)      세가지 항을 가진 연산자이다.   조건에 따라 선택이 2가지인 경우 사용한다.   ? 와 : 를 사용한다.   조건에 따라 리터럴 값을 선택하여 변수에 대입할 때 사용한다.   if문과 동일하게 사용가능하다.   삼항연산자는 단독으로 사용하기 보다는 결과 값을 대입할 때 주로 사용한다.        ✅ 사용 예시: 어떤 조건에 따라 선택이 두가지인 경우 사용한다.       // if문 if condition { \t\tprint(\"1\") } else {   \tprint(\"2\") }    // 삼항연산자 condition ? print(\"1\") : print(\"2\") var name = a &gt; 5 ? \"스티브\" : \"인덱스\"           2. 범위연산자      Swift에서 범위를 쉽게 표기하는 방법이다.                  폐쇠 범위 연산자(Closed Range Operator)       반폐쇄 범위 연산자(Half-Open Range operator)                       1…10 ClosedRange 1… PartialRangeForm …10 PartialRangeThrough       1..&lt;10 Range ..&lt;10 PartialRangeUpTo           3. 패턴 매칭 연산자(~=)      오른쪽에 있는 표현식이 왼쪽의 범위에 포함되는 지에 따라 참과 거짓을 반환한다.        범위연산자와 함께 쓰이는 연산자이다.       var age = 26 1...9 ~= age    // false 20...29 ~= age  // true           ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-05-%EC%82%BC%ED%95%AD%EB%B2%94%EC%9C%84%ED%8C%A8%ED%84%B4%EB%A7%A4%EC%B9%AD-%EC%97%B0%EC%82%B0%EC%9E%90/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 반복문",
        "excerpt":"1. for문      범위나 컬렉션에서 item을 하나씩 뽑아, 중괄호 안에서 반복 실행한다.   ⚠️ 여기서 item은 반복상수 이다.        즉 for in 반복상수는 매번 새로운 스택 공간에 동일한 식별자로 선언과 동시에 초기화되된다.       for item in 범위 or 컬렉션 { \t\tprint(item) }    for item in 1...5{      }    // 첫 사이클에서 item은 아래와 같다 let item: Int = 숫자              상수를 사용하는 이유      반복변수 item이가 불변(let) 이므로 Stack에 저장된다.   Stack 메모리는 매우 빠르며, var가 필요한 추가적인 메모리 할당 및 변경 비용이 필요없다.   만약 var를 사용하여 값을 변경할 수 있다면 Heap에 메모리를 할당해야 할 가능성이 높아지고 성능이 저하될 수 있음.   var를 사용하면 Swift의 ARC(Auto Reference Counting)가 변경을 추적해야 할 수 도 있다. 하지만 let을 사용하면 ARC가 불필요한 참조 카운트 연산을 수행하지 않아도 되어 성능 향상이 될 수 있다.   와일드카드 패턴      생략을 위해 사용하는 언더바이다. (_)        상수나 변수로 저장할 필요없이, 생략해도 되는 경우에 사용한다.       for _ in 1...5 {      }    let _ = (1...10).reversed()           for문 추가예제           범위에서 많이 사용되는 예제       // 범위 // (1...10).reversed // stride(from: 1, to: 15, by: 2) for item in 범위 {      }           2. while문           참과 거짓을 판단할 수 있는 문장(조건: condition) 즉 조건을 만족하는 동안 중괄호 내부를 반복 실행한다.       while 참과 거짓을 판단할 수 있는 문장 {   \t// 참일 때 계속 실행   \t// 조건에 변화를 주는 문장 }           repeat-while        일단 문장을 실행하고 난 뒤, 조건에 따라 반복적으로 실행할 지 여부 확인 후 반복 실행.       repeat {   \t// 조건에 변화를 주는 문장 } while 참과 거짓을 판단할 수 있는 문장           3. for vs while                  for       While                       반복횟수를 미리 알고 있거나 컬렉션, 범위 등을 이용할 때 또는 반복상수를 사용하는 작업을 해야할 때       반복횟수가 미리 정해져 있지 않고  조건에 따라 바뀔 때                 범위, 컬렉션, 문자열, stride       조건           4. 제어전송문      반복문 내에서 쓰이는 제어전송 명령문(흐름 제어)                  continue       반복문에서 다음 주기로 넘어간다       중첩사용시 가장 인접한 반복문에 영향을 미친다                       Break       반복문을 중지시킨다       중첩사용시 가장 인접한 반복문에 영향을 미친다           ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-06-%EB%B0%98%EB%B3%B5%EB%AC%B8/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 메모리",
        "excerpt":"1. let 사용이 성능적으로 유리한 이유      Stack 메모리 사용으로 메모리 할당이 빠르다.   컴파일러가 최적화 가능하여 불필요한 연산을 제거한다.   멀티스레드 환경에서 안전하며 동기화 비용이 절감된다.   CPU 명령어 최적화로 실행 속도 증가한다.   ARC 부담 감소로 불피요한 참조 카운트 연산이 감소한다.   Stack vs Heap           Stack              함수나 스코프 내에 선언된 값타입(Valur Type)은 Stack에 저장된다.       메모리 할당과 해제가 빠르다 (LIFO 방식)       let, var 모두 Stack에 저장될 수 있다 (값 타입일 경우)                값 타입(Value Type, Struct, Int, String, Array 등)           func example() {     var number: Int = 10 // 값 타입(Int)이므로 Stack에 저장됨     number += 5 // 여전히 Stack에서 관리됨 }                                Heap              객체(클래스, 클로저 등)처럼 참조 타입(Reference Type) 은 Heap에 저장된다.       여러 변수에서 공유될 수 있으며, ARC로 관리된다.       메모리 할당과 해제가 상대적으로 느리다.                참조 타입(Reference Type, Class, Closure 등)           class Person {     var name: String     init(name: String) {         self.name = name     } }       func example() {     var person1 = Person(name: \"Alice\") // Heap에 저장됨     var person2 = person1 // 같은 객체를 참조 (참조 카운트 증가)           person1.name = \"Bob\" // 변경하면 person2도 영향을 받음 (같은 객체이므로) }                           ###   ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-07-%EB%A9%94%EB%AA%A8%EB%A6%AC/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] Task-1",
        "excerpt":"1. 기존 동시성 프로그래밍(GCD)      대기열 / 큐를 사용하였다        대기열에 넣어서 2번 cpu에 일을 시키는 방식으로 비동기 처리       // 기존 동시성 프로그래밍(GCD) // 기본적으로 다른 쓰레드로 보내지 않았다면 1번 쓰레드(cpu)에서 실행한다 print(\"메인 쓰레드에서 실행 - 1\") print(\"메인 쓰레드에서 실행 - 2\")    // 무조건 2번(또는 특정의 백그라운드) 스레드로 보내서 실행하겠다는 의미(클로저 내에서는 순차적 실행)  DispatchQueue.global().async {     print(\"백그라운드 쓰레드에서 실행 - 1\")     print(\"백그라운드 쓰레드에서 실행 - 2\") }    print(\"메인 쓰레드에서 실행 - 3\") print(\"메인 쓰레드에서 실행 - 4\")           2. Swift Concurrency(asyc/await/task)   Task      비동기적인 일처리를 할 수 있는 하나의 실행 작업 단위를 만드는 것이다.        기존의 GCD방식과 거의 유사하다. (2번 스레드로 보내서 일을 시킨다는 점에서)       print(\"메인 쓰레드에서 실행 - 1\") print(\"메인 쓰레드에서 실행 - 2\")    Task {     print(\"백그라운드 쓰레드에서 실행 - 1\")     print(\"백그라운드 쓰레드에서 실행 - 2\") }    print(\"메인 쓰레드에서 실행 - 3\") print(\"메인 쓰레드에서 실행 - 4\")            서로 다른 작업 단위      각각의 Task는 다른 작업 단위이다.   예를 들어 Task1은 2번 Cpu에 일을 시킬 수 있고 동시에 Task2는 3번 Cpu에게 일을 시킬 수 있다.   Task는 병렬적으로 동시에 일을 할 수 있도록 해준다.        Task 클로저 내부는 순차적으로 실행된다.       // Task 1: // 2번 cpu Task {     print(\"백그라운드 쓰레드에서 실행 - 1\")     print(\"백그라운드 쓰레드에서 실행 - 2\") }    // Task 2: 3번 cpu Task {     print(\"백그라운드 쓰레드에서 실행 - 3\")     print(\"백그라운드 쓰레드에서 실행 - 4\") }    // -&gt; 2번, 3번 병렬적으로 동시에 일을 할 수 있게 만들어준다              Task를 변수/상수에 담을수도 있다      Task 자체를 타입으로 생성을 해서 변수에/상수에 담을 수 있다.   작업을 변수/상수에 담으면 변수에 접근하여 cancel 메서드(작업 취수) 사용 가능.        Never: 일반적인 구조에서 에러 발생하지 않는다.       let task: Task&lt;Void, Never&gt; = Task {     print(\"비동기적인 일 - 7\")     print(\"비동기적인 일 - 8\") } task.cancel()           Task 작업의 결과로 문자열을 리턴할 수 있다           task에서 문자열을 접근할 수 있다.       let task: Task&lt;String, Never&gt; = Task {     print(\"비동기적인 일 - 1\")     print(\"비동기적인 일 - 2\")     return \"문자열\" } // task.value -&gt; Task 성공의 결과값에 접근 // task.result -&gt; Task를 Result 타입으로 변환 가능           동기 함수 내에서 비동기적인 일처리를 할 수 있다           함수 내부에 작업을 만들어서 비동기적인 일처리 가능하다.       func doSomething() {     Task {         try await Task.sleep(for: .seconds(2))         print(\"함수 내부의 비동기적인 일 - 1\")         print(\"함수 내부의 비동기적인 일 - 2\")     } } /* 함수 내부의 비동기적인 일 - 1 함수 내부의 비동기적인 일 - 2 */    func doSomething2() {     print(\"함수 내부의 동기적인 실행 - 1\")            // 2번 Cpu에서 비동기적인 일 실행 가능     Task {         // 2초동안 일을 멈추는 코드.. 즉 2초정도 걸림         try await Task.sleep(for: .seconds(2))         print(\"함수 내부의 오래걸리는 일\")     }     print(\"함수 내부의 동기적인 실행 - 2\") }    /* 함수 내부의 동기적인 실행 - 1 함수 내부의 동기적인 실행 - 2 함수 내부의 오래걸리는 일 */           작업의 우선순위는 6가지가 존재한다      우선순위 지정은 선택사항이다.        우선순위를 사용하지 않는 방법이 일반적이다.       // 선택사항 우선순위 지정가능 task = Task(priority: .우선순위) {   // 비동기적인 일(비동기 함수 실행) }    // 현재 우선순위를 볼 수 있다 Task(priority: .userInitiated) {   \tprint(\"우선순위: \\(Task.currentPriority)\") }    /// 작업 실행 우선 순위의 종류 /// =============================== /// TaskPriority.userInitiated - 25 /// TaskPriority.high - 25 /// TaskPriority.medium - 21 /// TaskPriority.low - 17 /// TaskPriority.utility - 17 /// TaskPriority.background - 9 /// ===============================           작업은 지금 실행 컨텍스트(실행되고 있는 환경)의 메타데이터를 그대로 상속해서 사용한다(구조적 동시성은 아니다)           내부에서 자동으로 현재의 컨텍스트(어떤 환경에서 실행되는지)를 파악하고            우선순위 -&gt; 실행액터 -&gt; 로컬변수(Task-Local 변수)            취소는 상속되지 않는다.       let task = Task(priority: .background) {     sleep(2)     print(\"비동기적인 일 실행: \\(Task.currentPriority)\")     print(\"Task 내부에서 취소 여부: \\(Task.isCancelled)\")          // 내부의 작업 -&gt; 부모 작업의 메타데이터(우선 순위 등)를 상속 사용(취소는 상속 불가)     // 작업 안에서 작업을 다시 생성하는 것은 구조화를 시키지 않는다(하위 작업이 되는 것이 아니다)     Task {         print(\"비동기적인 일 실행: \\(Task.currentPriority)\")         print(\"Task 내부의 Task에서 취소 여부: \\(Task.isCancelled)\")     } }    // task.cancel() 하더라도 내부 Task는 실행된다 -&gt; 상속이 안되기 때문 task.cancel()    /* print(\"비동기적인 일 실행: \\(Task.currentPriority)\") print(\"Task 내부의 Task에서 취소 여부: \\(Task.isCancelled)\") */           특징           작업은 비동기적인 일처리를 위한 기본단위이다. (모든 비동기적인 일처리는 Task 일부)            우선순위 지정은 선택사항이다.            구조체로 만들어져있다.            인스턴스를 생성하자마자 operation 파라미터에 해당하는 클로저를 전달하면서, 작업(Task)을 생성 및 클로저로 전달된 작업을 즉시 실행한다.            즉 클로저를 할당하여 작업을 만들고 클로저를 바로 실행하여 Task를 생성한다.            Task 클로저 내에서 비동기적인 일 수행 가능하다.            비동기 실행 컨텍스트(비동기 함수기 실행될 수 있는 환경)을 만드는 것이다.            Swift Concurrency에서 작업 Task는 기본 단위이다.            Task는 트레일링 클로저 형태로 사용한다.            작업 클로저를 생성하자마자 작업 즉시 실행한다.            https://developer.apple.com/documentation/swift/task       // 에러를 던지지 않는 함수 Task(priority: &lt;#T##TaskPriority?#&gt;, operation: &lt;#T##() async -&gt; Sendable#&gt;) // 에러를 던질 수 있는 함수 Task(priority: &lt;#T##TaskPriority?#&gt;, operation: &lt;#T##() async throws -&gt; Sendable#&gt;)           ​  ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-Task-1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] Task-2",
        "excerpt":"1. Task      비동기적인 일처리를 할 수 있는 하나의 일(work)의 단위.   작업의 생성한다음 바로 비동기적인 일처리를 시작한다.        Operation 파라미터에 해당하는 클로저를 전달하면서, 작업Task을 생성 및 클로저로 전달된 (비동기적인) 작업을 즉시 실행한다.       // 인스턴스 생성 Task {     // 비동기적인 일(인스턴스를 생성하자마자 비동기 작업 실행한다) }           작업의 취소           변수에 담아서 관리가 가능해진다       task.cancel()           결과값 접근           작업은 Success 또는 Failure를 리턴       await task.value  // 작업의 성공의 결과값에 접근 await task.result // 작업의 결과를 Result 타입으로 변환           작업은 각자 비동기적인 작업 처리를 진행하므로, 각 작업은 병렬적으로 일처리를 진행한다   작업은 현재 실행중인 컨텍스트의 메타데이터를 그대로 상속해서 사용한다      2. 작업의 특징      Swift Concurrency에서 작업은 비동기적인 일처리를 위한 기본 단위이다.   작업은 동시성 코드를 실행하고 그 상태와 관련 데이터를 관리한다.   작업의 내부 코드는 순차적으로 동작한다. (멈췄다가 실행될 수도 있다)   컴파일 시점에 thread-safe하지 않은 코드 작성을 불가능하도록 하여 잠재적 불안정 가능성을 제거한다.   기존의 CGD는 대기열 방식인데 큐 자체가 우선 순위를 보유하기 때문에 반드시 우선순위로 실행되지 않을 수 있다.   기존의 CGD는 비동기 작업에 우선 순위를 지정할 수 있었지만 큐 내에서는 FIFO 방식이어서 기본적으로 대기열에 클로저가 등록된 순서대로 처리된다.   Task는 새로운 비동기 방식으로, 우선 순위로 지정한 일을 먼저 끝낼 수 있다.   Task 에서 새로운 방식 도입      Task 내부에서 실행되는 함수는 잠시 중단되었다가 다시 재개될 수 있다.(새로운 방식)   async/awit 도입한다는 것은 어떤 함수가 실행되다가 중단되었다가 다시 실행될 수 있는 개념을 만들어 주는 것이다.   반드시 Task 안에서 실행을 시켰을 때만 중단이 가능하다.  ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-Task-2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] Task-3",
        "excerpt":"1. Task 클로저에서 self 키워드 사용           Task {} 로 작업을 만들 수 있다.            클로저를 할당하면 클로저를 바로 실행하면서 Task를 생성한다.       struct Work: Sendable {}    class Worker {     var work: Task&lt;Void, Never&gt;?     var result: Work?          deinit {         print(\"인스턴스 해제\")     }     \t     func start() {         // 클로저를 통해 작업 생성         work = Task {             print(\"작업의 시작\")             try? await Task.sleep(for: .seconds(3))             // 주의: Task클로저에서 외부변수 result 접근             // self를 부쳐도 된다(원칙이 아님.. 암시적으로 self를 캡처하기 때문-&gt; 문법적 약속)             // 암시적 캡처란 현재 실행 컨텍스트를 캡처하여 현재의 액터 또는 클래스 인스턴스와 같은 실행 환경을 포함하기 때문에 이미 컴파일러가 self를 안전하게 참조할 수 있도록 처리하기 때문에 명시적으로 캡처할 필요가 없는 것이다.             result = Work()             print(\"작업의 완료\")         }     }     \t     // 클래스 내부에서 @escaping 클로저 사용하는 경우     // (self가 캡처되니 주의해서 사용해라는 의미에서) self 키워드 반드시 필요하다(원칙 -&gt; 문법적 약속)     func start2() {         DispatchQueue.global().async {             self.result = Work()         }     } }           2. Task 클로저에서 [weak self] 사용 필요 x           [weak self] in 쓸 필요 없다.            이유: Task는 작업이 끝나면 self 참조도 해제가 되어 강한 순환 참조가 일어날 수 없다.       class Worker {     var work: Task&lt;Void, Never&gt;?     var result: Work?          deinit {         print(\"인스턴스 해제\")     }     \t     func start() {          work = Task { // [weak self] in // 쓸 필요 없다             // 이유: Task는 작업이 끝나면 self 참조도 해제가 된다             print(\"작업의 시작\")             try? await Task.sleep(for: .seconds(3))             result = Work()             print(\"작업의 완료\")         }     }          func start2() {          // 비동기작업이 20초 걸린다고 가정시 self를 캡처한다면 20초동안 붙잡아두는데 이렇게 오래동안 붙잡아두는 상황을 피하기 위해 [weak self]를 사용은 가능하다. 일반적인 상황에서는 사용하지 않는다.         work = Task { [weak self] in              print(\"작업의 시작\")             try? await Task.sleep(for: .seconds(3))             self?.result = Work()             print(\"작업의 완료\")         }     }          // detached를 붙히면 self 필수이다.      // detached도 작업의 종류 중 하나인데 독립적인 작업을 만드는 것이다.     // 기존의 컨텍스트를 물려받지 않고(메타데이터를 상속해서 사용하지 않고 즉 무시하고) 독립적인 작업을 만든다.     func start3() {            work = Task.detached {               print(\"작업의 시작\")               try? await Task.sleep(for: .seconds(3))               self.result = Work()               print(\"작업의 완료\")           }      }              func start4() {       \tDispatchQueue.global().async { [weak self] in           \tself?.result = Work()         }     } }           ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-Task-3/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] async-await-1",
        "excerpt":"1. 기존의 비동기 함수   기존의 비동기 함수 정의 방법      오래 걸려서 얻는 결과값을 반드시 콜백 클로저 형태로 돌려받아야 했다.        올바르지 않은 형태       // 기존 방식에서 잘못된 함수 설계의 형태 func getImage1() -&gt; UIImage? {     var image: UIImage?            /// 오래 걸리는 일(2번 cpu에게 일을 시킨다)     DispatchQueue.global().async {          sleep(5)         image = UIImage(systemName: \"heart\")     }     ///          /// 1번 cpu에서 일을 한다     return image      /// } // 기다리지 않고 image는 무조건 nil이 나옴..                 올바른 형태       // 올바른 형태 (콜백함수 방식으로 설계해야 한다) func getImage2(callback: @escaping (UIImage?) -&gt; Void) {            // 오래 걸리는 일     DispatchQueue.global().async {         sleep(5)         let image = UIImage(systemName: \"heart\")         callback(image) // 콜백함수를 호출하여 데이터 전달     } }           2. async/await라는 개념이 등장           getImage1()처럼 리턴을 하는 것도 가능하도록 설계 가능해졌다.            ⚠️비동기 작업을 수행하면서도 특정 작업의 순서를 보장하고 싶을 때 await을 사용       // async: (이미지를 받아오는데) \"오래걸리는 함수\" 의미 func getImage() async -&gt; UIImage? {     var image: UIImage?     image = UIImage(systemName: \"heart\")     return image }    // async 함수는 호출시 await로 호출해야한다, Task 내에서 호출해야한다. // Task는 비동기 작업을 의미 Task {     let image1 = await getImage()     let image2 = await getImage()     let image3 = await getImage()     let image4 = await getImage() }                비동기 함수 안에서도 await 호출 가능하다. 이때는 Task 필요 x       func doSomething() async {     let image1 = await getImage()     let image2 = await getImage()     let image3 = await getImage()     let image4 = await getImage() }           기존 방식인 sleep -&gt; Task.sleep 방식으로 변경   Sleep(5)는 해당 CPU가 일을 하지 못하게 만드는 코드였다.(Blocking 방식)   Task.sleep은 함수가 실행되다가 잠깐 멈췄다가 나중에 n초 뒤에 다시 실핼할 수 있다.(non-Blocking 방식)            스레드가 비우게 만들어서 이 스레드에서 다른 일처리를 가능하게 해준다.       Await: 다시 실행되기를 기다리겠다           // async: (이미지를 받아오는데) \"오래걸리는 함수\" 의미 func getImage() async throws -&gt; UIImage? {     var image: UIImage?          // sleep(5)     // 기존 5초간 잠재우는 방식에서 변경     try await Task.sleep(for: .seconds(5))      // try가 들어간 에러를 던질 수 있는 함수이므로 함수 정의부분에 throws 추가(에러를 다시 밖으로 던질 수 있어야 한다)     // 이유: 함수 내부에서 do-catch 문 처리를 하지 않아서 throws 키워드를 붙혀야 한다     // 오래동안 걸리는 비동기 함수로 정의되어서 await도 추가..     \t     image = UIImage(systemName: \"heart\")     return image }       // try? throws즉 에러를 던지지 않아도 된다 // 에러 발생시 nil 리턴 func getImage() async -&gt; UIImage? {         // 이를 실행하면 중단됬다가 5초뒤에 재개가능     // 그동안 이를 사용하는 스레드는 다른 일처리가 가능해짐     // 이미지가 생기는 시점에 다시 일처리가 재개     try? await Task.sleep(for: .seconds(5))      let image = UIImage(systemName: \"heart\")     return image }    // 비동기로 정의된 함수를 await로 호출해야한다는 의미는 (1)비동기는 함수가 오래 걸릴 수 있는 함수임을 의미하기도 하지만 (2)잠시 멈췄다가 다시 실행될 수 있는 함수이다. Task {     let image = await getImage() }           ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-async-await-1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] async-await-2",
        "excerpt":"1. GCD 비동기 vs Swift ConCurrency 비동기   GCD 비동기      다른 쓰레드로 일을 시키고, 기다리지 않는다.        해당 작업이 끝나는 시점에 콜백 함수를 통해 값을 리턴 받거나 끝난 시점을 알려준다.       // 정의 func method(closure: @escaping (String) -&gt; Void) {     // 함수 내부 정의     closure(result) }    // 실행 method { result in     print(result)\t       }           Async 비동기 “함수”      async 키워드를 보면 먼저 생각할 것 “(1) 함수가 오래 걸릴 수 있다” “(2) 실행되던 함수가 중간에 멈췄다가 재개될 수 있다.”   중간에 잠깐 멈췄다가(suspend) 다시 재개(resume)될 수 있는 함수다.        CPU(쓰레드)는 해당 (함수) 작업을 실행시키지만 중간에 멈출 수 있는 포인트(suspension point)에서 작업의 진행상황을 시스템(운영체제)에 잠깐 저장했다가 나중에 다시 실행시킬 수도 있다.            (함수 실행시 비동기 컨텍스트에서 호출해야한다)       // 정의 func asyncMethod() async -&gt; String {     // 함수 내부 정의     let result = await otherMethod()     return result }    // 실행 // Task: 비동기적인 환경을 만들어준다 Task {     let result = await asyncMethod()     print(result) }           2. 비동기(async)함수 정리      중간에 잠깐 멈췄다가(suspend or pause) 재개(resume)될 수 있는 함수이다.   Cpu(쓰레드)는 해당 (비동기 함수) 작업을 실행시키지만 중간에 멈출 수 있는 포인트(suspension point)에서 쓰레드 제어권을 시스템(운영체제)에 넘긴다. 시스템은 다른 작업을 수행할 수 있다.   반드시 작업(Task) 내부 또는 다른 비동기 함수 내부(즉 비동기 컨텍스트)에서만 호출 가능하다.   데드락 원천적 방지(non-blockig 방식) 즉 잠시 멈춘 동안에 쓰레드를양보해서 다른 작업이 사용할 수 있도록 양보.   3. GCD vs async/await (Pyramid of doom)   GCD 불편함      비동기 함수의 일이 종료되는 시점을 연결하기 위해 끊임없는 콜백함수를 연결해야 함.        죽음의 피라미드…       func gcdImageData(completionBlock: (_ result: Image) -&gt; Void) {     loadWebResource(\"dataprofile.txt\") { dataResource in         loadWebResource(\"imagedata.dat\") { imageResource in             decodeImage(dataResource, imageResourc) { imageTMP in                 dewarpAndCleanupImage(imageTMP) { imageResult in                     completionBlock(imageResult)                 }             }         }     } }           async/await      콜백함수를 계속 들여쓰기 할 필요없이 반환(return) 시점을 기다릴 수 있고, 직관적인 코드 처리 가능하다.   오래 걸릴 수 있는 함수를 호출하면 데이터가 생기는 시점에 변수에 바인딩 가능하다.   함수이 호출이 오래걸리더라도 콜백 방식 사용 필요 없디.   동기방식으로 순차적으로 코드를 읽을 수 있다.        ⚠️ 각 비동기 함수가 완료된 후에 다음 줄이 실행된다!          func asyncImageData() async throws -&gt; Image {     let dataResource = try await loadWebResource(\"dataprofile.txt\")     let imageResource = try await loadWebResource(\"imagedata.dat\")     let imageTmp = try await decodeImage(dataResource, imageResource)     let imageResult = try await dewarpAndCleanupImage(imageTMP)     return imageResult }           ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-async-await-2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] async-await-3",
        "excerpt":"1. 에러 처리           에러를 던지는 비동기 함수 정의            에러를 던질 수 있는 비동기함수 실행시 try await            async 다음에 throws가 와야한다.            try 다음에 await이 와야한다.       // 1 func throwingGetImage() async throws -&gt; UIImage? {     // 오래 걸리는 일.., 에러가 던질 수 있는 코드     try await Task.sleep(for: .seconds(2))     return UIImage(systemName: \"heart\") }    // 에러를 던질 수 있는 비동기 함수 정의 func asyncMethod() async throws -&gt; String {     let result = try await otherMethod()     return result }    // 원칙적 방법 Task {     do {         let totalString = try await asyncMethod()         print(totalString)     } catch {         \t     } }    let task = Task {     // 1. asyncMethod는 비동기 함수라서 await 붙혀준다     // 2. 에러를 던질 수 있으므로 try 키워드를 붙혀준다     // 3. 원칙적 처리로는 do-catch가 맞지만 처리하지 않아도 된다     // 이유: Task 자체가 에러를 던질 수 있다     let result = try await asyncMethod()     print(result) }    Task {     await task.result }           2. 비동기 함수 실행방법 2가지                       (1) Task 안에서 async 함수 호출           Task {     let image = await getImage() }                                (2) 다른 async 함수 안에서 async 함수 호출 가능(비동기 컨텍스트)           func getImages() async -&gt; [UIImage?] {     let image1 = await getImage()     let image2 = await getImage()     let image3 = await getImage()       \t     return [image1, image2, image3] }      Task {     let images = await getImages() }                           3. 언제든지 비동기적인 컨텍스트 만드는 것 가능                       비동기함수는 비동기적인 컨텍스트에서 호출되야한다           func someSyncFunc() {     print(\"동기적인 작업 시작\")     Task {         try await Task.sleep(for: .seconds(2))         print(\"비동기적인 작업내에서의 작업\")     }     print(\"동기함수 작업 종료\") }                           4. 비동기 함수 내에서 비동기 함수 호출              각각의 함수 자체가 중간에 멈췄다가 다시 실행할 수 있다.       순서대로 진행된다.       비동기 함수 내에서 다른 비동기 함수를 호출을 하는것은 현재의 실행 컨텍스트 내에서 실행을 시키는 것이다(취소 전파도 가능하고, 하위 작업을 만드는 것이 아니다).                즉 구조적 동시성이 아니다.           func parentFuncgion() async throws {     // async 함수 내에서 다른 async 함수 호출: 동일한 비동기 컨텍스트 내에서의 실행(작업의 입루)     try await asyncFunction()     try await asyncFunction()      // Task를 사용하여 명시적으로 다른 작업(Task) 생성 가능(구조적 동시성은 아니고 따로 작업을 만든다) 병렬 실행     // 자식 작업의 생성 방식은 아니다     Task {         try await asyncParentFunction()         try await asyncParentFunction()     }              print(\"비동기 함수 실행의 종료\") }                           ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-async-await-3/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[알고리즘] 인접행렬",
        "excerpt":"1.  인접행렬      그래프와 정점과 간선의 관계를 나타내는 bool 타입의 정사각형 행렬이다.   정사각형 행렬의 각 요소가 0 또는 1의 값을 가짐을 의미한다.   0: 두 정점 사이의 경로가 없다.   1: 두 정점 사이의 경로가 있다.            import Foundation  let n = 4 let arr: [[Int]] = [     [0, 1, 1, 1],     [1, 0, 1, 0],     [1, 1, 0, 0],     [1, 0, 0, 0] ]  for i in 0..&lt;n {     for j in 0..&lt;n {         if arr[i][j] != 0 {             print(\"\\(i)부터 \\(j)까지 경로가 있습니다\")         }     } }   예제 1) 3번부터 5번 노드로 가는 단방향 경로가 있고 이를 인접행렬로 표현한다면?   a[3][5] = 1   예제 2) 3번노드에서 5번노드로 가는 양방향 경로가 있고 이를 인접행렬로 표현한다면?   a[3][5] = 1 a[5][3] = 1   예제 3) 정점의 개수가 20개인 그래프가 존재할 때, 이를 인접행렬로 표현하되 메모리를 최소로 사용하려면?   var a: [[Bool]] = Array(repeating: Array(repeating: false, count: 20), count: 20)   예제 4) 노드 1, 2, 3이 있으며, 1번 노드에서 2번 노드로 가는 단방향 경로와 2번 노드에서 3번 노드로 가는 단방향 경로를 인접행렬로 표현한다면?   [0, 1, 0] [0, 0, 1] [0, 0, 0]   예제 5) 1~4노드로 이루어진 4개의 노드가 존재한다. 1-&gt;2, 2-&gt;3, 3-&gt;4로 이동하는 노드경로가 있을 때 인접행렬로 표현한다면?   [0, 1, 0, 0] [0, 0, 3, 0] [0, 0, 0, 1] [0, 0, 0, 0]   예제 6) 1번부터 5번의 노드가 존재할 때, 모든 노드가 서로 연결되어있는 완전 그래프의 인접행렬을 표현하려면?   [0, 1, 1, 1, 1] [1, 0, 1, 1, 1] [1, 1, 0, 1, 1] [1, 1, 1, 0, 1] [1, 1, 1, 1, 0]   예제 7) 노드 1, 2, 3이 있으며 1-&gt; 3노드로 가는 단방향 경로가 있고, 3 -&gt; 2노드로 가는 단방향 경로가 있다. 또한 2 -&gt; 1노드로 가는 경로가 있을 때 인접행렬로 표현하려면?   [0, 0, 1] [1, 0, 0] [0, 1, 0]   예제 8-1) 정점은 0번 부터 9번까지 10개의 노드가 있다. 1 - 2 / 1 - 3 / 3 - 4 라는 경로가 있다. (1번과 2번, 1번과 3번, 3번과 4번은 연결되어있다.) 이를 인접행렬로 표현하라.   a[1][2] = 1; a[1][3] = 1; a[3][4] = 1; a[2][1] = 1; a[3][1] = 1; a[4][3] = 1;   예제 8-2) 0번부터 방문안한 노드를 찾고 해당 노드부터 방문, 연결된 노드를 이어서 방문해서 출력하는 재귀함수를 만들어라. 여기서 정점을 방문하고 다시 방문하지 않게 만들어야 한다.      Swift에서 &amp;&amp; 연산자는 단락 평가(short-circuit evaluation)를 수행하기 때문에    visited[i]가 false이면 adjMatrix[from][i]가 평가되지 않는다.    즉, 불필요한 배열 접근이 발생하지 않으므로 continue 방식과 성능이 동일하다.   let v: Int = 10 var adjMatrix: [[Bool]] = Array(repeating: Array(repeating: false, count: v), count: v) var visited: [Bool] = Array(repeating: false, count: v)  // 재귀함수 func go(_ from: Int) {     visited[from] = true     print(from)          for i in 0..&lt;v {         /*         1번방식         만약 방문하였으면 다음루프로         if visited[i] { continue }                  만약 두 정점 사이의 경로가 있다면 탐색         if adjMatrix[from][i] {             go(i)         }          */                  // 2번방식         if !visited[i] &amp;&amp; adjMatrix[from][i] {             go(i)         }     } }  // 그래프 간선 추가(무방향 그래프) adjMatrix[1][2] = true; adjMatrix[1][3] = true; adjMatrix[3][4] = true; adjMatrix[2][1] = true; adjMatrix[3][1] = true; adjMatrix[4][3] = true;  for i in 0..&lt;v {     for j in 0..&lt;v {         // 만약 두 정점 사이의 경로가 있고 &amp; 방문하지 않았으면 탐색하자         if !visited[i] &amp;&amp; adjMatrix[i][j] {             go(i)         }     } }   ","categories": [],
        "tags": ["Algorithm"],
        "url": "/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B8%EC%A0%91%ED%96%89%EB%A0%AC/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[자료구조] Queue",
        "excerpt":"Queue   struct DoubleStackQueue&lt;T&gt; {     private var enqueueStack: [T] = []     private var dequeueStack: [T] = []          var size: Int {         return enqueueStack.count + dequeueStack.count     }          var isEmpty: Bool {         return enqueueStack.isEmpty &amp;&amp; dequeueStack.isEmpty     }          mutating func enqueue(_ element: T) {         enqueueStack.append(element)               // O(1)     }          @discardableResult     mutating func dequeue() -&gt; T? {         if dequeueStack.isEmpty {             dequeueStack = enqueueStack.reversed() // O{n}             enqueueStack.removeAll()               // O(1)         }         return dequeueStack.popLast()              // O(1)     } }  @main struct Main {     static func main() {         let times = 1_000_000 // 100만 개 삽입         var myQueue = DoubleStackQueue&lt;Int&gt;()          // 🔹 Enqueue 시간 측정         var startTime = CFAbsoluteTimeGetCurrent()         for i in 1...times {             myQueue.enqueue(i)          }         var durationTime = CFAbsoluteTimeGetCurrent() - startTime         print(\"DoubleStackQueue enqueue time: \\(durationTime) seconds\")          // 🔹 Dequeue 시간 측정         startTime = CFAbsoluteTimeGetCurrent()         for _ in 1...times {             myQueue.dequeue()          }         durationTime = CFAbsoluteTimeGetCurrent() - startTime         print(\"DoubleStackQueue dequeue time: \\(durationTime) seconds\\n\")     } }   Result  DoubleStackQueue enqueue time: 0.25131893157958984 seconds DoubleStackQueue dequeue time: 0.34246695041656494 seconds  ","categories": [],
        "tags": ["Data Structure"],
        "url": "/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Queue/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[AutoLayout]-오토레이아웃-1",
        "excerpt":"1. 오토레이아웃이란?      오토레이아웃이란 뷰 계층구조에 있는 모든 뷰의 크기와 위치를 제약조건(constraints)에 따라 동적으로 계산한다.   즉 자동으로 레이아웃을 그린다는 의미이다.   2. Constraints란?      제약조건(Constraints)란 뷰의 위치와 크기를 다른 객체로부터 상대적으로 나타내는 방법이다.   오토 레이아웃은 제약조건(Constraints)을 이용해서 크기와 위치를  정한다.   view의 frame을 직접 지정해주는 것이 아니라 다른 객체(SafeArea)를 이용해 상대적으로 제약을 주는 것이다   3. 예시   기준 객체(Safe Area)로부터 왼쪽으로 30, 오른쪽으로 30, 위로 100만큼의 margin이 있고 heigh가 200이라는 제약조건이 있는 UIView를 그려보자.      UIView의 width를 정해주지 않았지만 Leading / Trailing Constraints에 의해 서로 당기는 성질이 있어서 해상도 별로 width가 자동으로 저장된다.   만약 가로의 크기가 100인 해상도일 경우 UIView는 100 - 30 - 30 = 40만큼의 width를 가질 것이다.   오토 레이아웃은 크기와 위치가 제일 중요하다.   여기서 크기는 height: 200, width: SafeArea에서 좌우 margin(30)을 뺀 나머지 값(해상도별로 동적으로 변함)   여기서 위치는 Leading: 30, Trailing: 30, Top: 50        ","categories": [],
        "tags": ["AutoLayout"],
        "url": "/AutoLayout-AutoLayout-1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[CleanArchitecture] 클린 아키텍처",
        "excerpt":"  Clean Architecture란?  로버트 C 마틴(Robert C. Martin), 별명으로는 엉클 밥(Uncle Bob)이 제안한 아키텍처로 소프트웨어를 다양한 계층(Layer)으로 분리해서 다음과 같은 목표를 추구한다     아키텍처는 특정 소프트웨어 라이브러리에 의존하지 않는다.   비즈니스 로직은 UI, DB, 웹 또는 기타 외부 요소 없이 테스트 할 수 있다.   UI는 비즈니스 로직과 분리되어, 시스템 로직을 변경하지 않고도 UI를 교체할 수 있다.   비즈니스 로직은 데이터베이스와 바인딩되어 있지 않다.   비즈니스 로직은 외부 세계(입출력 등)에 대해 아무것도 알지 못한다.      요약하자면, 소프트웨어를 역할별로 레이어를 나누고     각 레이어를 완전히 분리하여 의존성을 낮추는 것  이 클린아키텍처의 핵심이다.    이를 통해 변화에 유연하고 테스트하기 쉬운 구조를 만들 수 있다.    왜 아키텍처가 필요한가?  개발자는 돈을 받고 코드를 만드는 사람이다.    회서에서 가장 즁요한 것은     낮은 인건비로   결함이 적은 소프트웨어를 빠르게 개발하는 것   이다. 하지만 모든 개발자들이 적은 인력으로 유지보수가 가능하면서 결함율이 낮은 소프트웨어를 만들어낼 수 없다.    오히려 많은 인력을가지고도 유지보수도 못하고 버그는 많이 생기는 소프트웨어를 만든다.      소프트웨어를 만드는 건 누구나 할 수 있지만,    적은 인력으로 유지보수가 쉬운 ‘좋은 소프트웨어’를 만드는 건 어렵다.    그렇기 떄문에 좋은 아키텍처 의 개념이 중요하다.    좋은 아키텍처는 변화에 강하고, 유지보수가 쉽고, 테스트가 쉬운 구조를 만드는 데 핵심이 된다.   모바일에서의 클린아키텍처           엉클밥의 클린아키텍처 컨셉을 보면 계층을 4개로 분리하였다.    모바일 설계에서의 클린 아키텍처를 적용하기 위한 방법 중 하나로 3Layer 형태로 주로 사용한다.   1.Domain Layer     Entity와 UseCase 계층을 묶어 Domain Layer 라고 부른다.   Entity            앱의 핵심 데이터구조이다.           UseCase            핵심 비즈니스 로직이다.       유저 리스트 불러오기       유저 상세 데이터 불러오기       유저를 내부 저장소에 저장하기           Repository 인터페이스            UseCase와 Data Layer(서버 API, 로컬 DB)를 연결해주는 중간 다리 역할이다.       Domain Layer에서 Repository는 인터페이스(Protocol)만 존재한다.       실제 구현은 Data Layer에서 한다.           2. Data Layer     통신 및 데이터 관리 로직을 담당하는 계층이다.   DB, API            실제 데이터의 입출력을 담당한다.           Repository 구현체            데이터를 조정하는데 UseCase가 필요로 하는 데이터 저장/수정하는 기능을 한다.       데이터소스(ex. DB)를 Protocol같은 인터페이스 형태로 참조하기 때문에 데이터 소스 객체를 갈아끼울 수 있는 형태로, 외부 API를 호출하거나 로컬 DB에 접근하거나 테스트를 위한 MockObject로 전환할 수 있다.           3. Presentation Layer     UI표시, 애니메이션, 이벤트 핸들링 같은 UI 관련 모든 처리를 담당하는 계층이다.   View(ViewConroller, View)            UI 화면 표시와 사용자의 터치 이벤트를 수신한다.       화면에 그리는게 어떤 의미인지는 모르고, 어떤 색으로 그리는지와 같은 View적인 요소만 결정한다.       단순히 Presentor(ViewModel)에서 받은 데이터나 상태에 따라 뷰의 표시를 전환한다.           Presenter(ViewModel)            MVP/VIPER라면 Presenter역할, MVVM이라면 ViewModel역할과 동일하다.       사용자의 이벤트에 대한 판단과 대응을 진행한다. 뷰에 그려지는게 어떤 의미인지, 무엇을 그려야하는지 알고 있다.           의존성 규칙  클린 아키텍처에서 지켜야 할 규칙으로 의존성 규칙이 있다.     안쪽 원을 향하는 방향이 규칙이므로  Data Layer와 Presentation Layer가 Domain Layer를 바라보는 방향으로 의존성 방향이 지켜져야 한다.       Reference     https://sunny-maneg.tistory.com/entry/iOS-설계에서의-Clean-Architecture   https://yoojin99.github.io/app/클린-아키텍처/   https://mini-min-dev.tistory.com/284   https://velog.io/@woohm402/clean-architecture-short-summary   ","categories": [],
        "tags": ["CleanArchitecture"],
        "url": "/CleanArchitecture-CleanArchitecture/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[CleanArchitecture]-객체 지향 설계의 5원칙 SOLID",
        "excerpt":"SOLID 원칙이란  SOLID 원칙이란 객체지향 설계에서 지켜야 할 5개의 소프트웨어 개발 원칙을 의미한다.     특정 프로그래밍 언어 혹은 프레임워크를 위해 만든 원치이 아니다.   객체 지향 설계의 5원칙 SOLID     단일 책임 원칙 (Single Responsibility Principle)   개방 폐쇄 원칙 (Open Closed Principle)   리스코프 치환 원칙 (Liskov Subsitution Principle)   인터페이스 분리 원칙 (Interface Segregation Principle)   의존 역전 원칙 (Dependency Inversion Principle)   SOLID 원칙은 oop 4가지 특징(추상화, 상속, 캡슐화, 다형성)과 더불어, 객체 지향 프로그래밍의 단골 면접 질문 중 하나이다. 또한 Design Pattern들이 SOLID 설계 원칙에 입각해서 만들어진 것이기 때문에 표준화 작업에서부터 아키텍처 설계에 이르기까지 다양하게 적용되는 이의 근간이 되는 SOLID 원칙에 대해 정확히 이해할 필요가 있다.   좋은 소프트웨어란 변화에 대응을 잘 하는 것을 말한다. 예를 들어 클라이언트가 추가적인 요청을 한다면 구현을 할 때 애로사항없이 잘 대응하기 위해서 소프트웨어 설계 근간이 좋아야 한다.   좋은 설계란 시스템에 새로운 요구사항이나 변경사항이 있을 때, 영향을 받는 범위가 적은 구조를 말한다.    그래서 시스템에 예상치 못한 변경사항이 발생하더라도, 유연하게 대처하고 이후에 확장성있는 시스템 구조를 만들 수 있다.   즉 SOLID 객체 지향 원칙을 적용하면 코드를 확장하고 유지보수 관리가 쉬워지며 불필요한 복잡성을 제거하여 리팩토링 소요 시간을 줄임으로써 프로젝트 개발의 생산성을 높일 수 있다.   ","categories": [],
        "tags": ["CleanArchitecture"],
        "url": "/CleanArchitecture-SOLID/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[하루한컷] 1. iOS 카카오 로그인",
        "excerpt":"1. 카카오 로그인     https://developers.kakao.com/console/app 링크 접속   애플리케이션 추가   플랫폼 iOS 등록   네이티브 앱키를 Config.config파일에 저장   2. 파이어베이스 프로젝트 생성     Authentication 생성   Authentication에서 로그인 방법에서 카카오 로그인을 위해 OIDC 추가(이때 업그레이드 해줘야함)           프로젝트 설정에서 Google-Info.plist다운   3. 코드 설정  AppDelegate.swift  import UIKit  // 파이어베이스 import FirebaseCore import FirebaseAuth  // 카카오톡 import RxKakaoSDKCommon import RxKakaoSDKAuth import KakaoSDKAuth  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {     // Override point for customization after application launch.          // 파이어베이스 설정     FirebaseApp.configure()          // 카카오톡 설정     if let nativeAppKey: String = Bundle.main.infoDictionary?[\"KAKAO_NATIVE_APP_KEY\"] as? String {         RxKakaoSDK.initSDK(appKey: nativeAppKey)     }          return true }  func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -&gt; Bool {     // 카카오톡 로그인     if (AuthApi.isKakaoTalkLoginUrl(url)) {         return AuthController.rx.handleOpenUrl(url: url)     }          return false }   SceenDelegate.swift  func scene(_ scene: UIScene, openURLContexts URLContexts: Set&lt;UIOpenURLContext&gt;) {     // 카카오 로그인     if let url = URLContexts.first?.url {         if (AuthApi.isKakaoTalkLoginUrl(url)) {             _ = AuthController.rx.handleOpenUrl(url: url)         }     } }   MVC.swift   import UIKit import RxSwift  import RxKakaoSDKAuth import KakaoSDKAuth  import RxKakaoSDKUser import KakaoSDKUser   final class LoginViewController: UIViewController {          let disposeBag = DisposeBag()          private lazy var kakaoLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Kakao\")         config.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0)         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"카카오로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(red: 0.8, green: 0.72, blue: 0.0, alpha: 1.0) // 눌렸을 때 진한 노랑             } else {                 config?.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0) // 기본 노랑             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleKakaoLogin), for: .touchUpInside)         return button     }()          private lazy var appleLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Apple\")         config.baseBackgroundColor = .white         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"Apple로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(white: 0.9, alpha: 1.0) // 눌렀을 때 약간 회색             } else {                 config?.baseBackgroundColor = .white // 원래 흰색             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleAppleLogin), for: .touchUpInside)         return button     }()          // 카카오로그인버튼, 애플로그이넙튼 -&gt; 스택뷰에 추가     private lazy var stackView: UIStackView = {         let st = UIStackView(arrangedSubviews: [             kakaoLoginButton,             appleLoginButton         ])         st.spacing = 10         st.axis = .vertical         st.distribution = .fillEqually         st.alignment = .fill         return st     }()          override func viewDidLoad() {         super.viewDidLoad()         makeUI()     }          func makeUI() {         // 배경 색상         view.backgroundColor = #colorLiteral(red: 0.09411741048, green: 0.09411782771, blue: 0.102702044, alpha: 1)                  // 스택뷰 -&gt; 뷰에 추가         view.addSubview(stackView)         stackView.translatesAutoresizingMaskIntoConstraints = false                  // 오토레이아웃 제약 추가         NSLayoutConstraint.activate([             stackView.centerXAnchor.constraint(equalTo: view.centerXAnchor),             stackView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),             stackView.heightAnchor.constraint(equalToConstant: 130)         ])     }          @objc private func handleKakaoLogin() {         print(\"✅ 카카오 로그인 버튼 눌림\")         startKakaoLogin()      }          @objc private func handleAppleLogin() {         print(\"✅ Apple 로그인 버튼 눌림\")     } }  // MARK: - Observable extension LoginViewController {          func startKakaoLogin() {         fetchKakaoOpenIdToken()             .subscribe(onNext: { token in                 print(\"✅ 받은 토큰: \\(token)\")             }, onError: { error in                 print(\"❌ 로그인 에러: \\(error.localizedDescription)\")             })             .disposed(by: disposeBag)     }      private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }  #Preview {     LoginViewController() }   VIewController + ViewModel  ViewController  import UIKit import RxSwift  import RxKakaoSDKAuth import KakaoSDKAuth  import RxKakaoSDKUser import KakaoSDKUser   final class LoginViewController: UIViewController {          let disposeBag = DisposeBag()     private let viewModel = LoginViewModel()                 private func bindViewModel() {         viewModel.loginSuccess             .observe(on: MainScheduler.instance)             .subscribe { token in                 print(\"로그인 성공: \\(token)\")             }             .disposed(by: disposeBag)                  viewModel.loginFailure             .observe(on: MainScheduler.instance)             .subscribe { errorMessage in                 print(\"로그인 실패: \\(errorMessage)\")             }             .disposed(by: disposeBag)     }           private lazy var kakaoLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Kakao\")         config.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0)         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"카카오로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(red: 0.8, green: 0.72, blue: 0.0, alpha: 1.0) // 눌렸을 때 진한 노랑             } else {                 config?.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0) // 기본 노랑             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleKakaoLogin), for: .touchUpInside)         return button     }()          private lazy var appleLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Apple\")         config.baseBackgroundColor = .white         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"Apple로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(white: 0.9, alpha: 1.0) // 눌렀을 때 약간 회색             } else {                 config?.baseBackgroundColor = .white // 원래 흰색             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleAppleLogin), for: .touchUpInside)         return button     }()          // 카카오로그인버튼, 애플로그이넙튼 -&gt; 스택뷰에 추가     private lazy var stackView: UIStackView = {         let st = UIStackView(arrangedSubviews: [             kakaoLoginButton,             appleLoginButton         ])         st.spacing = 10         st.axis = .vertical         st.distribution = .fillEqually         st.alignment = .fill         return st     }()          override func viewDidLoad() {         super.viewDidLoad()         makeUI()         bindViewModel()     }          func makeUI() {         // 배경 색상         view.backgroundColor = #colorLiteral(red: 0.09411741048, green: 0.09411782771, blue: 0.102702044, alpha: 1)                  // 스택뷰 -&gt; 뷰에 추가         view.addSubview(stackView)         stackView.translatesAutoresizingMaskIntoConstraints = false                  // 오토레이아웃 제약 추가         NSLayoutConstraint.activate([             stackView.centerXAnchor.constraint(equalTo: view.centerXAnchor),             stackView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),             stackView.heightAnchor.constraint(equalToConstant: 130)         ])     }          @objc private func handleKakaoLogin() {         print(\"✅ 카카오 로그인 버튼 눌림\")         viewModel.loginWithKakao()     }          @objc private func handleAppleLogin() {         print(\"✅ Apple 로그인 버튼 눌림\")     } }  // MARK: - Observable extension LoginViewController {          func startKakaoLogin() {         fetchKakaoOpenIdToken()             .subscribe(onNext: { token in                 print(\"✅ 받은 토큰: \\(token)\")             }, onError: { error in                 print(\"❌ 로그인 에러: \\(error.localizedDescription)\")             })             .disposed(by: disposeBag)     }      private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }  #Preview {     LoginViewController() }   ViewModel  import Foundation import RxSwift import RxCocoa import KakaoSDKUser import RxKakaoSDKUser import RxKakaoSDKAuth import KakaoSDKAuth  final class LoginViewModel {     private let disposeBag = DisposeBag()           // View에서 구독할 수 있도록 공개용 Subject      let loginSuccess = PublishSubject&lt;String&gt;()      let loginFailure = PublishSubject&lt;String&gt;()          func loginWithKakao() {         fetchKakaoOpenIdToken()             .subscribe { token in                 self.loginSuccess.onNext(token)             } onError: { error in                 self.loginFailure.onNext(error.localizedDescription)             }             .disposed(by: disposeBag)     }          private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }   VIewController + ViewModel + Results  ViewController  import UIKit import RxSwift  import RxKakaoSDKAuth import KakaoSDKAuth  import RxKakaoSDKUser import KakaoSDKUser   final class LoginViewController: UIViewController {          let disposeBag = DisposeBag()     private let viewModel = LoginViewModel()          private func bindViewModel() {         viewModel.loginResult             .observe(on: MainScheduler.instance)             .subscribe { result in                 switch result {                 case .success(let token):                     print(\"로그인 성공: \\(token)\")                 case .failure(let error):                     print(\"로그인 실패: \\(error.localizedDescription)\")                 }             }.disposed(by: disposeBag)     }          private lazy var kakaoLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Kakao\")         config.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0)         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"카카오로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(red: 0.8, green: 0.72, blue: 0.0, alpha: 1.0) // 눌렸을 때 진한 노랑             } else {                 config?.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0) // 기본 노랑             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleKakaoLogin), for: .touchUpInside)         return button     }()          private lazy var appleLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Apple\")         config.baseBackgroundColor = .white         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"Apple로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(white: 0.9, alpha: 1.0) // 눌렀을 때 약간 회색             } else {                 config?.baseBackgroundColor = .white // 원래 흰색             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleAppleLogin), for: .touchUpInside)         return button     }()          // 카카오로그인버튼, 애플로그이넙튼 -&gt; 스택뷰에 추가     private lazy var stackView: UIStackView = {         let st = UIStackView(arrangedSubviews: [             kakaoLoginButton,             appleLoginButton         ])         st.spacing = 10         st.axis = .vertical         st.distribution = .fillEqually         st.alignment = .fill         return st     }()          override func viewDidLoad() {         super.viewDidLoad()         makeUI()         bindViewModel()     }          func makeUI() {         // 배경 색상         view.backgroundColor = #colorLiteral(red: 0.09411741048, green: 0.09411782771, blue: 0.102702044, alpha: 1)                  // 스택뷰 -&gt; 뷰에 추가         view.addSubview(stackView)         stackView.translatesAutoresizingMaskIntoConstraints = false                  // 오토레이아웃 제약 추가         NSLayoutConstraint.activate([             stackView.centerXAnchor.constraint(equalTo: view.centerXAnchor),             stackView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),             stackView.heightAnchor.constraint(equalToConstant: 130)         ])     }          @objc private func handleKakaoLogin() {         print(\"✅ 카카오 로그인 버튼 눌림\")         viewModel.loginWithKakao()     }          @objc private func handleAppleLogin() {         print(\"✅ Apple 로그인 버튼 눌림\")     } }  // MARK: - Observable extension LoginViewController {          func startKakaoLogin() {         fetchKakaoOpenIdToken()             .subscribe(onNext: { token in                 print(\"✅ 받은 토큰: \\(token)\")             }, onError: { error in                 print(\"❌ 로그인 에러: \\(error.localizedDescription)\")             })             .disposed(by: disposeBag)     }      private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }  #Preview {     LoginViewController() }     ViewModel  import Foundation import RxSwift import RxCocoa import KakaoSDKUser import RxKakaoSDKUser import RxKakaoSDKAuth import KakaoSDKAuth  final class LoginViewModel {     private let disposeBag = DisposeBag()          let loginResult = PublishSubject&lt;Result&lt;String, Error&gt;&gt;()          func loginWithKakao() {         fetchKakaoOpenIdToken()             .subscribe { token in                 self.loginResult.onNext(.success(token))             } onError: { error in                 self.loginResult.onNext(.failure(error))             }             .disposed(by: disposeBag)     }          private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }   VIewController + ViewModel + Result + Input/Output  ViewController  import UIKit import RxSwift  import RxKakaoSDKAuth import KakaoSDKAuth  import RxKakaoSDKUser import KakaoSDKUser  final class LoginViewController: UIViewController {          let disposeBag = DisposeBag()     private let viewModel = LoginViewModel()     private let kakaoLoginTapped = PublishSubject&lt;Void&gt;()          private func bindViewModel() {         let input = LoginViewModel.Input(kakaoLoginTapped: kakaoLoginTapped.asObservable())         let output = viewModel.transform(input: input)                  output.loginResult             .observe(on: MainScheduler.instance)             .subscribe { result in                 switch result {                 case .success(let token):                     print(\"로그인 성공: \\(token)\")                 case .failure(let error):                     print(\"로그인 실패: \\(error.localizedDescription)\")                 }             }.disposed(by: disposeBag)     }          private lazy var kakaoLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Kakao\")         config.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0)         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"카카오로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(red: 0.8, green: 0.72, blue: 0.0, alpha: 1.0) // 눌렸을 때 진한 노랑             } else {                 config?.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0) // 기본 노랑             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleKakaoLogin), for: .touchUpInside)         return button     }()          private lazy var appleLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Apple\")         config.baseBackgroundColor = .white         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"Apple로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(white: 0.9, alpha: 1.0) // 눌렀을 때 약간 회색             } else {                 config?.baseBackgroundColor = .white // 원래 흰색             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleAppleLogin), for: .touchUpInside)         return button     }()          private lazy var stackView: UIStackView = {         // 카카오로그인버튼, 애플로그이넙튼 -&gt; 스택뷰에 추가         let st = UIStackView(arrangedSubviews: [             kakaoLoginButton,             appleLoginButton         ])         st.spacing = 10         st.axis = .vertical         st.distribution = .fillEqually         st.alignment = .fill         return st     }()          override func viewDidLoad() {         super.viewDidLoad()         makeUI()         bindViewModel()     }          func makeUI() {         // 배경 색상         view.backgroundColor = #colorLiteral(red: 0.09411741048, green: 0.09411782771, blue: 0.102702044, alpha: 1)                  // 스택뷰 -&gt; 뷰에 추가         view.addSubview(stackView)         stackView.translatesAutoresizingMaskIntoConstraints = false                  // 오토레이아웃 제약 추가         NSLayoutConstraint.activate([             stackView.centerXAnchor.constraint(equalTo: view.centerXAnchor),             stackView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),             stackView.heightAnchor.constraint(equalToConstant: 130)         ])     }          @objc private func handleKakaoLogin() {         print(\"✅ 카카오 로그인 버튼 눌림\")         kakaoLoginTapped.onNext(())         //viewModel.loginWithKakao()     }          @objc private func handleAppleLogin() {         print(\"✅ Apple 로그인 버튼 눌림\")     } }  #Preview {     LoginViewController() }   ViewModel  import Foundation import RxSwift import RxCocoa import KakaoSDKUser import RxKakaoSDKUser import RxKakaoSDKAuth import KakaoSDKAuth  final class LoginViewModel {     private let disposeBag = DisposeBag()          // let loginResult = PublishSubject&lt;Result&lt;String, Error&gt;&gt;()          struct Input {         let kakaoLoginTapped: Observable&lt;Void&gt;     }          struct Output {         let loginResult: Observable&lt;Result&lt;String, Error&gt;&gt;     }          func transform(input: Input) -&gt; Output {         let result = PublishSubject&lt;Result&lt;String, Error&gt;&gt;()                  input.kakaoLoginTapped             .flatMapLatest { [weak self] _ -&gt; Observable&lt;Result&lt;String, Error&gt;&gt; in                 guard let self = self else { return .empty() }                 return self.fetchKakaoOpenIdToken()                     .map { .success($0) }                     .catch { error in                             .just(.failure(error))                     }             }             .bind(to: result)             .disposed(by: disposeBag)                  return Output(loginResult: result.asObservable())     }          private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }  ","categories": [],
        "tags": ["Haruhancut"],
        "url": "/Haruhancut-Haruhancut-1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[RxSwift] 2. 개념 및 예제",
        "excerpt":"   1. Rx란?  파이프라인 연결이다   2. 구성     보내는 것 - Observable   연결 - subScribe   중간처리 - 연산자   3. 큰 개념  보내는 것 - 옵저버블(총알 = 구독 가능한 것)     Observable            가장 기본 베이스, 생성하자마자 이벤트를 전달한다       .onNext(), .onError(), .onCompleted()를 통해 이벤트를 받을 수 있다       .subscribe()를 통해 이벤트를 발행 가능       이벤트를 정의하고, 정적인 스트림 생성(한방향: 선언 -&gt; 구독)            // 1. Observable은 가장 기본적인 Rx 스트림  let observable = Observable&lt;Int&gt;.just(1)       // 2. subscribe를 통해 값을 받아 처리  observable      .subscribe(onNext: { value in          print(\"Received: \\(value)\")      })      .disposed(by: disposeBag)           Subject            Observable(구독 가능한 것)이면서 Observer(관찰자)       일단 연결을 해두고 원하는 시점에 이벤트를 보낸다.       외부에서 직접 값을 넣고, 동적인 스트림 생성(양방향)                 BehaviorSubject - 상태                    초기값 필수           구독 시, 가장 최신값 1개를 즉시 전달받음           이후에는 일반 Observable처럼 .onNext 이벤트를 수신                   // 1. BehaviorSubject는 초기값을 설정하고, 구독 시 가장 최근 값을 전달 let behaviorSubject = BehaviorSubject&lt;String&gt;(value: \"초기값\")        // 2. 구독 설정 → \"초기값\"이 바로 전달됨 behaviorSubject     .subscribe(onNext: { print(\"BehaviorSubject:\", $0) })     .disposed(by: disposeBag)        // 3. 새로운 이벤트 전달 behaviorSubject.onNext(\"새로운 값\")                       PublishSubjcet - 단방향 이벤트                    구독 이후 이벤트만 받음(초기값 없음)           주로 이벤트 전달용                   // 1. PublishSubject는 구독 이후에 발생한 이벤트만 전달 let publishSubject = PublishSubject&lt;String&gt;()  // 2. 구독 설정 publishSubject     .subscribe(onNext: { print(\"PublishSubject:\", $0) })     .disposed(by: disposeBag)  // 3. 이벤트 발생 (구독 이후라 전달됨) publishSubject.onNext(\"첫 번째 이벤트\")                           Relay            Subject의 변형으로, error가 없고 UI바인딩에 최적화       PublishRelay                          단방향 이벤트 전달(버튼 클릭)           // 1. PublishRelay는 error가 없고 UI에 최적화된 Subject let publishRelay = PublishRelay&lt;String&gt;()  // 2. 구독 설정 publishRelay     .subscribe(onNext: { print(\"PublishRelay:\", $0) })     .disposed(by: disposeBag)  // 3. 이벤트 발생 → accept()로 전달 publishRelay.accept(\"이벤트 발생!\")                       BehaviorRelay                상태 저장, 초기값 필수 -&gt; accept() 사용           // 1. BehaviorRelay는 초기값이 필요하며, 상태 저장에 적합 let behaviorRelay = BehaviorRelay&lt;String&gt;(value: \"기본값\")  // 2. 구독 설정 → \"기본값\"이 바로 전달됨 behaviorRelay     .subscribe(onNext: { print(\"BehaviorRelay:\", $0) })     .disposed(by: disposeBag)  // 3. 값 업데이트 → accept() 사용 behaviorRelay.accept(\"업데이트된 값\")                           Driver            메인스레드, share(1)                UI 바인딩 전용으로 사용되는 옵저버블              // 1. Relay에서 값을 가져와 Driver로 변환  let textRelay = BehaviorRelay&lt;String&gt;(value: \"Hello\")   // 2. Driver로 변환 (에러 없이, MainThread에서 작동)  let textDriver = textRelay.asDriver()   // 3. UI 요소에 drive (drive는 MainThread에서 UI 바인딩 시 사용)  textDriver      .drive(label.rx.text)      .disposed(by: disposeBag)                           구독     subscribe(onNext:)            next, error, completed 시퀀스 이벤트를 받을 수 있다       직점 onError 처리 가능하다       viewModel 내부, 로직 처리, 이벤트 감지, 에러 대응       Disposable 반환해야한다       모든 Observable계열 구독 가능                bind(onNext:) 보다 범용적, 완료/에러 받을 수 있다            // 1. onNext만 사용하는 기본적인 구독  let observable = Observable.just(\"Hello, RxSwift!\")   observable      .subscribe(onNext: { value in          print(\"onNext:\", value)      })      .disposed(by: disposeBag)   // 2. onNext, onError, onCompleted 모두 명시  let observable = Observable&lt;String&gt;.create { observer in      observer.onNext(\"첫 번째 이벤트\")      observer.onCompleted()      return Disposables.create()  }   observable      .subscribe(          onNext: { print(\"onNext:\", $0) },          onError: { print(\"onError:\", $0.localizedDescription) },          onCompleted: { print(\"onCompleted\") },          onDisposed: { print(\"onDisposed\") }      )      .disposed(by: disposeBag)                           bind(to:)            UI 컴포넌트 프로퍼티에 바인딩할 때 사용       구독과 동시에 값이 특정 속성에 직접 들어가는 방식       값을 특정UI의 속성에 직접 구독해서 바인딩           // label.text = title처럼 자동으로 연결하는 직접 바인딩 방식   viewModel.title    .bind(to: label.rx.text)    .disposed(by: disposeBag)                           bind(onNext:)            단순히 이벤트를 수신하고 구독 형태       내부에 명시적으로 처리 로직을 작성해야 함       값을 받아서 직접 처리(프린트, 로직 실행)하는 방식으로 구독           viewModel.title    .bind(onNext: { text in    print(\"값 출력: \\(text)\")    })    .disposed(by: disposeBag)                           비교     // 1. 자동 UI 업데이트 (bind to UI)   viewModel.username // Observable&lt;String&gt;       .bind(to: label.rx.text) // 📲 label.text = 값       .disposed(by: disposeBag)    // 2. 내가 직접 프린트 (bind with closure)   viewModel.username       .bind(onNext: { name in           print(\"유저 이름은 \\(name)\")       })       .disposed(by: disposeBag)  ","categories": [],
        "tags": ["ReactiveX","RxSwift"],
        "url": "/RxSwift-RxSwift-2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[UIKit] Delegate Pattern란?",
        "excerpt":"1. Delegate 조건  UIKit 클론코딩을 하다 보면 여러가지 상황에서 Delegate Protocol을 채택하고 Protocol 내부에서 제공하는 method를 사용하게 된다. UITextField, UITableView에서도 기능을 구현할 때 흔하게 사용되는 방식이다. Apple에서 우리가 유용하게 사용할 만한 기능들을 함수에 담아 미리 구현해두고 우리가 추가적인 코드를 작성함으로서 우리가 원하는 방식대로 앱이 동작하게 할 수 있다.   Delegate Pattern 은 아래의 조건을 총족함으로서 사용할 수 있다.  Delegate를 생성하는 뷰     Protocol을 생성하고, 구현하고 싶은 기능을 해당 Protocol의 메서드로 생성   Protocol을 Type으로 갖는 Delegate 인스턴스 생성   생성한 method가 동작해야하는 상황에 코드 작성   Delegate를 위임받는 뷰     ViewController에 Delegate Protocol을 채택   Protocol 필수 method 구현   Delegate 위임   2. 준비  FirstViewController는 결과값을 표시할 Label, 두번째 Controller를 뛰울 Button  SecondViewController는 결과값을 입력받을 TextField와 첫번째 Controller로 돌아갈 수 있는 Button을 배치   Protocol  /// 1 protocol CustomTextFieldDelegate: AnyObject {     func textDidInput(text: String) }   FirstViewController  // //  FirstViewController.swift //  MyDelegate // //  Created by 김동현 on 4/30/25. //  import UIKit  final class FirstViewController: UIViewController {          // MARK: - UI Components     private lazy var myLabel: UILabel = {         let label = UILabel()         label.text = \"hello world\"         label.textColor = .white         return label     }()          private lazy var nextButton: UIButton = {         let button = UIButton()         button.setTitle(\"secondView\", for: .normal)         button.setTitleColor(.black, for: .normal)         button.backgroundColor = .systemMint         button.layer.cornerRadius = 20         button.addTarget(self, action: #selector(goNextView), for: .touchUpInside)         return button     }()      override func viewDidLoad() {         super.viewDidLoad()         makeUI()     }          func makeUI() {         // MARK: - 뷰 추가         [myLabel, nextButton].forEach {             view.addSubview($0)             $0.translatesAutoresizingMaskIntoConstraints = false         }                  // MARK: - 제약조건 설정         // 레이블         NSLayoutConstraint.activate([             myLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),             myLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor)         ])                  // 버튼         NSLayoutConstraint.activate([             // 위치 제약             nextButton.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             nextButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),                          // 크기 제약             nextButton.heightAnchor.constraint(equalToConstant: 50),             nextButton.widthAnchor.constraint(equalToConstant: 200)         ])     }          @objc     func goNextView() {         let secondVC = SecondViewController()         secondVC.delegate = self         self.present(secondVC, animated: true)     } }  /// 3 extension FirstViewController: CustomTextFieldDelegate {     func textDidInput(text: String) {         myLabel.text = text     } }  #Preview {     FirstViewController() }    SecondViewController  // //  SecondViewController.swift //  MyDelegate // //  Created by 김동현 on 4/30/25. //  import UIKit  final class SecondViewController: UIViewController {     /// 2     weak var delegate: CustomTextFieldDelegate? = nil          // MARK: - UI Components     private lazy var texxtField: UITextField = {         let textField = UITextField()                  // placeholder 스타일         textField.attributedPlaceholder = NSAttributedString(             string: \"입력해주세요\",             attributes: [.foregroundColor: UIColor.lightGray]         )                  // 왼쪽 여백         textField.leftView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 0))         textField.leftViewMode = .always                  // 테두리 스타일         textField.layer.borderColor = UIColor.black.cgColor // 테두리 색상         textField.layer.borderWidth = 1.0 // 테두리 둑께         textField.layer.cornerRadius = 10 // 둘글게                  return textField     }()          private lazy var endButton: UIButton = {         let button = UIButton()         button.setTitle(\"secondView\", for: .normal)         button.setTitleColor(.black, for: .normal)         button.backgroundColor = .systemMint         button.layer.cornerRadius = 20         button.addTarget(self, action: #selector(goBack), for: .touchUpInside)         return button     }()          override func viewDidLoad() {         super.viewDidLoad()         view.backgroundColor = .darkGray         /// print(\"delegate 상태:\", delegate as Any)         makeUI()     }          private func makeUI() {         // MARK: - 뷰 추가         [texxtField, endButton].forEach {             view.addSubview($0)             $0.translatesAutoresizingMaskIntoConstraints = false         }                  // MARK: - 제약조건 설정         // 텍스트필드         NSLayoutConstraint.activate([             // 위치             texxtField.centerXAnchor.constraint(equalTo: view.centerXAnchor),             texxtField.centerYAnchor.constraint(equalTo: view.centerYAnchor),                          // 크기             texxtField.heightAnchor.constraint(equalToConstant: 50),             texxtField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20)         ])                  // 버튼         NSLayoutConstraint.activate([             // 위치 제약             endButton.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             endButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),                          // 크기 제약             endButton.heightAnchor.constraint(equalToConstant: 50),             endButton.widthAnchor.constraint(equalToConstant: 200)         ])     }          @objc     private func goBack() {         let text = texxtField.text ?? \"\"         self.delegate?.textDidInput(text: text)         self.dismiss(animated: true)     } }  #Preview {     FirstViewController() }    3. Delegate Pattern 연습  Protocol 구현하기  구현하고자 하는 method를 Protocol을 생성하고 그 내부에 만들어 주어야 한다. Protocol은 class을 Type으로 가진다. class Type을 가지게 되면 이후 생성할 delegate 인스턴스를 weak 형태로 생성할 수 있다.  // 1. 프로토콜 정의 (class 전용) protocol ChatDelegate: AnyObject {     func didReceiveMessage(_ message: String) }  // 2. 메시지를 받는 쪽 (delegate를 호출하는 쪽) class ChatRoom {     // 2.1 순환 참조 방지를 위해 반드시 weak 사용     // 프로토콜에 AnyObject 또는 class 제약을 반드시 붙여야 함     weak var delegate: ChatDelegate?      func receiveNewMessage() {         let message = \"안녕하세요!\"         delegate?.didReceiveMessage(message)     } }  // 3. 메시지를 표시할 화면 (delegate를 구현하는 쪽) class ChatViewController: UIViewController, ChatDelegate {     let chatRoom = ChatRoom()      override func viewDidLoad() {         super.viewDidLoad()         chatRoom.delegate = self // 위임 설정     }      func didReceiveMessage(_ message: String) {         print(\"받은 메시지: \\(message)\")     } }   이 실습에서는 SecondViewController 의 UITextField 에 입력받은 내용을 FirstViewController 의 UILabel 에 전달해야하므로 우리가 구현할 method 는 String 을 Parameter 로 전달 받는다.  protocol CustomTextFieldDelegate: AnyObject {     func textDidInput(text: String) }   Delegate 인스턴스 생성하기  SecondViewController에서 delegate 인스턴스를 생성한다. delegate인스턴스는 CustomTextFieldDelegate를 타입으로 가짐으로서 이 인스턴스에 접근해서 우리가 Protocol 내부에 작성해두었던 함수에 접근할 수 있게 된다.  // weak 을 사용해 ARC 가 증가하지 않도록 만들어줌으로서 메모리 Leak 이 발생하지 않도록 방지해주는 것이 중요 weak var delegate: CustomTextFieldDelegate? = nil   Protocol 채택 및 필수 method 구현  Protocol을 채택시 우리가 생성한 Protocol을 채택하고 method까지 함께 구현한다.  Protocol을 채택할 때는 반드시 Extension으로 주어야 하는 것은 아니지만 필자는 가독성이 좋다고 판단하여 Extension으로 Delegate를 채택하는 것을 선호한다.  Protocol 이 채택되고 나면 경고창이 뜨면서 필수 함수를 구현하라고 나오는데 이 때 Xcode 가 지원하는 자동에러처리를 사용하면 함수 하나가 생성된다.   /// 3 extension FirstViewController: CustomTextFieldDelegate {     func textDidInput(text: String) {         myLabel.text = text     } }   Delegate 위임하기  delegate 인스턴스를 생성했을 때 Optional 형태로 생성하였다. 이 값에 CustomTextFieldDelegate를 채택한 FirstViewController를 할당해준다.  실제 Input은 SecondViewController에서 이루어지지만 그 값에 대한 처리가 FirstViewController에서 대행하겠다는 일종의 명시이다.  위임 방법은 FirstViewController에서 화면을 present할 때 구현해놓은 nextVC의 delegate에 접근에서 설정할 수 있다  @objc func goNextView() {     let secondVC = SecondViewController()     secondVC.delegate = self     self.present(secondVC, animated: true) }   SecondViewController에서 함수가 동작해야하는 시점 설정  우리가 원하는 타이밍에 함수가 작동할 수 있도록 코드 구현. 화면을 전달하면서 값을 전달하면된다. delegate의 textDidInput함수를 호출하는 시점이 결정되었고 이제 버튼이 눌리게 되면 View 가 Dismiss 되기 전 이 함수를 호출하며 FirstViewController 가 값을 전달받게 된다. 이게 가능한 이유는 SecondViewController 가 present 되기 전 우리가 FirstViewController 를 delegate 로 설정해주었기 때문이다.  @objc private func goBack() {     let text = texxtField.text ?? \"\"     self.delegate?.textDidInput(text: text)     self.dismiss(animated: true) }   Reference     https://kasroid.github.io/posts/ios/20201010-uikit-delegate-pattern/  ","categories": [],
        "tags": ["UIKit"],
        "url": "/UIKit-delegate/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 1. 테이블뷰 예제",
        "excerpt":"테이블 뷰  테이블뷰는 dataSource와 delegate, Cell로 이루어져있다.   구성     dataSource            데이터와 관련된 부분       셀을 어떻게 보여줄 지       데이터 크기, 종류에 따른 셀의 타입 정하기       리스트 개수가 몇개인지           delegate            특정 셀 선택시 엑션과 같은 이벤트 처리 담당           Cell            테이블뷰에 들어가는 각각의 알맹이           예제 1  import UIKit  class ViewController: UIViewController {      /// Interface Builder에 연결된 테이블 뷰 아울렛     @IBOutlet weak var myTableView: UITableView!          /// 더미 데이터     var dummyDataList: [String] = [         \"hello world1\",         \"hello world2\",         \"hello world3\",         \"hello world4\",         \"hello world5\",         \"hello world6\",         \"hello world7\",         \"hello world8\",         \"hello world9\",     ]          override func viewDidLoad() {         super.viewDidLoad()                  /// 테이블 뷰의 데이터 소스, 델리겟을 현재 뷰 컨트롤러로 설정         myTableView.dataSource = self         myTableView.delegate = self     } }  /// 프로토콜은 약속이다 -&gt; 준수해야한다 /// DateSource - 데이터 관련된 부분 /// 리스트는 섹션과 섹션안에 아이템들이 있다 /// 테이블뷰에서는 섹션과 로우로 부룬다 /// /// UITableView의 데이터 관리 역할을 담당 extension ViewController: UITableViewDataSource {          /// 섹션 내 보여줄 셀의 개수를 반환     /// - section: 섹션 인덱스 (기본적으로 1개 섹션 사용 중)     /// - returns: 행(Row)의 개수     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummyDataList.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.textLabel?.text = dummyDataList[indexPath.row]                  /// 셀의 서브 타이틀 설정         cell.detailTextLabel?.text = \"테스트\"         return cell     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension ViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   예제 2     더미 데이터 활용   struct DummyData {     let uuid: UUID     let title: String     let body: String          init() {         self.uuid = UUID()         self.title = \"타이틀입니다: \\(uuid)\"         self.body = \"바디입니다: \\(uuid)\"     }          static func getDumies(_ count: Int = 100) -&gt; [DummyData] {         return (1...count).map { _ in DummyData() }     } }   import UIKit  class ViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dummyDataList: [DummyData] = DummyData.getDumies()          override func viewDidLoad() {         super.viewDidLoad()         myTableView.dataSource = self         myTableView.delegate = self     } }  extension ViewController: UITableViewDataSource {          func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummyDataList.count     }          func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")         let cellData: DummyData = dummyDataList[indexPath.row]         cell.textLabel?.text = cellData.title         cell.detailTextLabel?.text = cellData.body         return cell     } }  extension ViewController: UITableViewDelegate {     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   예제 3     섹션의 header와 footer 활용   import Foundation  struct DummySection {     let uuid: UUID     let title: String     let body: String     let rows: [DummyData]          init() {         self.uuid = UUID()         self.title = \"섹션 타이틀입니다: \\(uuid)\"         self.body = \"섹션 바디입니다: \\(uuid)\"         self.rows = DummyData.getDumies(10)     }          static func getDumies(_ count: Int = 100) -&gt; [DummySection] {         return (1...count).map { _ in DummySection() }     } }  struct DummyData {     let uuid: UUID     let title: String     let body: String          init() {         self.uuid = UUID()         self.title = \"타이틀입니다: \\(uuid)\"         self.body = \"바디입니다: \\(uuid)\"     }          static func getDumies(_ count: Int = 100) -&gt; [DummyData] {         return (1...count).map { _ in DummyData() }     } }   import UIKit  class ViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dummySections: [DummySection] = DummySection.getDumies()          override func viewDidLoad() {         super.viewDidLoad()                  myTableView.dataSource = self         myTableView.delegate = self     } }  extension ViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")         let sectionData: DummySection = dummySections[indexPath.section]         let cellData: DummyData = sectionData.rows[indexPath.row]         cell.textLabel?.text = cellData.title         cell.detailTextLabel?.text = cellData.body         return cell     } }  extension ViewController: UITableViewDelegate {     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   예제 4     Fakery 라이블러리 활용   import Foundation import Fakery  struct DummySection {     let uuid: UUID     let title: String     let body: String     let rows: [DummyData]          init() {         self.uuid = UUID()         self.title = \"섹션 타이틀입니다: \\(uuid)\"         self.body = \"섹션 바디입니다: \\(uuid)\"         self.rows = DummyData.getDumies(10)     }          static func getDumies(_ count: Int = 100) -&gt; [DummySection] {         return (1...count).map { _ in DummySection() }     } }  struct DummyData {     let uuid: UUID     let title: String     let body: String          init() {         self.uuid = UUID()         let faker = Faker(locale: \"ko\")         let firstName = faker.name.firstName()  //=&gt; \"Emilie\"         let lastName = faker.name.lastName()    //=&gt; \"Hansen\"                  let body = faker.lorem.paragraphs(amount: 10)                  self.title = \"타이틀입니다: \\(lastName) \\(firstName)\"         self.body = \"바디입니다: \\(body)\"     }          static func getDumies(_ count: Int = 100) -&gt; [DummyData] {         return (1...count).map { _ in DummyData() }     } }   import UIKit  class ViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dummySections: [DummySection] = DummySection.getDumies()          override func viewDidLoad() {         super.viewDidLoad()                  myTableView.dataSource = self         myTableView.delegate = self     } }  extension ViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")         let sectionData: DummySection = dummySections[indexPath.section]         let cellData: DummyData = sectionData.rows[indexPath.row]         cell.textLabel?.text = cellData.title         cell.detailTextLabel?.text = cellData.body         return cell     } }  extension ViewController: UITableViewDelegate {     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }  ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 2. 스토리보드로 여러 화면 분기하기",
        "excerpt":"    스토리보드로 여러 화면 분기하기      필요 파일      MainViewController   Main.storyboard   MainStoryboard에서 Command + Shift + L을 눌러서 Storyboard를 추가하고 우측 하단의 Embeded In을 눌러서 Navigation Controller(화면 이동 관할)을 추가한다.           다음으로 현재 Main스토리보드에서 어떤 화변이 먼저 실행이 될 지 정해줘야 한다. Attribute Inspector에서 is Initial View Controller 클릭해서 첫 시작 뷰 컨트롤러를 설정해준다.        filled버튼들을 추가하고 전체 버튼들을 드래그하여 Embed In 클릭 후 Stack View를 눌러준다 그러면 버튼들이 StackView로 묶인다. 버튼들을 Stack에 같은 크기로 채우려면 alignment를 fill로 해주고 Distribution은 Fill Equally로 해준다. 그 이후 StackView를 SafeArea로 드래그하여 horizontal, vertical 각각 center 지정해준다. 주황색이 뜨면 새로고침 눌러준다.      alignment(정렬)는 요소들이 한 축을 기준으로 어떻게 정렬될지를 결정한다.  horizontal stack view일 경우:     .leading → 왼쪽 정렬   .center → 가운데 정렬   .trailing → 오른쪽 정렬   .top, .bottom → 요소들의 수직 위치 정렬 방식도 있음      distribution(분배)는 여러 UI 요소를 Stack View 안에서 얼마나 넓게 어떻게 나눌지 결정한다.  .fill → 가능한 공간만큼 채움  .fillEqually → 모든 요소가 동일한 크기로 공간 분배  .fillProportionally → 각 요소의 원래 크기 비율에 따라 분배  .equalSpacing → 요소들 사이 간격을 동일하게 유지  .equalCentering → 중심점 기준으로 균등하게 배치        Default버튼을 우측 ViewController쪽으로 드래그하여 Show를 눌러준다 이때 ViewController는 CustomClass에서 Class설정을 해줘서 ViewController코드와 연결해둬야한다. 그러면 Default를 누르면 화면이동이 된다. 동일하게 나머지 버튼들도 ViewController를 만들어서 연결해준다.        완성하면 이렇게 되는데 MainStoryBoard 파일 안에서 View가 많아지게 되면 상당히 무거워지기 때문에 작업이 힘들어 진다. 추천하는 방식은 Reference 방식이다.        StoryboardList.storyboard를 만들고 만들면 제공되는 ViewController를 없앤다. 그럼 이렇게 빈 화면이 나온다. 그리고 MainStoryboard에 있는 Storyboard 타이틀 VC를 Control + X로 잘라내어 StoryboardList.storyboard에 붙여넣는다        그리고 나서 타이틀을 설정해준다. 그리고 MainStoryboard로 가서 Command + Shift + L로 reference검색해서 드래그한다. 이는 스토리보드에 대한 참조(메모리 주소)이다. 즉 이로 서로 연걸이 되게끔 할 수 있다.        스토리보드Id를 설정한다 보통 클래스이름과 동일하게 적는다. 여기서 사진에는 표시 안되어 있지만 Use StoryboardId 체크 클릭해준다.          스토리보드와 스토리보드Id를 적어준다. 그리고 Identifier도 동일하게 스토리보드Id를 적어준다.        최종적으로 참조에 드래그를 해서 show로 지정해준다. 이러면 이전의 방식과 동일한 방식이다. 이렇게 하면 작업이 용이해진다. 나머지 코드들도 동일하게 해주자.       최종화면      ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 3. 스토리보드로 커스텀 테이블뷰 구현하기",
        "excerpt":"    스토리보드로 커스텀 테이블뷰 구현하기                           기존 셀     구현할 커스텀 셀     위 왼쪽 사진은 1. 테이블뷰 예제에서 구현한 방식이다. 사진처럼 셀 스타일이 기본 셀이라서 커스텀을 할 수 없다. 그래서 보통 UITableViewCell을 상속받아 커스텀 Cell Class를 만들어 입맛대로 만든다. 커스텀 Cell 적용 방식이 1. 스토리보드, 2. Nib파일, 3. 코드 방식 총 3가지가 있는데 이번 포스팅에서는 스토리보드 방식으로 커스템 셀 구현을 진행한다.         Shift + Command + L을 눌러서 TableView를 추가하고 상하좌우 제약을 0을 주도록 설정한다. 삼각형 모양이 Size Inspector이다.         Shift + Command + L을 눌러서 Table View Cell을 드래그해준다 이를 등록 과정(register)이라고 한다. ContentView가 핵심이다. 여기에 요소들 집어넣는다. 우측상단의 Raw Height로 셀 높이를 지정할 수 있다.         상단 Label은 Leading과 Top 걸어주고 하단 Label은 상단의 Leading, Vertical Spacing 설정, Bottom도 설정해준다. 이후 상단의 leading제약을 10으로 해준다. 그리고 상단 Label의 Top 제약을 10으로 걸면 빨간 에러가 뜬다.   Label 자체는 크기를 가지고 있지 않기 때문에 상단 Label을 늘릴지 하단 Label이 늘릴지 정해줘야한다.         상단Label의 크기는 유지하고 하단 Label의 크기를 늘려서 하단 Label의 Content Hugging Priority의 Vertical을 줄이면 된다.         마무리로 모든 제약을 10으로 해준다.        긴 문장이 들어오면 number of lines가 1이라서 뒷부분이 잘린다. 해결하기 위해 상단 label의 trailing도 10 제약을 준다.           두번째 Label에도 긴문장을 넣으면 뒷부분이 잘린다. 해결을 위해 number of lines를 0으로 하고 trailing도 10 잡아준다. 이때 빨간색 줄이 생기는데 이유는 number of lines가 0이라서 계속 늘어나기 때문이다. 늘어났을 때 ContentView 사이즈공간이 모자라서 상단 Label을 밀어내려고 하기 떄문에 발생한다. 이를 해결하기 위해 Compression Resistance를 설정해야한다. 만약 하단 Label의 vertical을 751로 올리면 상단 Label이 없어진다. 그래서 상단Label을 누르고 Compression Resistance를 751로올려야한다.                     항목       설명       효과                       Content Hugging = 낮음       늘어나도 괜찮음       다른 뷰들이 먼저 자기 크기 유지                 Compression Resistance = 낮음       줄어들어도 괜찮음       다른 뷰가 먼저 자기 크기 지킴                 상단 Label Hugging 높음       상단 Label이 더 이상 안 늘어나려 함       하단 Label이 늘어남                 상단 Label Resistance 높음       상단 Label이 안 줄어들고 버팀       하단 Label이 줄어듦           🔚 정리      Hugging: “나는 커지기 싫어”(숫자 높을수록 안커짐)   Compression Resistance: “나는 작아지기 싫어”(숫자 높을수록 안작아짐)   위 두 값을 적절히 조절해주면, Auto Layout이 충돌 없이 어떤 뷰가 늘어나거나 줄어들지 결정하게 된다.        import Foundation import UIKit  class StoryboardCell: UITableViewCell {     /// 1. 셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. awakeFromNib     override class func awakeFromNib() {         /// 2. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다         super.awakeFromNib()     } }   이제 커스텀 셀을 만들어야 한다. StoryboardCell.swift파일을 만들어준다.  셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. 이 라이프사이클을 awakeFromNib라고 한다. -&gt; Interface Builder같이 스토리보드로 추가되거나 Nib파일로 되었을 경우에 awakeFromNib()가 호출된다 ViewController의 ViewDidload랑 비슷한 역할이다. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다.          Label이 드래그안될때는 당황하지말고 직접 @IBOutlet weak var로 선언해준다. 그리고 반대로 드래그해서 Label로 연결시켜주면 된다. 알고보니 StoryboardList의 StoryboardCell의 CustomClass설정을 StoryboardCell로 해줘야하는데 안되있어서 연결이 안된 것이었다. 주의하자. 이까지 완료되면 등록 과정(Register) 완료이다.      // 커스텀 셀 import Foundation import UIKit  class StoryboardCell: UITableViewCell {          @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          /// 1. 셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. awakeFromNib     override func awakeFromNib() {         /// 2. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다         super.awakeFromNib()         print(#fileID, #function, #line, \"- awakeFromNib()\")     } }   // //  StoryboardListViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/8/25. //  import UIKit  class StoryboardListViewController: UIViewController {      @IBOutlet weak var MyTableView: UITableView!          var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         super.viewDidLoad()         self.MyTableView.dataSource = self         self.MyTableView.delegate = self     } }  /// UITableView의 데이터 관리 역할을 담당 extension StoryboardListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension StoryboardListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    이제 StoryboardListViewController로 돌아와서 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) 여기서 수정한다. 기존의 let cell 부분을 주석처리하고 바로 셀을 생성하는게 아니라 테이블 뷰 자체는 메모리를 재사용한다고 했으니 재사용 셀을 설정하기 위해 dequeueReusableCell를 설정한다.현재 셀을 가져온다.   Reference      https://hanipsum.com   ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView3/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 4. Nib으로 커스텀 테이블뷰 구현하기",
        "excerpt":"    Nib으로 커스텀 테이블뷰 구현하기                           Storyboard 커스텀 셀     Nib 커스텀 셀         파일만들기 -&gt; Cocoa Toucn -&gt; Nib파일이름, 체크박스 체크로 2개의 파일을 만든다. 그러면 Nib파일과, Swift파일이 생성된다.            TitleLabel만들고 ContentView로 드래그하여 Leading, Top, Trailing을 체크해준다. 그리고 이번에는 타이틀 Label의 number of lines를 1로 하자.            BodyLabel을 TitleLabel로 드래그하여 Leading, Vertical Spacing 체크해준다.   그리고 BodyLabel을 ContentView로 드래그하여 Trailing을 채크해준다.(TitleLabel은 한줄이라서..?)               Identifier, Class 설정해준다.             import UIKit  class NibCell: UITableViewCell {     @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          override func awakeFromNib() {         super.awakeFromNib()         self.backgroundColor = .systemMint     } }   IBOutlet 추가한다.                NibListStoryboard에서 테이블만들고 My Table View 이름 지정.해준다. 그리고 이를 NibListViewController에 드래그하여 myTableView만들어준다.          fileprivate func configureTableView() {      // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.     let cellNib = UINib(nibName: \"NibCell\", bundle: nil)     self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")      self.myTableView.dataSource = self     self.myTableView.delegate = self }   이대로 실행하면 에러가난다. Storyboard 방식과 달리 Nib 방식으로 할때는 등록 절차를 직접 해줘야 한다.          전체코드   NibCell.xib      NibCell.swift   // //  NibCell.swift //  UITableViewTutorial // //  Created by 김동현 on 5/11/25. //  import UIKit  class NibCell: UITableViewCell {           @IBOutlet weak var titleLabel: UILabel!          @IBOutlet weak var bodyLabel: UILabel!          override func awakeFromNib() {         super.awakeFromNib()         self.backgroundColor = .systemMint     }      /*     override func setSelected(_ selected: Bool, animated: Bool) {         super.setSelected(selected, animated: animated)          // Configure the view for the selected state     }      */ }    NibListViewController   // //  NibListViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/8/25. //  import UIKit  class NibListViewController: UIViewController {           @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.         let cellNib = UINib(nibName: \"NibCell\", bundle: nil)         self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }  /// UITableView의 데이터 관리 역할을 담당 extension NibListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"NibCell\", for: indexPath) as? NibCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension NibListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView4/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 5. 코드기반 커스텀 테이블뷰 구현하기",
        "excerpt":"    코드기반 커스텀 테이블뷰 구현하기                                  Storyboard 커스텀 셀     Nib 커스텀 셀       Code 커스텀 셀         CodeList.xiv파일로 와서 테이블뷰를 드래그해서 추가 후 제약조건을 상하좌우 전부 0으로 해준다.         myTableView를 ViewController로 드래그해서 IBOutlet 추가한다. 이떄 추가가안되면 xib파일의 viewController가 연결되있는지 확인한다.      CodeCell.swift   // //  CodeCell.swift //  UITableViewTutorial // //  Created by 김동현 on 5/11/25. //  import UIKit  class CodeCell: UITableViewCell {          lazy var titleLabel: UILabel = {         let label = UILabel()         label.translatesAutoresizingMaskIntoConstraints = false         label.text = \"타이틀 라벨타이틀 라벨타이틀 라벨타이틀 라벨타이틀 라벨\"         label.numberOfLines = 1         label.font = UIFont.systemFont(ofSize: 14, weight: .bold)         return label     }()          lazy var bodyLabel: UILabel = {         let label = UILabel()         label.translatesAutoresizingMaskIntoConstraints = false         label.text = \"바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨\"         label.numberOfLines = 0         label.font = UIFont.systemFont(ofSize: 12, weight: .regular)         return label     }()          fileprivate func configureUI() {         self.backgroundColor = .systemYellow                  // 타이틀 라벨 설정         self.contentView.addSubview(self.titleLabel)         NSLayoutConstraint.activate([             titleLabel.topAnchor.constraint(equalTo: self.contentView.topAnchor, constant: 10),             titleLabel.leadingAnchor.constraint(equalTo: self.contentView.leadingAnchor, constant: 10),             titleLabel.trailingAnchor.constraint(equalTo: self.contentView.trailingAnchor, constant: -10),         ])                  // 바디 라벨 설정         self.contentView.addSubview(self.bodyLabel)         NSLayoutConstraint.activate([             bodyLabel.topAnchor.constraint(equalTo: self.titleLabel.bottomAnchor, constant: 10),             bodyLabel.leadingAnchor.constraint(equalTo: self.contentView.leadingAnchor, constant: 10),             bodyLabel.trailingAnchor.constraint(equalTo: self.contentView.trailingAnchor, constant: -10),             bodyLabel.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -10)         ])     }          // 원래는 awakefromnib을 타지만 코드로 UI를 진행한다면 awakefromnib을 타지 않는다.     override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {         super.init(style: style, reuseIdentifier: reuseIdentifier) /// 부모의 로직을 싱행시키는 의미         configureUI()     }          required init?(coder: NSCoder) {         super.init(coder: coder)     }          override func layoutSubviews() {         super.layoutSubviews()     } }    #if DEBUG import SwiftUI  extension UIView {     private struct ViewRepresentable: UIViewRepresentable {         let uiView: UIView         func updateUIView(_ uiView: UIViewType, context: Context) {         }         func makeUIView(context: Context) -&gt; some UIView {             uiView         }     }          func getPreview() -&gt; some View {         ViewRepresentable(uiView: self)     } } #endif  #if DEBUG import SwiftUI  struct CodeCell_PreviewProvider_Previews: PreviewProvider {     static var previews: some View {         CodeCell().getPreview()             .previewLayout(.fixed(width: 200, height: 100))     } } #endif    CodeListViewController   // //  CodeListViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/8/25. //  import UIKit  class CodeListViewController: UIViewController {           @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)         override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CodeCell.self, forCellReuseIdentifier: \"CodeCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   /// UITableView의 데이터 관리 역할을 담당 extension CodeListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CodeCell\", for: indexPath) as? CodeCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension CodeListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    참고: 테이블뷰도 완전 코드베이스로 하는법   // //  MainViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/8/25. //  import UIKit  class MainViewController: UIViewController {           override func viewDidLoad() {         super.viewDidLoad()         print(\"MainViewController loaded\")     }          @IBAction func codeButtonTapped(_ sender: UIButton) {         print(\"눌림\")         let vc = OnlyCodeBaseViewController()         self.navigationController?.pushViewController(vc, animated: true)     } }    // //  OnlyCodeBaseViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/11/25. //  import UIKit  class OnlyCodeBaseViewController: UIViewController {          private let myTableView: UITableView = {         let tableView = UITableView()         tableView.translatesAutoresizingMaskIntoConstraints = false         return tableView     }()          private func setupTableView() {         view.addSubview(myTableView)         NSLayoutConstraint.activate([             myTableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),             myTableView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),             myTableView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),             myTableView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)         ])     }          private func configureTableView() {         myTableView.register(CodeCell.self, forCellReuseIdentifier: \"CodeCell\")         myTableView.dataSource = self         myTableView.delegate = self     }          var dummySections: [DummySection] = DummySection.getDumies(10)      override func viewDidLoad() {         super.viewDidLoad()         view.backgroundColor = .white         setupTableView()         configureTableView()     } }  /// UITableView의 데이터 관리 역할을 담당 extension OnlyCodeBaseViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CodeCell\", for: indexPath) as? CodeCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension OnlyCodeBaseViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView5/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 6. Cell Configuration",
        "excerpt":"    Cell Configuration 알아보기   Cell Configuration은 iOS 14+부터 도입된 기능으로, 셀의 UI 구성과 데이터 설정을 보다 선언적으로 처리할 수 있도록 도와준다.   기존에는 셀마다 IBOutlet을 연결하거나, cell.textLabel.text = ... 방식으로 직접 설정했지만,    Cell Configuration은 UI와 데이터를 분리하고 설정 구조체를 통해 셀 내부 뷰를 생성 및 업데이트하는 구조다.    화면 구성 예시         테이블뷰를 스토리보드에서 추가하고, 상하좌우 제약을 0으로 설정한다               Storyboard ID는 CellConfigurationListViewController로 지정   Reference ID도 동일하게 맞춰야 코드에서 호출 가능     구성   Cell Configuration을 구성하는 핵심 요소는 다음과 같다:                  요소       설명                       UIContentConfiguration       데이터 설정을 위한 구조체 역할 (예: MyCellConfiguration)                 UIContentView       실제 UI를 그리는 뷰 (예: CellConfigurationView)                 UITableViewCell       시스템이 자동으로 UIContentView를 삽입해주는 셀 컨테이너 (CellConfigTableViewCell)             1. MyCellConfiguration.swift   struct MyCellConfiguration: UIContentConfiguration, Hashable {     var title: String = \"\"     var body: String = \"\"      func makeContentView() -&gt; UIView &amp; UIContentView {         return CellConfigurationView(config: self)     }      func updated(for state: UIConfigurationState) -&gt; MyCellConfiguration {         var updated = self         if let state = state as? UICellConfigurationState, state.isSelected {             updated.title = \"선택됨: \" + updated.title         }         return updated     } }      데이터(title, body)를 담고 있고, 상태(state)에 따라 동적으로 내용도 바꿀 수 있다.   makeContentView()를 통해 실제 UIContentView (CellConfigurationView) 생성     2. CellConfigurationView.swift   class CellConfigurationView: UIView, UIContentView {     var configuration: UIContentConfiguration {         get { customConfiguration }         set {             if let config = newValue as? MyCellConfiguration {                 applyConfig(config)             }         }     }      init(config: MyCellConfiguration) {         super.init(frame: .zero)         configureUI()         applyConfig(config)     }      fileprivate func applyConfig(_ config: MyCellConfiguration) {         self.customConfiguration = config         titleLabel.text = config.title         bodyLabel.text = config.body     } }      UIView이자 UIContentView를 채택   외부에서 전달받은 MyCellConfiguration을 적용해서 UILabel에 반영   내부적으로 titleLabel, bodyLabel을 AutoLayout으로 배치     3. CellConfigTableViewCell.swift   class CellConfigTableViewCell: UITableViewCell {     var title: String = \"\" {         didSet { setNeedsUpdateConfiguration() }     }      var body: String = \"\" {         didSet { setNeedsUpdateConfiguration() }     }      override func updateConfiguration(using state: UICellConfigurationState) {         var config = MyCellConfiguration().updated(for: state)         config.title = title         config.body = body         self.contentConfiguration = config     } }      setNeedsUpdateConfiguration() 호출 시 시스템이 updateConfiguration(using:)을 호출   title, body를 가지고 MyCellConfiguration을 만든 뒤 contentConfiguration에 설정   시스템은 이 설정을 보고 자동으로 CellConfigurationView를 생성 및 삽입     4. CellConfigurationListViewController.swift   func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {     guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CellConfigTableViewCell\", for: indexPath) as? CellConfigTableViewCell else {         return UITableViewCell()     }      let cellData = dummySections[indexPath.section].rows[indexPath.row]     cell.title = cellData.title     cell.body = cellData.body     return cell }      더미 데이터를 불러와 title, body만 할당하면 자동으로 UI가 구성된다   직접적으로 UILabel에 접근하거나 cell.subviews를 조작하지 않아도 된다     전체 예제 코드   1. MyCellConfiguration.swift   import UIKit  // 커스텀 셀에 대한 설정 struct MyCellConfiguration: UIContentConfiguration, Hashable {          var title: String = \"\"     var body: String = \"\"          // 보여줄 화면     // UIView이면서 UIContentView인 애를 반화내라     func makeContentView() -&gt; any UIView &amp; UIContentView {         return CellConfigurationView(config: self)     }               /// 셀 상태가 변경되면 발동     /// - Parameter state: 셀 상태     /// - Returns: 셀 설정 자체     func updated(for state: any UIConfigurationState) -&gt; MyCellConfiguration {         if let state = state as? UICellConfigurationState {             var updatedConfig = self                          if state.isSelected {                 updatedConfig.title = \"선택됨: \" + updatedConfig.title             }             return updatedConfig         }         return self     } }   2. CellConfigurationView.swift   import UIKit  // 뷰 안에 컨텐츠 Config를 가지고 있는 뷰 class CellConfigurationView: UIView, UIContentView {          // 여러 데이터를 가진 덩어리     fileprivate var customConfiguration: MyCellConfiguration!          // 데이터와 UI를 연결     fileprivate func applyConfigAndChangeUI(_ newConfiguration: MyCellConfiguration) {         self.customConfiguration = newConfiguration         titleLabel.text = newConfiguration.title         bodyLabel.text = newConfiguration.body     }          var configuration: UIContentConfiguration {         get { customConfiguration }         set {             if let newConfiguration = newValue as? MyCellConfiguration {                 applyConfigAndChangeUI(newConfiguration)             }         }     }         init(config: MyCellConfiguration) {         super.init(frame: .zero)         configureUI()         applyConfigAndChangeUI(config)     }      lazy var titleLabel: UILabel = {         let label = UILabel()         label.translatesAutoresizingMaskIntoConstraints = false         label.text = \"타이틀 라벨타이틀 라벨타이틀 라벨타이틀 라벨타이틀 라벨\"         label.numberOfLines = 1         label.textColor = .white         label.font = UIFont.systemFont(ofSize: 14, weight: .bold)         return label     }()          lazy var bodyLabel: UILabel = {         let label = UILabel()         label.translatesAutoresizingMaskIntoConstraints = false         label.text = \"바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨\"         label.numberOfLines = 0         label.textColor = .white         label.font = UIFont.systemFont(ofSize: 12, weight: .regular)         return label     }()          fileprivate func configureUI() {         self.backgroundColor = .systemBlue                  // 타이틀 라벨 설정         self.addSubview(self.titleLabel)         NSLayoutConstraint.activate([             titleLabel.topAnchor.constraint(equalTo: self.topAnchor, constant: 10),             titleLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 10),             titleLabel.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: -10),         ])                  // 바디 라벨 설정         self.addSubview(self.bodyLabel)         NSLayoutConstraint.activate([             bodyLabel.topAnchor.constraint(equalTo: self.titleLabel.bottomAnchor, constant: 10),             bodyLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 10),             bodyLabel.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: -10),             bodyLabel.bottomAnchor.constraint(equalTo: self.bottomAnchor, constant: -10)         ])     }          required init?(coder: NSCoder) {         super.init(coder: coder)     }          override func layoutSubviews() {         super.layoutSubviews()     } }  #if DEBUG import SwiftUI  struct CellConfigurationView_PreviewProvider_Previews: PreviewProvider {     static var previews: some View {         CellConfigurationView(config: MyCellConfiguration(title: \"오늘도 코딩\", body: \"바디부분\")).getPreview()             .previewLayout(.fixed(width: 200, height: 100))     } } #endif   3. CellConfigTableViewCell.swift   import UIKit  // 기존 테이블뷰 셀은 데이터만 신경쓰면 됨 class CellConfigTableViewCell: UITableViewCell {          // 데이터 변경시 UI 변경해라     var title: String = \"\" {         didSet {             setNeedsUpdateConfiguration()         }     }          var body: String = \"\" {         didSet {             setNeedsUpdateConfiguration()         }     }      override func updateConfiguration(using state: UICellConfigurationState) {         super.updateConfiguration(using: state)                  var contentConfig = MyCellConfiguration().updated(for: state)         contentConfig.title = title         contentConfig.body = body         self.contentConfiguration = contentConfig     }          override func layoutSubviews() {         super.layoutSubviews()     } }  #if DEBUG import SwiftUI  struct CellConfigTableViewCell_PreviewProvider_Previews: PreviewProvider {     static var previews: some View {         CodeCell().getPreview()             .previewLayout(.fixed(width: 200, height: 100))     } } #endif   4. CellConfigurationListViewController.swift   import UIKit  class CellConfigurationListViewController: UIViewController {          @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         configureTableView()     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: \"CellConfigTableViewCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   /// UITableView의 데이터 관리 역할을 담당 extension CellConfigurationListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CellConfigTableViewCell\", for: indexPath) as? CellConfigTableViewCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         // cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         // cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0                  // 여기서는 UI에 접근하는게 아니라 Cell이 가지고 있는 멤버변수 데이터 자체에 접근         cell.title = cellData.title         cell.body = cellData.body         return cell     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension CellConfigurationListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }  ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView6/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 7. UITableViewCell 확장을 통해 셀 식별자 코드 재사용",
        "excerpt":"    코드 재사용   /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라 /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 /// - returns: 구성된 UITableViewCell 객체 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {     /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)     /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")      // [guard let] 방식     guard let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell else {         return UITableViewCell()     }      let sectionData: DummySection = dummySections[indexPath.section]      let cellData: DummyData = sectionData.rows[indexPath.row]      /// 셀의 주 텍스트를 더미 데이터에서 가져오기     cell.titleLabel.text = cellData.title      /// 셀의 서브 타이틀 설정     cell.bodyLabel.text = cellData.body      //cell.detailTextLabel?.numberOfLines = 0     return cell }   지금까지 재사용되는 셀은 고유한 식별자를 상수로 넣어주는데 보통 클래스 명을 써주었다.   프로그래밍 하면서 상수가 있는 부분은 최대한 피하는게 좋다. 이유는 상수를 재사용할 수도 있고 오타가 발생할 수 있기 때문이다.      class StoryboardCell: UITableViewCell {          // 변수로     static let reuseIdentifier: String = \"StoryboardCell\"          @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          /// 1. 셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. awakeFromNib     override func awakeFromNib() {         /// 2. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다         super.awakeFromNib()         print(#fileID, #function, #line, \"- awakeFromNib()\")         self.backgroundColor = .systemYellow     } }   guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {     return UITableViewCell() }   그래서 셀에서 static으로 상수로 추가해둔다. 이 방법도 충분하지만 조금 더 편하게 할 수 있다.  UITableviewCell 자체가 전부 reuseIdentifier라는 static변수를 가질 수 있게 하면 더 편리해질 수 있다.       extension UITableViewCell {     static var reuseIdentifier: String {         return String(describing: Self.self) // 현재 타입.현재 타입의 타입 그자체, 현재 타입의 타입 객체(메타타입)     } }    참고로 확장에서는 저장 속성을 정의할 수 없음으로 계산 속성으로 변경해준다.       extension UITableViewCell {     static var reuseIdentifier: String {         return String(describing: Self.self) // 현재 타입.현재 타입의 타입 그자체, 현재 타입의 타입 객체(메타타입)     } }  extension UICollectionView {     static var reuseIdentifier: String {         return String(describing: Self.self) // 현재 타입.현재 타입의 타입 그자체, 현재 타입의 타입 객체(메타타입)     } }   하지만 이 방식도 UItableView, UICollectionVIew각각마다 만들어줘야하는 불편함이 있다.  반복을 더 줄일 수 있다.      protocol ReuseIdentifiable {     // 프로토콜에서 로직을 정의할 수 없어서 가져올 수 있도록 설정     static var reuseIdentifier: String { get } }  extension ReuseIdentifiable {     // 로직에 대한 정의는 Extension에서 간능     static var reuseIdentifier: String {         return String(describing: Self.self)     } }  // ReuseIdentifiable 채택 class StoryboardCell: UITableViewCell, ReuseIdentifiable {      @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          override func awakeFromNib() {         super.awakeFromNib()         print(#fileID, #function, #line, \"- awakeFromNib()\")         self.backgroundColor = .systemYellow     } }   프로토콜을 활용해서 해결하자. 프로토콜 이름은 아래 컨벤션을 따르면 좋다.  https://www.swift.org/documentation/api-design-guidelines/      class NibListViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.         let cellNib = UINib(nibName: \"NibCell\", bundle: nil)         self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   이를 활용하면 Nib파일을 등록할때도 적용할 수 있다. NibCell을 상수로 사용하지 않고 프로토로 해결해보자.      최종 코드   import UIKit  protocol Nibbed {     static var uinib: UINib { get } }  extension Nibbed {     static var uinib: UINib {         return UINib(nibName: String(describing: Self.self), bundle: nil)     } }  protocol ReuseIdentifiable {     // 프로토콜에서 로직을 정의할 수 없어서 가져올 수 있도록 설정     static var reuseIdentifier: String { get } }  extension ReuseIdentifiable {     // 로직에 대한 정의는 Extension에서 간능     static var reuseIdentifier: String {         return String(describing: Self.self)     } }  extension UITableViewCell: Nibbed, ReuseIdentifiable {}  class NibListViewController: UIViewController {          @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.         // let cellNib = UINib(nibName: \"NibCell\", bundle: nil)                  // self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")         self.myTableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView7/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 8. 데이터 소스 이해, 따로써보기",
        "excerpt":"    8. 데이터 소스 이해, 따로써보기   테이블 뷰 만들기(List)      테이블뷰 컨트롤러로 만들기(기능이 한정적) vs 일반 뷰 컨트롤러로 만들기   우리는 일반 뷰 컨트롤러를 주로 쓰자   구성                     데이터 소스 - 데이터와 연관, 셀의 종류를 정하기, 보여줄 셀의 개수가 몇개인지 정하기             class viewController: UIViewController {}            extension viewController: UITableViewDataSource {       /// 섹션 내의 셀 개수를 반환하는 메서드       /// - Parameters:       ///   - tableView: 데이터를 표시할 테이블 뷰       ///   - section: 현재 섹션 인덱스       /// - Returns: 해당 섹션에 표시할 행(row)의 개수       func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {           // 예: return items.count       }                    /// 각 행에 표시될 셀을 반환하는 메서드       /// - Parameters:       ///   - tableView: 셀을 표시할 테이블 뷰       ///   - indexPath: 현재 행의 위치 정보 (섹션, row)       /// - Returns: 구성된 UITableViewCell 객체       func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {           // 예:           // let cell = tableView.dequeueReusableCell(withIdentifier: \"CellIdentifier\", for: indexPath)           // cell.textLabel?.text = items[indexPath.row]           // return cell       }   }                       델리겟 - 이벤트 처리(특정 셀 선택) = 테이블뷰에 대한 액션       셀 - 테이블뷰에 들어가는 알맹이           DataSource를 따로 빼보기   기존 코드   Cell 파일은 수정 x   protocol Nibbed {     static var uinib: UINib { get } }  extension Nibbed {     static var uinib: UINib {         return UINib(nibName: String(describing: Self.self), bundle: nil)     } }  protocol ReuseIdentifiable {     // 프로토콜에서 로직을 정의할 수 없어서 가져올 수 있도록 설정     static var reuseIdentifier: String { get } }  extension ReuseIdentifiable {     // 로직에 대한 정의는 Extension에서 간능     static var reuseIdentifier: String {         return String(describing: Self.self)     } }  extension UITableViewCell: Nibbed {} extension UITableViewCell : ReuseIdentifiable { } extension UITableViewHeaderFooterView : ReuseIdentifiable {}  class StoryboardCell: UITableViewCell {          // 변수로     //static let reuseIdentifier: String = \"StoryboardCell\"          @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          /// 1. 셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. awakeFromNib     override func awakeFromNib() {         /// 2. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다         super.awakeFromNib()         print(#fileID, #function, #line, \"- awakeFromNib()\")         self.backgroundColor = .systemYellow     } }   import UIKit  class StoryboardListViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dummySections: [DummySection] = DummySection.getDummies(10)          override func viewDidLoad() {         super.viewDidLoad()         self.myTableView.dataSource = self         self.myTableView.delegate = self     } }  /// UITableView의 데이터 관리 역할을 담당 extension StoryboardListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension StoryboardListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   수정된 코드   import UIKit  class MyDataSource: NSObject, UITableViewDataSource {          var dummySections: [DummySection] = DummySection.getDummies()          override init() {         super.init()     }          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell     } }    import UIKit  class StoryboardListViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dataSource: MyDataSource = MyDataSource()          override func viewDidLoad() {         super.viewDidLoad()         self.myTableView.dataSource = dataSource         self.myTableView.delegate = self     } }   /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension StoryboardListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   NibListViewController도 MyDataSource로수정 가능   기존 코드   import UIKit  class NibListViewController: UIViewController {           @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDummies(10)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.         // let cellNib = UINib(nibName: \"NibCell\", bundle: nil)                  // self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")         self.myTableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }  /// UITableView의 데이터 관리 역할을 담당 extension NibListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"NibCell\", for: indexPath) as? NibCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension NibListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    수정된 코드   import UIKit  class MyDataSource: NSObject, UITableViewDataSource {          enum ListType {         case storyboard         case nib         case code         case cellConfig     }          var listType: ListType = .storyboard          var dummySections: [DummySection] = DummySection.getDummies()          override init() {         super.init()     }          convenience init(type: ListType = .storyboard) {         self.init()         self.listType = type     }          // MARK: - 셀을 등록하는 소스 관련     /// 셀을 등록     /// 스토리보드에서 셀을 추가하면 Xcode가 내부적으로 셀을 자동 등록한다     /// 이코드가 자동 등록된다고 생각 tableView.dequeueReusableCell(withIdentifier: \"StoryboardCell\")     /// - Parameter tableView: 등록할 테이블뷰     func registerCells(with tableView: UITableView) {         tableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)     }          // MARK: -  테이블뷰 데이터 소스 관련     /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식                  switch listType {         case .storyboard:             guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .nib:             guard let cell = tableView.dequeueReusableCell(withIdentifier: NibCell.reuseIdentifier, for: indexPath) as? NibCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .code:             guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .cellConfig:             guard let cell = tableView.dequeueReusableCell(withIdentifier: CellConfigTableViewCell.reuseIdentifier, for: indexPath) as? CellConfigTableViewCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.title = cellData.title             cell.body = cellData.body             return cell         }     } }   import UIKit  class NibListViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dataSource: MyDataSource = MyDataSource(type: .nib)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {         // self.myTableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                  // 셀을 등록         self.dataSource.registerCells(with: myTableView)         self.myTableView.dataSource = dataSource         self.myTableView.delegate = self     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension NibListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   CellConfigurationListViewController도 MyDataSource로수정 가능   기존 코드   import UIKit  class CellConfigurationListViewController: UIViewController {          @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDummies(10)          override func viewDidLoad() {         configureTableView()     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: \"CellConfigTableViewCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   /// UITableView의 데이터 관리 역할을 담당 extension CellConfigurationListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CellConfigTableViewCell\", for: indexPath) as? CellConfigTableViewCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         // cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         // cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0                  // 여기서는 UI에 접근하는게 아니라 Cell이 가지고 있는 멤버변수 데이터 자체에 접근         cell.title = cellData.title         cell.body = cellData.body         return cell     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension CellConfigurationListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    수정된 코드   import UIKit  class MyDataSource: NSObject, UITableViewDataSource {          enum ListType {         case storyboard         case nib         case code         case cellConfig     }          var listType: ListType = .storyboard          var dummySections: [DummySection] = DummySection.getDummies(10)          override init() {         super.init()     }          convenience init(type: ListType = .storyboard) {         self.init()         self.listType = type     }          // MARK: - 셀을 등록하는 소스 관련     /// 셀을 등록     /// 스토리보드에서 셀을 추가하면 Xcode가 내부적으로 셀을 자동 등록한다     /// 이코드가 자동 등록된다고 생각 tableView.dequeueReusableCell(withIdentifier: \"StoryboardCell\")     /// - Parameter tableView: 등록할 테이블뷰     func registerCells(with tableView: UITableView) {         /// Nib 방식으로 만든 셀(NibCell.xib 파일)을 테이블 뷰에 등록         /// - NibCell.uinib : UINib(nibName: \"NibCell\", bundle: nil) 을 반환         /// - NibCell.reuseIdentifier : \"NibCell\" 문자열을 반환 (보통 클래스명을 기반으로 자동 생성)         /// → 이후 dequeue 시 이 identifier로 셀을 재사용할 수 있게 됨         /// tableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                  /// 코드로만 구현된 셀 클래스를 테이블 뷰에 등록         /// - CellConfigTableViewCell.self : 클래스 자체를 등록         /// - reuseIdentifier : \"CellConfigTableViewCell\" 문자열         /// → register(class:) 방식은 .xib 없이 순수 코드로 UI 구성한 셀에 사용         /// tableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: CellConfigTableViewCell.reuseIdentifier)         switch listType {         case .nib:             tableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                      case .code:             tableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier)                      case .cellConfig:             tableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: CellConfigTableViewCell.reuseIdentifier)                      case .storyboard:             // ❌ 스토리보드는 register 필요 없음!             break         }     }          // MARK: -  테이블뷰 데이터 소스 관련     /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식                  switch listType {         case .storyboard:             guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .nib:             guard let cell = tableView.dequeueReusableCell(withIdentifier: NibCell.reuseIdentifier, for: indexPath) as? NibCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .code:             guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .cellConfig:             guard let cell = tableView.dequeueReusableCell(withIdentifier: CellConfigTableViewCell.reuseIdentifier, for: indexPath) as? CellConfigTableViewCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.title = cellData.title             cell.body = cellData.body             return cell         }     } }   import UIKit  class CellConfigurationListViewController: UIViewController {          @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDummies(10)     var dataSource: MyDataSource = MyDataSource(type: .cellConfig)          override func viewDidLoad() {         configureTableView()     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요 //        self.myTableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: \"CellConfigTableViewCell\")                  self.dataSource.registerCells(with: myTableView)         self.myTableView.dataSource = dataSource         self.myTableView.delegate = self     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension CellConfigurationListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView8/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 9. 테이블뷰 콤바인 적용",
        "excerpt":"    테이블뷰 콤바인 적용   Combine이란?      iOS 13 이상부터 지원한다.   데이터를 리액티브 흐름으로 만들어서 데이터가 변경되면 이벤트 처리를 받을 수 있도록 설정할 수 있는데 보내는쪽을Publisher,  받는쪽을 Subscribe라고 한다.   기존 테이블뷰에서는 데이터를 dataSource에서 처리하였는데 ViewController에서 데이터 변경이 일어나면 dataSource와 연결시켜서 바로 테이블뷰에 보여줄 수 있다.     우선 CombineList.storyboard라는 이름으로 파일을 생성하고 테이블뷰를 만들어준다.   import UIKit import Combine  class CombineListViewController: UIViewController {          // Combine 메모리 처리를 위해 생성     var subscriptions = Set&lt;AnyCancellable&gt;()          // Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다.     @Published var dummies: [DummyData] = []          @IBOutlet weak var myTableView: UITableView!          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()                           /*         - sink는 @Published가 수정된 스레드에서 실행된다         - 그래서 Published변수 수정시 메인 스레드에서 수정해주자         - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다          */                  // $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨         // sink는 구독하는 것이다.         // AnyCancellable 구독한다고 한다.         // store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다.         $dummies             .receive(on: DispatchQueue.main)             // 데이터 변경시마다 동작             .sink(receiveValue: { (changedDummies: [DummyData]) in                 print(\"changedDummies: \\(changedDummies.count)\")                                  // sink는 메인스레드에서 동작해서 Dispatch안해도된다                 self.myTableView.reloadData()             })             .store(in: &amp;subscriptions)                  // 2초 뒤에 더미데이터 10개 추가         DispatchQueue.global().asyncAfter(deadline: .now() + 2, execute: {             self.dummies += DummyData.getDumies(10)         })     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier)                  self.myTableView.dataSource = self //        self.myTableView.delegate = self     } }   /// UITableView의 데이터 관리 역할을 담당 extension CombineListViewController: UITableViewDataSource {      /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummies.count     }      /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")          // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {             return UITableViewCell()         }          let cellData: DummyData = dummies[indexPath.row]          /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title          /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body          cell.detailTextLabel?.numberOfLines = 0         return cell     } }   그리고 연결할 CombineListViewController를 만들어준다.     Main.storyboard에서 Combine버튼 생성 후 reference 생성하고 Stoayboard이름과 Referenced ID도 추가해준다.  ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView9/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Baekjoon] 백준 2583 영역구하기",
        "excerpt":"   문제  영역 구하기     직사각형이 그려진 도화지에서 남은 영역의 개수와 넓이를 구하는 문제이다.   풀이  넓이 구하기 + Connected Component 개념을 알아야 한다.    /*  m x n(m세로, n가로 &lt;= 100)  직사각형 - k개   */  let (m, n, k): (Int, Int, Int) = { let input = readLine()!.split(separator: \" \").map { Int($0)! }; return (input[0], input[1], input[2]) }() var graph = Array(repeating: Array(repeating: false, count: n), count: m) var visited = Array(repeating: Array(repeating: false, count: n), count: m)  let dy = [-1, 0, 1, 0] let dx = [0, 1, 0, -1] var ret = 0 var arr: [Int] = []   func dfs(_ y: Int, _ x: Int) -&gt; Int {     visited[y][x] = true          var area = 1     for i in 0..&lt;4 {         let ny = y + dy[i]         let nx = x + dx[i]                  if ny&lt;0 || ny&gt;=m || nx&lt;0 || nx&gt;=n { continue }         if !visited[ny][nx] &amp;&amp; graph[ny][nx] == false {             area += dfs(ny, nx)         }     }     return area }  for _ in 0..&lt;k {     let input = readLine()!.split(separator: \" \").map { Int($0)! }     let (lx, ly) = (input[0], input[1])     let (rx, ry) = (input[2], input[3])          for y in ly..&lt;ry {         for x in lx..&lt;rx {             graph[y][x] = true         }     } }  for i in 0..&lt;m {     for j in 0..&lt;n {         if graph[i][j] == false &amp;&amp; !visited[i][j] {             ret+=1             let area = dfs(i,j)             arr.append(area)         }     } }  print(ret) print(arr.sorted().map { String($0) }.joined(separator: \" \"))  ","categories": [],
        "tags": ["Baekjoon"],
        "url": "/Baekjoon-2583/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[CodeLounge] Admob",
        "excerpt":"    SwiftUI에 Admob 광고 적용하기   1. Admob 설정 및 테스트 광고 ID   https://admob.google.com/v2/home      Admob 계정 생성(필수)   애플 앱스토어 등록(선택)            어플을 앱스토어에 등록 후 Admob 작업을 진행하는 게 훨 씬 수월하다.                               ca-app-pub-xxxxx와 같은 형태의 App ID가 발급된다.      // SKAdNetworkItems - IDFA 없이도 광고 성과 추적 (Apple 정책 대응) // NSUserTrackingUsageDescription - 사용자에게 추적 허용 요청 팝업 표시 // requestTrackingAuthorization() - 실제로 권한 요청하는 코드 // 기타 옵션들 - 광고 관련 기능(예: SKOverlay 등) 자동 지원 목적  &lt;key&gt;GADApplicationIdentifier&lt;/key&gt; &lt;string&gt;ca-app-pub-xxxxxxxxxxxxxxxx~yyyyyyyyyy&lt;/string&gt; &lt;key&gt;SKAdNetworkItems&lt;/key&gt; &lt;array&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;cstr6suwn9.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;4fzdc2evr5.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;4pfyvq9l8r.skadnetwork&lt;/string&gt;   &lt;/dict   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;2fnua5tdw4.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;ydx93a7ass.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;5a6flpkh64.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;p78axxw29g.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;v72qych5uu.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;ludvb6z3bs.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;cp8zw746q7.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;3sh42y64q3.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;c6k4g5qg8m.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;s39g8k73mm.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;3qy4746246.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;f38h382jlk.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;hs6bdukanm.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;v4nxqhlyqp.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;wzmmz9fp6w.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;yclnxrl5pm.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;t38b2kh725.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;7ug5zh24hu.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;gta9lk7p23.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;vutu7akeur.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;y5ghdn5j9k.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;n6fk4nfna4.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;v9wttpbfk9.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;n38lu8286q.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;47vhws6wlr.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;kbd757ywx3.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;9t245vhmpl.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;eh6m2bh4zr.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;a2p9lx4jpn.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;22mmun2rn5.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;4468km3ulz.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;2u9pt9hc89.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;8s468mfl3y.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;klf5c3l5u5.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;ppxm28t8ap.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;ecpz2srf59.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;uw77j35x4d.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;pwa73g5rt2.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;mlmmfzh3r3.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;578prtvx9j.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;4dzt52r2t5.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;e5fvkxwrpn.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;8c4e2ghe7u.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;zq492l623r.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;3rd42ekr43.skadnetwork&lt;/string&gt;   &lt;/dict&gt;   &lt;dict&gt;     &lt;key&gt;SKAdNetworkIdentifier&lt;/key&gt;     &lt;string&gt;3qcr597p9d.skadnetwork&lt;/string&gt;   &lt;/dict&gt; &lt;/array&gt;   발급된 App ID를 Info.plist에 추가한다.   2. Google Mobile Ads 설치(SPM)      Xcode -&gt; File -&gt; Add Package   입력 URL      https://github.com/googleads/swift-package-manager-google-mobile-ads.git           버전: 최신 선택   메인 앱 타겟만 체크 -&gt; Extension이 포함된 앱이더라도, 메인 앱에만 적용이 가능하다고 한다.   3. AppDelegate설정(광고 초기화)   // AppDelegate.swift import GoogleMobileAds  class AppDelegate: NSObject, UIApplicationDelegate {     func application(_ application: UIApplication,                      didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -&gt; Bool { \t\tMobileAds.shared.start(completionHandler: nil) // 추가         return true     } }   Reference      https://royzero.tistory.com/entry/SwiftUI-AdMob-적용하기   https://velog.io/@heejin62/SwiftUI-앱에-AdMob-적용하기-근데-이제-Trouble-Shooting을-곁들인   https://developers.google.com/admob/ios/test-ads?hl=ko   https://actumn.tistory.com/99   https://developers.google.com/admob/ios/privacy/strategies?hl=ko#skadnetwork   https://dev-apple.tistory.com/30   https://developers.google.com/admob/ios/test-ads?hl=ko#swift  ","categories": [],
        "tags": ["CodeLounge"],
        "url": "/CodeLounge-Admob/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Docker] Docker?",
        "excerpt":"    Docker  이식성 - 명령어 한 줄로 어떤 컴퓨터에서든 동일한 환경설정이 가능해 에러를 피할 수 있다.  ","categories": [],
        "tags": ["Docker"],
        "url": "/Docker-docker1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Recommendation System] 1. 추천시스템 소개",
        "excerpt":"    추천 시스템이란  추천 시스템이란 사용자의 과거 행동 데이터를 바탕으로 사용자에게 필요한 정보나 제품을 제시하는 시스템이다.   추천 시스템의 여러 기술     협업 필터링(Collaborative Filtering)   내용 기반 필터링(Content-Based Filtering)   지식 기반 필터링(Knowledge-Based Filtering)   딥러닝(Deep Learning)   하이브리드 필터링(협업필터링 &amp; 딥러닝)   1.1 협업 필터링 (Collaborative Filtering)  구매 및 소비한 제품에 대한 소비자의 평가 패턴이 비슷한 집단 속에서 서로 접하지 않은 제품을 추천하는 기술이다.  한계 - 소비자의 평가정보를 구하기 어렵다 ex)신규/휴먼 고객  해결책 - 구매가 아니라 클릭, 체류시간으로 간접적인 데이터로 협업 필터링 가능   1.2 내용 기반 필터링(Content-Based Filtering)  제품의 내용을 분석해서 추천하는 기술이다.   1.4 지식 기반 필터링(Knowledge-Based Filtering)  특정 분야 전문가의 도움을 받아서 그 분야에 대한 전체적인 지식 구조를 만들어서 활용하는 방법이다.   1.5 딥러닝(Deep Learning)  AI 알고리즘 중 현재 가장 많이 사용되는 딥러닝 방법이다.   1.6 하이브리드 필터링(협업필터링 &amp; 딥러닝)  두가지 이상의 알고리즘 혼합을 통한 하이브리드 형태이다.  ","categories": [],
        "tags": ["Recommendation System"],
        "url": "/Recommendation-System-Section1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Xcode] 프로젝트 개발 환경 세팅 자동화",
        "excerpt":"    1. 프로젝트 개발 환경 자동화 배경  팀 프로젝트르를 진행하면서 *.xcconfig, *.plist와 와 같은 숨겨야 하는 파일들이 생기게 된다. 이러한 파일들은 .gitignore에 추가하여 Git에 포함하지 않도록 한다. 이러한 Git의 관리를 받지 않는 파일은 팀원간 파일 공유를 수작업으로 진행해야 한다. 초기에는 카톡으로 주고 받았는데 수정하고 공유하는 과정이 매번 번거로웠다. 팀원에게 공유하는 것을 까먹게 되면 서로 다른 환경 속에서 프로젝트를 빌드, 개발하는 불상사가 발생할 수 있다.   2. 개발 환경 세팅을 한줄로 끝내는 명령어를 완성해보자  필요 기능     private files 다운로드   Homebrew 설치 자동화   fastlane 설치 인증서 다운로드   모든 작업 통합   make로 명령어 실행   1. private files 다운로드    우선 Private Repository를 만들어준다.      echo \"# CodeLounge-Private\" &gt;&gt; README.md git init git add README.md git commit -m \"first commit\" git branch -M main git remote add origin https://github.com/team-GitDeulida/CodeLounge-Private.git git push -u origin main   VScode에서 프로젝트 생성후 방금 만든 레포지토리를 설정한다.         // Config.xcconfig파일 생성 후 Hello World 작성 git add . git commit -m \"upload\" git push origin main   Config.xcconfig 테스트 파일을 생성하고 push 해준다. 그러면 레포지토리에서 Config.xcconfig가 업로드된것이 보인다.   # Makefile  # ----------------------------- # 📁 Privates 파일 다운로드 설정 # -----------------------------  # GitHub에서 private 파일을 가져올 repository 경로 (팀명/저장소명/브랜치) Private_Repository=team-GitDeulida/CodeLounge-Private/main  # GitHub Raw URL 기본 경로 BASE_URL=https://raw.githubusercontent.com/$(Private_Repository)  # ✅ 파일 다운로드 함수 정의 # $(1): 디렉토리 경로 # $(2): GitHub Access Token # $(3): 파일 이름 define download_file \tmkdir -p $(1) \tcurl -H \"Authorization: token $(2)\" -o $(1)/$(3) $(BASE_URL)/$(1)/$(3) endef  # 🏁 진입 지점: download-privates 명령 실행 시 동작 download-privates:  \t# .env 파일이 없으면 GitHub Access Token을 사용자에게 입력받아 저장 \t# Get GitHub Access Token \t@if [ ! -f .env ]; then \\ \t\tread -p \"Enter your GitHub access token: \" token; \\ \t\techo \"GITHUB_ACCESS_TOKEN=$$token\" &gt; .env; \\ \telse \\ \t\t/bin/bash -c \"source .env; make _download-privates\"; \\ \t\texit 0; \\ \tfi  \t# 실제 다운로드 수행 \tmake _download-privates  # 🔽 내부 명령: 다운로드 로직 수행 _download-privates:  \t# .env 파일에서 GITHUB_ACCESS_TOKEN을 읽어 환경 변수로 설정 \t$(eval export $(shell cat .env))  \t# 레포지토리의 최상위 디렉토리에서 Config.xcconfig 다운로드 \t$(call download_file,.,$$GITHUB_ACCESS_TOKEN,Config.xcconfig)   최초 코드를 실행하면 .env파일이 없기 때문에 GitHub Access Token을 입력하라고 요청한다. 입력해주자. GitHub Access Token은 Personal access tokens -&gt; Fine-grained tokens에서 생성할 수 있다.     실제 프로젝트에서 실행시 Config.xcconfig 파일이 다운로드된것을 확인할 수 있다. 이를 활용하여 여러 파일을 Private 레포지토리에 두고 make 명령어 한줄로 ignore 파일들을 가져올 수 있다.   2. Homebrew 설치 자동화   # ------------------------- # Homebrew 설치 확인 및 설치 # -------------------------  install_homebrew: \t@if ! command -v brew &gt;/dev/null 2&gt;&amp;1; then \\ \t\techo \"Homebrew가 설치되어 있지 않습니다. 설치를 진행합니다...\"; \\ \t\t/bin/bash -c \"$$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"; \\ \telse \\ \t\techo \"Homebrew가 이미 설치되어 있습니다.\"; \\ \tfi   3. fastlane 및 인증서 관련 작업(추가작업 진행예정)   이제 Private 레포지토리에 프로비저닝 프로파일을 저장해두고 팀원이 쉽게 가져올 수 있게 해보자.     fastlane match init         // git 선택 -&gt; Private레포지토리 주소 입력\t fastlane match appstore\t    // Apple Id 입력 -&gt; 앱 번들Id 입력 fastlane match development\t// Apple Id 입력 -&gt; 앱 번들Id 입력     이렇게 하게 되면 Private 레포지토리에 master브랜치가 생성되고 프로비저닝 관련 파일들이 생성된다.   # ------------------------- # fastlane 및 인증서 관련 작업 # -------------------------  # Automatically manage signing 체크 해제해야함!! # Homebrew로 fastlane 설치 (설치되어 있으면 업데이트) install_fastlane: install_homebrew \t@echo \"Updating Homebrew...\" \t@brew update \t@echo \"Installing fastlane via Homebrew...\" \t@brew install fastlane || true \t@echo \"✅ fastlane 설치 완료 (Homebrew 사용)\" \t # 인증서 다운로드 (readonly 모드) fetch_certs: install_fastlane \t@echo \"Fetching development certificates...\" \t@fastlane match development --readonly \t@echo \"Fetching appstore certificates...\" \t@fastlane match appstore --readonly \t@echo \"✅ 인증서 가져오기 완료\"   fastlane match로 인증서를 다운로드 한 후, Xcode에서 Automatically manage signing”이 꺼져 있다면, 해당 팀 ID와 Bundle ID에 맞는 프로비저닝 프로파일을 수동으로 선택할 수 있다.   최종 Makefile   # 터미널에 make 입력시 실행됨 .DEFAULT_GOAL := all  # ----------------------------- # 📁 Privates 파일 다운로드 설정 # -----------------------------  # GitHub에서 private 파일을 가져올 repository 경로 (팀명/저장소명/브랜치) Private_Repository=team-GitDeulida/CodeLounge-Private/main  # GitHub Raw URL 기본 경로 BASE_URL=https://raw.githubusercontent.com/$(Private_Repository)  # ✅ 파일 다운로드 함수 정의 # $(1): 디렉토리 경로 # $(2): GitHub Access Token # $(3): 파일 이름 define download_file \tmkdir -p $(1) \tcurl -H \"Authorization: token $(2)\" -o $(1)/$(3) $(BASE_URL)/$(1)/$(3) endef  # 🏁 진입 지점: download-privates 명령 실행 시 동작 download-privates:  \t# .env 파일이 없으면 GitHub Access Token을 사용자에게 입력받아 저장 \t# Get GitHub Access Token \t@if [ ! -f .env ]; then \\ \t\tread -p \"Enter your GitHub access token: \" token; \\ \t\techo \"GITHUB_ACCESS_TOKEN=$$token\" &gt; .env; \\ \telse \\ \t\techo \"Homebrew가 이미 설치되어 있습니다.\"; \\ \tfi  \t# 실제 다운로드 수행 \tmake _download-privates  # 🔽 내부 명령: 다운로드 로직 수행 _download-privates:  \t# .env 파일에서 GITHUB_ACCESS_TOKEN을 읽어 환경 변수로 설정 \t$(eval export $(shell cat .env))  \t# 레포지토리의 최상위 디렉토리에서 Config.xcconfig 다운로드 \t$(call download_file,.,$$GITHUB_ACCESS_TOKEN,Config.xcconfig)  # ------------------------- # Homebrew 설치 확인 및 설치 # -------------------------  install_homebrew: \t@if ! command -v brew &gt;/dev/null 2&gt;&amp;1; then \\ \t\techo \"Homebrew가 설치되어 있지 않습니다. 설치를 진행합니다...\"; \\ \t\t/bin/bash -c \"$$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"; \\ \telse \\ \t\techo \"Homebrew가 이미 설치되어 있습니다.\"; \\ \tfi  # ------------------------- # fastlane 및 인증서 관련 작업 # -------------------------  # Automatically manage signing 체크 해제해야함!! # Homebrew로 fastlane 설치 (설치되어 있으면 업데이트) install_fastlane: install_homebrew \t@echo \"Updating Homebrew...\" \t@brew update \t@echo \"Installing fastlane via Homebrew...\" \t@brew install fastlane || true \t@echo \"✅ fastlane 설치 완료 (Homebrew 사용)\" \t # 인증서 다운로드 (readonly 모드) fetch_certs: install_fastlane \t@echo \"Fetching development certificates...\" \t@fastlane match development --readonly \t@echo \"Fetching appstore certificates...\" \t@fastlane match appstore --readonly \t@echo \"✅ 인증서 가져오기 완료\"  # ------------------------- # 통합 기본 타겟: 필요한 경우 Private 파일과 인증서 모두 다운로드 # ------------------------- all: download-privates fetch_certs \t@echo \"✅ 모든 작업 완료\"   실행시 Private 레포지토리 2~3번 주소 요청시 입력해준다.  그리고 Xcode 재실행하면 사진처럼 프로비저닝 파일이 보이게 된다.     이제 팀원이 프로비저닝 관련 해서 문제가 생긴다면 make명령어 실행해주세요~ 라고 멋있게 말해주면 된다.  ","categories": [],
        "tags": ["Xcode"],
        "url": "/Xcode-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EC%84%B8%ED%8C%85-%EC%9E%90%EB%8F%99%ED%99%94/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] Closure",
        "excerpt":"    클로저   클로저 표현식   {(parameters) -&gt; returnType in     실행구문  }   클로저 종류     Named Closure = 함수   Unnamed Closure   클로저는 Argument Label을 사용하지 않는다.      클로저는 둘다 포함하지만 보통 Unnamed Closure를 말한다.   클로저도 익명이긴 하지만 함수이기 때문에, 함수형 프로그래밍이 가능하다.   Swift의 함수와 클로저는 1급 객체(First-Class Citizen)로 동작한다.   1급 객체     프로그래밍 언어에서 값처럼 다룰 수 있는 객체를 의미한다.   1등 시민처럼, 많은 권한을 부여 받은 것   권한     변수 또는 상수에 함수/클로저를 담을 수 있다.   인자(파라미터)로 함수/클로저를 전달할 수 있다.   반환값(리턴벨류)으로 함수/클로저를 전달할 수 있다.   클로저와 함수 차이     클로저는 상위 스코프 변수 캡처 가능   함수는 캡처 기본 제공 x   용도     클로저 - 일회성 로직 전달(ex. 콜백)   함수 - 명시적 로직 분리   func doSomething() {     print(\"hello world\") } let closuredoSomething = { print(\"hello world\") }    func doSomething2(name: String) {     print(\"hello world \\(name)\") } let closuredoSomething2 = { (name: String) -&gt; Void in     print(\"hello world \\(name)\") } let closuredoSomething22: (String) -&gt; Void = { name in     print(\"hello world\") }  func doSomething3(name: String) -&gt; String {     return name } let closuredoSomethihg3: (String) -&gt; String = { name in     return name }  func doSomething4(closure: () -&gt; ()) {     closure() }  let closuredoSomethihg4: () -&gt; () = {     print(\"test\") }   @main struct Main {     static func main() {         // doSomething()         // closuredoSomething()         doSomething2(name: \"인덱스\")         closuredoSomething2(\"인덱스2\")                  doSomething4(closure: closuredoSomethihg4)                  // MARK: - 마지막 매개변수가 클로저이면 후행 클로저를 사용할 수 있다.         doSomething4 {             closuredoSomethihg4()         }     } }   ## reference   - https://babbab2.tistory.com/81  ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-closure/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 10. 테이블뷰 Combine CustomDataSource",
        "excerpt":"    테이블뷰 콤바인 커스텀 데이터 소스   지난 시간에 Combine을 통해 List를 보여주었는데 이번 포스트에서는 Combine에서 구독을 통해 들어오는 데이터 바로 DataSource로 연결하는 방법을 해보자. 클로저에 대한 개념을 알아야 이해하기 쉽다.   CustomCombineDataSource.swift    //  //  CustomCombineDataSource.swift  //  UITableViewTutorial  //  //  Created by 김동현 on 5/15/25.  //    import UIKit    class CustomCombineDataSource: NSObject, UITableViewDataSource {            // 멤버 변수      var dataList: [DummyData] = []            override init() {          super.init()      }            // MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점        /// 변경된 데이터를 받아서 테이블뷰에 적용한다      /// - Parameters:      ///   - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수      ///   - tableView: 리로드 대상 테이블뷰      func pushDataList(_ updatedDataList: [DummyData], to tableView: UITableView) {          tableView.dataSource = self          self.dataList = updatedDataList          tableView.reloadData()      }            // MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적             /// 하나의 섹션에 몇개의 rows가 있냐      func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {          return dataList.count      }        /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라      /// - indexPath: 셀의 위치를 나타내는 인덱스 경로      /// - returns: 구성된 UITableViewCell 객체      func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {          /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)          /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")            // [guard let] 방식          guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {              return UITableViewCell()          }            let cellData: DummyData = dataList[indexPath.row]            /// 셀의 주 텍스트를 더미 데이터에서 가져오기          cell.titleLabel.text = cellData.title            /// 셀의 서브 타이틀 설정          cell.bodyLabel.text = cellData.body            cell.detailTextLabel?.numberOfLines = 0          return cell      }  }   커스텀 데이터소스를 만든다. 멤버변수로 데이터리스트를 보유하도록 하자. 지금은 DummyData이지만 다음 포스팅에서 제네릭으로 변경할 예정이다.  DataSource에서 변경이 된 데이터와 테이블뷰 리로드를 위한 테이블뷰 접근을 관리하기 위해 pushDataList()를 만들어주자. 그리고 기존 ViewController에서 관리하던 UITableViewDataSource 관련 프로토콜 로직을 CustomCombineDataSource로 그대로 옮겨준다.  왜냐하면 원래 dataSource의 주요 역할이 어떤 셀의 종류를 보여줄지, 리스트 개수가 몇개일지를 관여하기 때문이다. 즉 기존 ViewController의 비즈니스 로직을 CustomDataSource로 옮긴 것이다. 이제 CustomDataSource를 만들었으니 적용하기 위해 클로저를 만들어주자.   UITableView+Combine.swift   // //  UITableView+Combine.swift //  UITableViewTutorial // //  Created by 김동현 on 5/15/25. //  import UIKit import Combine  // MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자. // public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable extension UITableView {     // 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체     // (Self.Output) -&gt; Void)     // ([DummyData]) -&gt; Void     // 데이터소스 바인딩     func customItems() -&gt; ([DummyData]) -&gt; Void {         let dataSource = CustomCombineDataSource()         return { (updatedDateLisst: [DummyData]) in             dataSource.pushDataList(updatedDateLisst, to: self) // 리로드         }     } }   기존 ViewController에서 sink로 받는 것을 보면 제네릭 형태인데 Sink로 이벤트(Publisker)가 들어온 데이터를 매개변수로 가지고 반환이 없는 형태의 클로저이다. (Self.Output) -&gt; Void)   이 (Self.Output) -&gt; Void) 형태로 반환을 만족하는 함수를 만들어주자. 지금은 들어오는 형태가 [DummyData] 이므로 func customItems() -&gt; ([DummyData]) -&gt; Void로 해주면 된다.   SInk를 통해 들어오는게 [DummyData]로 들어오게 되고 return { input in } 에 input 부분으로 들어오게 된다.  그럼 pushDataList를 통해 변경이 된 이벤트를 나자신에게 넣어준다.   CombineListViewController.swift   // //  CombineListViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/13/25. //  import UIKit import Combine  class CombineListViewController: UIViewController {          // Combine 메모리 처리를 위해 생성     var subscriptions = Set&lt;AnyCancellable&gt;()          // Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다.     @Published var dummies: [DummyData] = []          @IBOutlet weak var myTableView: UITableView!          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()                           /*         - sink는 @Published가 수정된 스레드에서 실행된다         - 그래서 Published변수 수정시 메인 스레드에서 수정해주자         - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다          */                  // MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다.         // $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨         // sink는 구독하는 것이다.         // AnyCancellable 구독한다고 한다.         // store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다.         $dummies             .receive(on: DispatchQueue.main)             .sink(receiveValue: self.myTableView.customItems())             .store(in: &amp;subscriptions)                  /*          기존 방식          $dummies              .receive(on: DispatchQueue.main)              // 데이터 변경시마다 동작              .sink(receiveValue: { (changedDummies: [DummyData]) in                  print(\"changedDummies: \\(changedDummies.count)\")                                    // sink는 메인스레드에서 동작해서 Dispatch안해도된다                  self.myTableView.reloadData()              })              .store(in: &amp;subscriptions)          */                  // 2초 뒤에 더미데이터 10개 추가         DispatchQueue.global().asyncAfter(deadline: .now() + 2, execute: {             self.dummies += DummyData.getDumies(10)         })     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier)         // self.myTableView.delegate = self     } }  결국 Combine 데이터 변경되었을 때 즉 Publisher가 들어올 때 바로 tableview의 dataSource도 설정하고, 바로 데이터를 꽂아줄 수 있다. 하지만 지금 customItems() 형태가 DummyData로 고정되어있기 때문에 서버에서 받을 수 있는 여러 타입을 모두 반영하기 위해 제네릭으로 변환하는 포스팅을 작성할 예정이다.  ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView10/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 11. 테이블뷰 제네릭 CustomCombineDataSource",
        "excerpt":"    테이블뷰 제네릭 CustomCombineDataSource   제네릭     어떠한 자료형을 받을 수 있다.   IndexData를 만들어서 해당 타입도 받을 수 있도록 해보자.   IndexData구조체 추가   // //  DummyData.swift //  UITableViewTutorial // //  Created by 김동현 on 5/8/25. //  import Foundation import Fakery  struct DummySection {     let uuid: UUID     let title: String     let body: String     let rows: [DummyData]          init() {         self.uuid = UUID()         self.title = \"섹션 타이틀입니다: \\(uuid)\"         self.body = \"섹션 바디입니다: \\(uuid)\"         self.rows = DummyData.getDumies(10)     }          static func getDummies(_ count: Int = 100) -&gt; [DummySection] {         return (1...count).map { _ in DummySection() }     } }  struct DummyData {     let uuid: UUID     let title: String     let body: String          init() {         self.uuid = UUID()         let faker = Faker(locale: \"ko\")         let firstName = faker.name.firstName()  //=&gt; \"Emilie\"         let lastName = faker.name.lastName()    //=&gt; \"Hansen\"                  let body = faker.lorem.paragraphs(amount: 10)                  self.title = \"타이틀입니다: \\(lastName) \\(firstName)\"         self.body = \"바디입니다: \\(body)\"     }          static func getDumies(_ count: Int = 100) -&gt; [DummyData] {         return (1...count).map { _ in DummyData() }     } }  struct IndexData {     let uuid: UUID     let title: String     let body: String          init() {         self.uuid = UUID()         let faker = Faker(locale: \"ko\")         let firstName = faker.name.firstName()  //=&gt; \"Emilie\"         let lastName = faker.name.lastName()    //=&gt; \"Hansen\"                  let body = faker.lorem.paragraphs(amount: 10)                  self.title = \"타이틀입니다: \\(lastName) \\(firstName)\"         self.body = \"바디입니다: \\(body)\"     }          static func getDumies(_ count: Int = 100) -&gt; [IndexData] {         return (1...count).map { _ in IndexData() }     } }   CustomCombineDataSource.swift    //  //  CustomCombineDataSource.swift  //  UITableViewTutorial  //  //  Created by 김동현 on 5/15/25.  //    import UIKit    /*  class CustomCombineDataSource&lt;T, G&gt;: NSObject, UITableViewDataSource {            // 멤버 변수      var dataList: [T] = []            var testDataList: [G] = []  */    class CustomCombineDataSource&lt;Item&gt;: NSObject, UITableViewDataSource {            // 멤버 변수      var dataList: [Item] = []            override init() {          super.init()      }            // MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점        /// 변경된 데이터를 받아서 테이블뷰에 적용한다      /// - Parameters:      ///   - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수      ///   - tableView: 리로드 대상 테이블뷰      func pushDataList(_ updatedDataList: [Item], to tableView: UITableView) {          tableView.dataSource = self          self.dataList = updatedDataList          tableView.reloadData()      }            // MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적             /// 하나의 섹션에 몇개의 rows가 있냐      func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {          return dataList.count      }        // 어떤 셀을 보여줄 지      /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라      /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 - 몇번째인지      /// - returns: 구성된 UITableViewCell 객체      func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {          /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)          /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")            // [guard let] 방식          guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {              return UITableViewCell()          }                    if let dataList = dataList as? [DummyData] {              let cellData: DummyData = dataList[indexPath.row]                /// 셀의 주 텍스트를 더미 데이터에서 가져오기              cell.titleLabel.text = cellData.title                /// 셀의 서브 타이틀 설정              cell.bodyLabel.text = cellData.body                cell.detailTextLabel?.numberOfLines = 0          }                    if let dataList = dataList as? [IndexData] {              let cellData: IndexData = dataList[indexPath.row]                /// 셀의 주 텍스트를 더미 데이터에서 가져오기              cell.titleLabel.text = cellData.title                /// 셀의 서브 타이틀 설정              cell.bodyLabel.text = cellData.body                cell.detailTextLabel?.numberOfLines = 0          }                    return cell      }  }   셀의 종류가 추가될때마다 항상 if let dataList를 하면 불편하다고 생각된다.   UITableView+Combine.swift   // //  UITableView+Combine.swift //  UITableViewTutorial // //  Created by 김동현 on 5/15/25. //  import UIKit import Combine  // MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자. // public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable extension UITableView {     // 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체     // (Self.Output) -&gt; Void)     // ([DummyData]) -&gt; Void     // 데이터소스 바인딩     func customItems&lt;Item&gt;() -&gt; ([Item]) -&gt; Void {         let dataSource = CustomCombineDataSource&lt;Item&gt;()         return { (updatedDateLisst: [Item]) in             dataSource.pushDataList(updatedDateLisst, to: self) // 리로드         }     } }   CombineListViewController.swift   // //  CombineListViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/13/25. //  import UIKit import Combine  class CombineListViewController: UIViewController {          // Combine 메모리 처리를 위해 생성     var subscriptions = Set&lt;AnyCancellable&gt;()          // Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다.     // @Published var dummies: [DummyData] = []     @Published var indexDatas: [IndexData] = []          @IBOutlet weak var myTableView: UITableView!          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()                           /*         - sink는 @Published가 수정된 스레드에서 실행된다         - 그래서 Published변수 수정시 메인 스레드에서 수정해주자         - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다          */                  // MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다.         // $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨         // sink는 구독하는 것이다.         // AnyCancellable 구독한다고 한다.         // store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다.         $indexDatas             .receive(on: DispatchQueue.main)             .sink(receiveValue: self.myTableView.customItems())             .store(in: &amp;subscriptions)                  /*          기존 방식          $dummies              .receive(on: DispatchQueue.main)              // 데이터 변경시마다 동작              .sink(receiveValue: { (changedDummies: [DummyData]) in                  print(\"changedDummies: \\(changedDummies.count)\")                                    // sink는 메인스레드에서 동작해서 Dispatch안해도된다                  self.myTableView.reloadData()              })              .store(in: &amp;subscriptions)          */                  // 2초 뒤에 더미데이터 10개 추가         DispatchQueue.global().asyncAfter(deadline: .now() + 2, execute: {             // self.dummies += DummyData.getDumies(10)             self.indexDatas += IndexData.getDumies(10)         })     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier)         // self.myTableView.delegate = self     } }   위 코드에서 CustomCombineDataSource.swift에서 셀이 추가될 때마다 항상 if let dataList를 하면 불편하다고 생각되기 때문에 이를 해결하기 위해 다음 포스팅을 작성하겠다.   정리  데이터소스는 데이터와 관련되어 있고, 셀의 종류를 정하고 어떤 데이터인지에 따라 어떤 셀을 보여줄지 정하고, 리스트 갯수가 몇개인지를 관여한다.  ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView11/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 12. 테이블뷰 제네릭 CustomCombineDataSource",
        "excerpt":"    테이블뷰 제네릭 CustomCombineDataSource  이전 포스팅에서 tableview데이터소스를 combine과 제네릭으로 연결을 했다.   데이터소스는 데이터와 연괸되어있고, 셀의 종류를 정하고, 리스트 개수가 몇개인지 정하는 역할이다 즉 데이터와 관련이 있다.   이전 포스팅에서 커스텀 DataSource를 만들어서 처리하였는데 문제가 있었다. 리스트를 보여줄 때 데이터 타입이 변경되면 받을 수 없고 DummyData타입만 받을 수 있었다. 어떠한 데이터가 오더라도 확장성이 있도록 호출하는 쪽에서 셀의 타입을 정하도록 구현해보자.   CustomCombineDataSource.swift    //  //  CustomCombineDataSource.swift  //  UITableViewTutorial  //  //  Created by 김동현 on 5/15/25.  //  // https://www.youtube.com/watch?v=vlJ392OMkoI&amp;list=PLgOlaPUIbynpuq9GKCwAedgWkkPm2Wo8v&amp;index=16    import UIKit    /*  class CustomCombineDataSource&lt;T, G&gt;: NSObject, UITableViewDataSource {            // 멤버 변수      var dataList: [T] = []            var testDataList: [G] = []  */    class CustomCombineDataSource&lt;Item&gt;: NSObject, UITableViewDataSource {            // 셀을 만드는 클로저      // 1. let makeCell: (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell      // 2. let makeCell: (UITableView, IndexPath, Item) -&gt; UITableViewCell // 위랑 같음      // 3.      var makeCell: ((UITableView, IndexPath, Item) -&gt; UITableViewCell)? = nil // 옵셔널로도 가능            var dataList: [Item] = []            // 2. 안쪽에서 터트리기 때문에 escaping 해주자      /*      init(makeCell: @escaping (_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell) {          self.makeCell = makeCell          super.init()      }       */            // 3. 옵셔널로 한다면 escaping 안해도 된다      init(_ makeCell: ((_ tableView: UITableView, _ indexPath: IndexPath, _ cellData: Item) -&gt; UITableViewCell)? = nil) {          self.makeCell = makeCell          super.init()      }            // MARK: - Combine 이벤트로 들어온 데이터랑 테이블뷰랑 연결시켜주는 지점        /// 변경된 데이터를 받아서 테이블뷰에 적용한다      /// - Parameters:      ///   - updatedDataList: 외부에서 변경된 Combine Publisher로 들어온 데이터를 내 DataSource가 가진 data로 변경하기 위한 매개변수      ///   - tableView: 리로드 대상 테이블뷰      func pushDataList(_ updatedDataList: [Item], to tableView: UITableView) {          tableView.dataSource = self          self.dataList = updatedDataList          tableView.reloadData()      }            // MARK: - 테이블뷰 데이터 소스 관련(변경이 된 데이터를 데이터소스로 넘겨받아서 reloadData를 하는 목적             /// 하나의 섹션에 몇개의 rows가 있냐      func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {          return dataList.count      }        /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라      /// - indexPath: 셀의 위치를 나타내는 인덱스 경로      /// - returns: 구성된 UITableViewCell 객체      /// 어떤 셀을 보여줄지      // 1. 테이블뷰      // 2. indexPath 몇번째인지      // 3. 셀에 대한 데이터 - 셀에 대한 제네릭 데이터      func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                    // 비어있으면 기본 UITableViewCell 반환          makeCell?(tableView, indexPath, dataList[indexPath.row]) ?? UITableViewCell()                    //        /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)          //        /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")          //          //        // [guard let] 방식          //        guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {          //            return UITableViewCell()          //        }          //          //        if let dataList = dataList as? [DummyData] {          //            let cellData: DummyData = dataList[indexPath.row]          //          //            /// 셀의 주 텍스트를 더미 데이터에서 가져오기          //            cell.titleLabel.text = cellData.title          //          //            /// 셀의 서브 타이틀 설정          //            cell.bodyLabel.text = cellData.body          //          //            cell.detailTextLabel?.numberOfLines = 0          //        }          //          //        if let dataList = dataList as? [IndexData] {          //            let cellData: IndexData = dataList[indexPath.row]          //          //            /// 셀의 주 텍스트를 더미 데이터에서 가져오기          //            cell.titleLabel.text = cellData.title          //          //            /// 셀의 서브 타이틀 설정          //            cell.bodyLabel.text = cellData.body          //          //            cell.detailTextLabel?.numberOfLines = 0          //        }          //          //        return cell      }  }             tableView()의 각 매개변수 tableView, indexPath, 그리고 셀에 대한 데이터 cellData을 조합을 하여 UITableViewCell 즉 셀을 만들자. 기존 tableView() 내부를 전부 주석처리를 하고 주석부분을 만드는 클로저를 두자. 함수 = 클로저 = 논리이다.  즉 논리 = 로직이다. 다시말해 로직을 클로저로 빼자.   UITableView+Combine.swift   // //  UITableView+Combine.swift //  UITableViewTutorial // //  Created by 김동현 on 5/15/25. //  import UIKit import Combine  // MARK: - Sink 정의를 보면 매개변수로 (Self.Output) -&gt; Void) 형태의 클로저를 받는다. 이 형태를 만족하는 로직 함수를 만들자. // public func sink(receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable extension UITableView {     // 고차함수 - 클로저를 매개변수로 가지거나 반환을 가지는 함수 자체     // (Self.Output) -&gt; Void)     // ([DummyData]) -&gt; Void     // 데이터소스 바인딩         func customItemsWithCell&lt;Item&gt;(         makeCell: ((UITableView, IndexPath, Item) -&gt; UITableViewCell)? = nil     ) -&gt; ([Item]) -&gt; Void {         let dataSource = CustomCombineDataSource&lt;Item&gt;(makeCell)         return { (updatedDateLisst: [Item]) in             dataSource.pushDataList(updatedDateLisst, to: self) // 리로드         }     } }    CombineListViewController.swift   // //  CombineListViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/13/25. //  import UIKit import Combine  class CombineListViewController: UIViewController {          // Combine 메모리 처리를 위해 생성     var subscriptions = Set&lt;AnyCancellable&gt;()          // Published를 하게 되면 dummies 데이터가 추가나 값 변경시 이벤트를 받을 수 있다.     @Published var dummies: [DummyData] = []     @Published var indexDatas: [IndexData] = []          @IBOutlet weak var myTableView: UITableView!          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()                           /*         - sink는 @Published가 수정된 스레드에서 실행된다         - 그래서 Published변수 수정시 메인 스레드에서 수정해주자         - @Published 값을 메인 스레드에서 수정하든, 백그라운드에서 수정하든, .receive(on: .main)만 붙이면 sink는 메인에서 실행되고reloadData()도 안전하게 실행된다          */                  // MARK: - 기존의 데이터를 받는 거를 CombineListViewController에서 다했더라면 이제는 customDataSource으로 따로 뺴두고, 로직은 extension으로 빼서 처리를 한 것이다.         // $ 붙이면 데이터 이벤트를 받을 수 있는 상태가 됨         // sink는 구독하는 것이다.         // AnyCancellable 구독한다고 한다.         // store: 구독했던거에 대한 메모리 참조가 들어오게 되는데 이를 관리하기 위해 subscriptions에 넣어준다.         /*          기존 방식          $dummies              .receive(on: DispatchQueue.main)              // 데이터 변경시마다 동작              .sink(receiveValue: { (changedDummies: [DummyData]) in                  print(\"changedDummies: \\(changedDummies.count)\")                                    // sink는 메인스레드에서 동작해서 Dispatch안해도된다                  self.myTableView.reloadData()              })              .store(in: &amp;subscriptions)          */                  $dummies.receive(on: DispatchQueue.main)             .sink(receiveValue: self.myTableView.customItemsWithCell(                 // 셀에 대한 종류를 정해주기 위해 바깥으로 뺀 형태 -&gt; makeCell을 데이터 타입마다 다르게 정의할 수 있다                 makeCell: { myTableView, indexPath, cellData in                                  // [guard let] 방식                 guard let cell = myTableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {                     return UITableViewCell()                 }                          cell.titleLabel.text = cellData.title  // 셀의 주 텍스트를 더미 데이터에서 가져오기                 cell.bodyLabel.text = cellData.body // 셀의 서브 타이틀 설정                 cell.detailTextLabel?.numberOfLines = 0                 return cell                              }))             .store(in: &amp;subscriptions)                           // 2초 뒤에 더미데이터 10개 추가         DispatchQueue.global().asyncAfter(deadline: .now() + 2, execute: {             self.dummies += DummyData.getDumies(10)             // self.indexDatas += IndexData.getDumies(10)         })     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier)         // self.myTableView.delegate = self     } }    ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView12/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] UITextView vs UITextField",
        "excerpt":"    UITextView UITextField  차이  TextField는 placeholder를 사용할 수 있으나 TextView는 안되는것을 알게 되어 두 컴포넌트의 차이에 대해 알아보고자 정리하게 되었다.   UITextView  공식문서를 살펴보면  A scrollable, multiline text region  1줄 이상으로 이루어진 스크롤 가능한 텍스트 영역    placeholder는 제공하지 않기 때문에 직접 구현해야 한다.   placeholder 구현 방법  UITextView는 UITextViewDeleagate 프로토콜을 채택하고 있다.   그 중 textViewDidBeginEditing method를 사용해서 구현해보자.   // init 시 상태를 lazy로 지정 private lazy var textView: UITextView = {     let tv = UITextView()     tv.text = \"입력하세요..\"     tv.textColor = .secondaryLabel     tv.delegate = self     return textView }()  init 시 상태를 lazy로 지정해주면서 layout 세팅을 진행하였다.   textViewDidBeginEditing  Tells the delegate when editing of the specified text view begins.  Optional 설정으로 textView의 수정이 일어나면 실행되는 메서드   extension UploadViewController: UITextViewDelegate {     func textViewDidBeginEditing(_ textView: UITextView) {         guard textView.textColor == .secondaryLabel else { return }         textView.text = nil         textView.textColor = .label     } }  textColor가 .secondaryLabel라는 기본값으로 세팅되어 있으면 return 시키고, 아니라면 text를 비우고 Color도 검정색으로 바꾸어준다.   UITextField  ","categories": [],
        "tags": ["UIKit","UIComponent"],
        "url": "/UIKit-UItextField-UITextView/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 13. RxTableView",
        "excerpt":"   ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView13/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Docker] code-server",
        "excerpt":"    # Dockerfile  FROM ubuntu:latest  # ----- 기본 패키지 설치 ----- RUN apt-get update &amp;&amp; \\     apt-get install -y \\         curl sudo python3 python3-pip default-jdk \\         git wget nano locales \\         libpython3.10 libicu-dev libxml2-dev clang \\         unzip gnupg2 libcurl4-openssl-dev pkg-config \\     &amp;&amp; apt-get clean  # ----- 로케일 설정 ----- RUN locale-gen en_US.UTF-8 ENV LANG=en_US.UTF-8 ENV LANGUAGE=en_US:en ENV LC_ALL=en_US.UTF-8  # ----- ARG로 외부에서 변수 받기 ----- ARG USER ARG PASSWORD  # ----- 사용자 생성 및 sudo 권한 부여 ----- RUN useradd -m ${USER} &amp;&amp; echo \"${USER}:${PASSWORD}\" | chpasswd &amp;&amp; adduser ${USER} sudo  # ----- code-server 설치 및 작업 디렉토리 생성 ----- ENV WORKINGDIR=\"/home/${USER}/vscode\" RUN curl -fsSL https://code-server.dev/install.sh | sh &amp;&amp; \\     mkdir -p ${WORKINGDIR} &amp;&amp; chown -R ${USER}:${USER} ${WORKINGDIR}  # ----- 컨테이너 환경변수로도 유지 ----- ENV PASSWORD=${PASSWORD} ENV USER=${USER}  # ----- 사용자 전환 ----- USER ${USER} WORKDIR ${WORKINGDIR}  # ----- VSCode 확장 설치 ----- RUN code-server --install-extension ms-python.python &amp;&amp; \\     code-server --install-extension ms-azuretools.vscode-docker &amp;&amp; \\     code-server --install-extension formulahendry.code-runner  # ----- 포트 오픈 ----- EXPOSE 8080  # ----- code-server 실행 ----- CMD [\"code-server\", \"--bind-addr\", \"0.0.0.0:8080\", \"--auth\", \"password\", \".\"]   # 컨테이너 터미널로 진입 docker exec -it vscode-container bash  # 이동 cd /home/ec2-user/.local/share/code-server/User  nano settings.json  {   \"code-runner.executorMap\": {     \"python\": \"python3 -u\",     \"swift\": \"/home/ec2-user/.local/share/swiftly/bin/swift\"   },   \"code-runner.showExecutionMessage\": false,   \"code-runner.clearPreviousOutput\": true }  # 저장 ctrl + o enter ctrl x  # 나가고 재빌드 exit docker compose up -d --build   swift 추가  # 컨테이너 터미널로 진입 docker exec -it vscode-container bash   # 1. 기존 swiftly 완전 삭제 rm -rf ~/.local/share/swiftly rm -f ~/swiftly  # 2. 필수 패키지 설치 sudo apt-get update sudo apt-get install -y clang libicu-dev wget libpython3-dev  # 3. 최신 swiftly 설치 curl -O \"https://download.swift.org/swiftly/linux/swiftly-$(uname -m).tar.gz\" tar zxf \"swiftly-$(uname -m).tar.gz\" chmod +x swiftly ./swiftly init --quiet-shell-followup --assume-yes  # 4. 환경 변수 적용 source ~/.local/share/swiftly/env.sh echo 'source ~/.local/share/swiftly/env.sh' &gt;&gt; ~/.bashrc  # 5. Swift 6.1.0 설치 (실제 toolchain 다운로드) ~/.local/share/swiftly/bin/swiftly install 6.1.0 --assume-yes --verify  # 6. swift 실행 확인 find ~/.local/share/swiftly/toolchains -name swift -type f -executable swift --version  ","categories": [],
        "tags": ["Docker"],
        "url": "/Docker-code-server/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Baekjoon] 백준 1992 쿼드트리",
        "excerpt":"   문제  쿼드트리     주어진 영상이 0으로만 이루어져 있다면 결과는 0이 되고 혹은 그 반대면 결과가 1이 된다.    만약 0과 1이 섞여 있으면 전체를 한번에 나타내지 못하고 4개의 영역으로 나누어 각 영역을 압축한 결과를 차례로 괄호 안에서 묶어서 표현한다.   풀이  분할 정복 알고리즘을 사용하여 해결할 수 있다.    분할 정복은 재귀적으로 큰 문제를 하위 문제로 쪼개어 하위 문제를 해결하고 모아서 상위 문제를 해결하는 방식이다.    2차원 배열을 같은 숫자로 구성된 4등분 단위로 압축 및 재귀적으로 처리하여 괄호로 묶는다. Stack으로도 구현 가능하다.   /* ┌───┬───┐ │ 1 │ 2 │ ├───┼───┤ │ 3 │ 4 │ └───┴───┘ */ let n = Int(readLine()!)! var graph: [[String]] = []  for _ in 0..&lt;n {     let row = readLine()!.map { String($0) }     graph.append(row) }  // 분할정복 함수 - (y, x) 위치에서 size 크기의 정사각형 영역 처리 func go(_ y: Int, _ x: Int, _ size: Int) -&gt; String {     let base = graph[y][x]     var ret = \"\"      for row in y..&lt;y+size {         for col in x..&lt;x+size {             // 입력 조건이 2^k 이므로 0이하로 들어올 가능성이 없기 때문에 기저 사례 필요 x             if size == 1 { return graph[y][x] }              // 하나라도 값이 다르다면 4분할하여 재귀적으로 검사             if base != graph[row][col] {                 ret += \"(\"                 ret += go(y, x, size/2)                 ret += go(y, x+size/2, size/2)                 ret += go(y+size/2, x, size/2)                 ret += go(y+size/2, x+size/2, size/2)                 ret += \")\"                 return ret             }         }     }      // 모두 같은 값이면 해당 값 반환     return base }  // (0, 0)부터 분할정복 시작 print(go(0, 0, n))  ","categories": [],
        "tags": ["Baekjoon"],
        "url": "/Baekjoon-1992/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Baekjoon] 백준 2828 사과 담기 게임",
        "excerpt":"   문제  사과 담기 게임     스크린 위에서 사과 여러개가 떨어질 때 바구니로 사과를 담기 위한 이동거리의 최솟값을 구하라   풀이  시작지점을 left와 right를 방정식으로 나타낼 수 있다.  left = 1  right = left + m - 1   /*  5 1  3  1  5  3  */  let input = readLine()!.split(separator: \" \").map { Int($0)! } let n = input[0]          // screen let m = input[1]          // basket let j = Int(readLine()!)! // count  var left = 1 var right = left + m - 1 // 그냉 m으로 해도 된다 var totalMove = 0  for _ in 0..&lt;j {     // 사과가 떨어지는 위치     let pos = Int(readLine()!)!          // 사과의 위치가 이미 바구니가 있는 위치이면 아래 바구니 이동 로직을 무시     if pos &gt;= left &amp;&amp; pos &lt;= right { continue }         // 포지션이 바구니 안에 있으면 이동 안함     if pos &lt; left {         let move = left - pos         left -= move         right -= move         totalMove += move     } else if pos &gt; right {         let move = pos - right         right += move         left += move         totalMove += move     } }  print(totalMove)  ","categories": [],
        "tags": ["Baekjoon"],
        "url": "/Baekjoon-2828/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Baekjoon] 백준 2910 빈도 정렬",
        "excerpt":"   문제  빈도 정렬     자주 등장하는 숫자 기준으로 오름차순 정렬하되, 등장횟수가 같다면 먼저 나온 것이 앞에 있어야 한다.   풀이   정렬 관련 함수  // 배열 var numbers = [5, 2, 8, 1, 3]  // 오름차순 정렬 let ascending = numbers.sorted() print(\"오름차순:\", ascending) // [1, 2, 3, 5, 8]  // 내림차순 정렬 let descending = numbers.sorted(by: &gt;) print(\"내림차순:\", descending) // [8, 5, 3, 2, 1]   // 딕셔너리 let scores = [\"Alice\": 88, \"Bob\": 95, \"Charlie\": 72]  // 🔹 value 기준 오름차순 정렬 let byScoreAsc = scores.sorted { $0.value &lt; $1.value } print(\"점수 오름차순:\", byScoreAsc)  // 🔹 value 기준 내림차순 정렬 let byScoreDesc = scores.sorted { $0.value &gt; $1.value } print(\"점수 내림차순:\", byScoreDesc)  // 🔹 key 기준 오름차순 정렬 let byNameAsc = scores.sorted { $0.key &lt; $1.key } print(\"이름 오름차순:\", byNameAsc)  // 우선순위 기반 정렬 1 let dic = [1: 2, 2: 5, 3: 5, 4: 1] let order = [2, 3, 1, 4] // 우선순위: 2 &gt; 3 &gt; 1 &gt; 4  let sortedKeys = dic.sorted {     if $0.value == $1.value {         // O(n)         return order.firstIndex(of: $0.key)! &lt; order.firstIndex(of: $1.key)! // &lt;: 인덱스가 낮은 key가 먼저 온다     }     return $0.value &gt; $1.value }.map { $0.key } print(sortedKeys)  // 우선순위 기반 정렬 2 let dic = [1: 2, 2: 5, 3: 5, 4: 1] // num: count let order = [2, 3, 1, 4]   // [2: 0, 3: 1, 1: 2, 4: 3] = num: idx(Order) // 우선순위 인덱스를 미리 딕셔너리로 만들어 둔다 (O(1) 접근) let priority: [Int: Int] = Dictionary(uniqueKeysWithValues: order.enumerated().map { ($1, $0) })  let sortedKeys = dic.sorted {     if $0.value == $1.value {         return priority[$0.key]! &lt; priority[$1.key]!     }     return $0.value &gt; $1.value }.map { $0.key }  print(sortedKeys)    처음 접근 방법  딕셔너리의 키를 숫자로 두고 value로 카운팅을 한다.   _ = readLine() let numbers = readLine()!.split(separator: \" \").map { Int($0)! } // [1, 1, 1, 2, 2, 2] var dic: [Int:Int] = [:]  for num in numbers {     dic[num, default: 0] += 1 } print(dic)       // [2: 3, 1: 2]  // value가 많은순으로 키룰 정렬하는 방법 let sortedKeys = dic.sorted {     return $0.value &gt; $1.value }.map { $0.key } print(sortedKeys)  // [2, 1]  var output = \"\" for num in sortedKeys {     output += String(repeating: \"\\(num) \", count: dic[num]!) } print(output) // 2 2 2 1 1   이러면 1번 예제는 해결이 되지만 만약 동일한 등장횟수면 해당 순서를 보장해줘야 한다.   제출 1   /* 5 2 2 1 2 1 2  */ _ = readLine() let numbers = readLine()!.split(separator: \" \").map { Int($0)! }  // ── 1) 빈도 계산 / 순서 계산 ───────────────────────────────────── var dic: [Int:Int] = [:]    // 숫자:개수 var order: [Int:Int] = [:]  // 숫자:우선순위 for (idx, num) in numbers.enumerated() {     if dic[num] == nil {         order[num] = idx // num이 처음 등장한 idx 기록     }     dic[num, default: 0] += 1  // [num:value] }  // ── 2) 빈도순으로 key 한번씩만 내보내기 ───────────────────────────────────── let keysByFreq = dic     .sorted {         if $0.value == $1.value {             // 먼저 나온 key가 앞으로 오도록 정렬             return order[$0.key]! &lt; order[$1.key]!         } else {             return $0.value &gt; $1.value // 내림차순         }     }     .map { $0.key }                   // key만 추출  // ── 3) 빈도순으로 key를 빈도만큼 반복 출력 ───────────────────────────────────── var output: String = \"\" for num in keysByFreq {     output += String(repeating: \"\\(num) \", count: dic[num]!) } print(output)    제출 2   /* 5 2 2 1 2 1 2  딕셔너리 dic은 다음과 같이 구성 [숫자: (등장 순서, 등장 횟수)]  [예시] [   2: (0, 3), // 0번째에 처음 등장, 3번 나옴   1: (1, 2), // 1번째에 처음 등장, 2번 나옴 ]  */ _ = readLine() var dic = [Int: (Int, Int)]() let numbers = readLine()!.split(separator: \" \").map { Int($0)! }  for (idx, num) in numbers.enumerated() {     // 숫자 처음 등장시     if dic[num] == nil {         dic[num] = (idx, 1) // 등장순서, 1번 등장     } else {         dic[num]!.1 += 1   // 이미 등장한 숫자라면 횟수만 추가     } }  // 등장 횟수가 많은 숫자가 먼저 오도록, 같으면 등장순서가 빠른 순으로 let sorted = dic.sorted {     let (firstIdx, firstCnt) = $0.value     let (secondIdx, secondCnt) = $1.value          if firstCnt != secondCnt {         return firstCnt &gt; secondCnt // 등장 횟수 많은 순     } else {         return firstIdx &lt; secondIdx // 먼저 등장한 숫자 먼저     } }  // 출력 1 print(sorted.map { String(repeating: \"\\($0.key) \", count: $0.value.1) }.joined())  // 출력 2 var output = \"\" for (number, (_, cnt)) in sorted {     output += String(repeating: \"\\(number) \", count: cnt) } print(output)   ","categories": [],
        "tags": ["Baekjoon"],
        "url": "/Baekjoon-2910/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[UIKit] iOS 푸시알림 FCM, APNS",
        "excerpt":"    iOS 푸시알림 FCM, APNS   iOS에서 푸시 종류는 2가지가 있다.      로컬에서 직접 보내는 알림   서버에서 보내는 알림            서버에서 보내는 APNS(Apple Push Notification Service)                FCM(Firebase Cloud Messaging) -&gt; 이번 포스팅에서는 FCM을 활용한 2번 방식을 진행할 예정이다.           ​                   APNS 란?   APNS (Apple Push Notification Service) 는    iOS의 모든 원격 알림이 반드시 거쳐야 하는 애플 공식 푸시 전달 서버이다..   즉, 푸시 메시지를 내가 직접 사용자 기기로 보내는 게 아니라    → APNS에 요청    → APNS가 사용자 기기로 전송    하는 방식이다.     FCM 란?   FCM은 Google에서 제공하는 클라우드 기반 메시징 서비스로,  iOS의 APNS를 포함해 Android, Web 등 다양한 플랫폼에 푸시 메시지를 전송할 수 있도록 중간 서버 역할을 해준다.  iOS에서 FCM을 통해 푸시 알림을 보내면, FCM 내부적으로 APNS를 거쳐서 사용자 기기에 도달한다.   FCM이 APNS 대신 해주는 것들      애플 인증서 등록 및 관리   APNS에 메시지 전송 요청   안드로이드, iOS 둘 다 지원 (멀티 플랫폼)   클라우드 환경에서 손쉽게 운영   왜 FCM을 쓰는가?      APNS 서버 직접 구축이 복잡하고 부담스러울 때   iOS &amp; Android를 동시에 지원하는 일관된 환경이 필요할 때   푸시 알림 시스템을 빠르게 구축하고 싶을 때   Firebase Analytics, A/B 테스트 같은 연계 기능을 활용할 때     푸시 알림의 기본 동작 흐름      앱이 APNS에 Device Token 요청            이 토큰은 앱이 설치된 기기의 주소 역할을 한다.           APNS가 앱에게 Device Token 전달   앱이 Device Token을 푸시 서버(FCM 등)에 전달            이 서버가 실제 푸시 메시지를 보낼 주체이다.             APNS를 통한 푸시 알림 동작 구조      푸시 서버(예: FCM)가 메시지와 Device Token을 APNS에 전송            이때 APNS와 푸시 서버는 TLS 인증으로 보안 통신       서버에는 APNS 인증 정보(p8 키 or 인증서)가 등록되어 있어야 함           APNS는 해당 디바이스로 푸시 메시지를 전송   디바이스에서 푸시 알림 수신     실습     identifiers에서 해당 프로젝트 누른 후 push notification 체크박스 체크 해준다.     keys에서 키를 발급 해준다. 완료하면 Download버튼이 생긴다 이를 통해 p8파일을 다운로드 한다.     firebase 프로젝트 -&gt; 프로젝트 설정 -&gt; 클라우드 메시징에서 APNS인증키를 등록해준다.     업로드를 눌러서 완료한다.                           Push Notifications     Background Modes     xcode -&gt; target -&gt; Push Notifications, Background Mode 추가한다.     Remote Notifications 체크해준다.     AppDelegate.swift   import UIKit import FirebaseCore import FirebaseMessaging import UserNotifications  @main class AppDelegate: UIResponder, UIApplicationDelegate {          func application(_ application: UIApplication,                      didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {                  // Firebase 초기화         FirebaseApp.configure()                  // 알림 권한 요청         UNUserNotificationCenter.current().delegate = self         UNUserNotificationCenter.current().requestAuthorization(             options: [.alert, .badge, .sound]         ) { granted, error in             print(\"✅ 알림 권한 요청 결과: \\(granted)\")             if granted {                 DispatchQueue.main.async {                     UIApplication.shared.registerForRemoteNotifications()                 }             }         }                  // FCM 설정         Messaging.messaging().delegate = self                  return true     } }  extension AppDelegate: UNUserNotificationCenterDelegate {          // APNs로부터 device token 받았을 때 FCM에 등록     func application(_ application: UIApplication,                      didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {         print(\"📮 APNS Token 수신: \\(deviceToken)\")         Messaging.messaging().apnsToken = deviceToken     }      // 앱이 실행 중일 때 알림 수신 (배너로 표시되게 설정)     func userNotificationCenter(_ center: UNUserNotificationCenter,                                 willPresent notification: UNNotification,                                 withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {         completionHandler([.list, .banner, .sound])     } }  extension AppDelegate: MessagingDelegate {          // FCM 토큰 갱신될 때 호출     func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) {         print(\"📌 FCM Token: \\(fcmToken ?? \"nil\")\")                  // 필요 시 NotificationCenter로 다른 컴포넌트에 전달         NotificationCenter.default.post(             name: Notification.Name(\"FCMToken\"),             object: nil,             userInfo: [\"token\": fcmToken ?? \"\"]         )     } }        빌드하면 나오는 FCM을 복사한다.   FCM.py   import firebase_admin from firebase_admin import credentials, messaging  # 1. 서비스 계정 키 경로 (.json) cred = credentials.Certificate(\"파이어베이스 설정 -&gt; 서비스 계정 -&gt; 새 비공키 키 생성시 .json파일 다운 가능 -&gt; 해당 경로 입력\") firebase_admin.initialize_app(cred)  # 2. 대상 유저의 FCM 토큰 fcm_token = \"빌드하면 나오는 FCM 입력\"  # 3. 전송할 메시지 title = \"새 댓글이 달렸어요!\" body = \"당신의 게시글에 누군가 댓글을 남겼습니다.\"  # 4. 알림 메시지 구성 message = messaging.Message(     token=fcm_token,     notification=messaging.Notification(         title=title,         body=body,     ) )  # 5. 메시지 전송 try:     response = messaging.send(message)     print(\"✅ 메시지 전송 성공:\", response) except Exception as e:     print(\"❌ 메시지 전송 실패:\", e)                           앱이 종료되어있을 때     앱 실행중일 때      Reference      https://bannavi.tistory.com/558   https://dokit.tistory.com/49   https://dokit.tistory.com/50   https://velog.io/@niro/Firebase-Push-Notification-알림-보내기-with-SwiftUI   https://yagom.net/forums/topic/push-알림을-보낼-때-fcm-과-apns-의-차이점이-있나요/   ","categories": [],
        "tags": ["UIKit"],
        "url": "/UIKit-FCM/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[CleanArchitecture] SOLID, MVVM, CleanArchitecture",
        "excerpt":"        SOLOD, MVVM, CleanArchitecture   클린 아키텍처를 알기 위해서는 MVVM을 알아야 하고 MVVM을 알기 위해서는 SOLID 원칙을 알아야 한다.  SOLID 원칙 -&gt; MVVM -&gt; Interface -&gt; Clean Architecture 순서로 정리하였다.   원칙이란?         원칙을 지키면 시간이 흐른 뒤에는 큰 영향을 가져온다.   원칙을 지키지 않는다면 어디서부터 어떻게 고쳐야 할 지 어렵고, 한 부분을 해결하면 다른 부분에서 문제가 발생할 수도 있다.   SOLID 프로그램의 원칙을 지키면 프로젝트 규모가 커질수록 큰 영향을 가져온다.   SOLID 원칙을 지키면 얻을 수 있는 효과가 유지보수성이다.   유지보수가 쉬운 코드 = 어떤 상황에서도 잘 동작하고 변경에 용이     SOLID 원칙      SOLID원칙은 5가지 원칙을 의미한다.   1. 단일 책임 원칙      클래스는 하나의 책임만을 가져야 한다.   (책임 = 변경이 일어날 때 영향을 받는다라고 가정)   ex) ViewConntroller의 책임     UI 그리기   (&lt;- 책임)   UI 로직 구현   API 호출   내부 데이터 저장, 불러오기   =&gt; 이 4개중에 하나의 책임만 가져야 한다. 여기서는 UI 그리기가 책임이 된다.       2. 개팡 폐쇄 원칙      클래스는 기능의 확장에 있어서 열려 있어야 하고 수정에는 닫혀 있어야 한다.     ViewModel에서 User 데이터에 대한 타입이 변경되면 ViewModel에 의존하는 ViewController가 영향을 받는다.  하지만 ViewController에서 UI에 대한 코드가 변경되면 안된다.         예제코드 \t        3. 인터페이스 분리 원칙      사용하지 않는 인터페이스는 쓰지 않아야 한다.     사진과 같이 ViewController가 property1과 func3만 사용한다면  ViewController입장에서 나머지 property2, func1, func2는 필요 없다. 이럴때는 인터페이스를 분리해야 한다.       4. 의존성 역전 원칙      고수준 모듈은 저수준 모듈에 의존해서는 안된다. 둘다 추상화에 의존해야 한다.     저수준은 UI와 같이 잘 바뀌는 코드를 의미하고 고수준은 앱에서 핵심 기능인 잘 안바뀌는 기능을 의미한다.(쇼핑앱에서는 결제 기능과 유사)  즉 쉽게 바뀌는 코드가 쉽게 바뀌지 않는 코드를 의존해야 한다.  참고로 추상화(인터페이스)에 의존해야한다.         예제코드 \t        5. 리스코프 치환원칙      자식 클래스는 언제나 자신의 부모 클래스로 교체할 수 있어야 한다. 즉 부모 타입을 사용하는 곳에 자식 타입을 넣어도 정상적으로 작동해야 한다.         리스코프 치환 위반 예시 \t         리스코프 치환 지키는 예시  \t     MVVM      SOLID 원칙을 지키기 위해 MVVM 패턴을 사용한다. MVVM패턴을 지키면 자연스럽게 SOLID 원칙을 지킬 수 있다. MVVM은 Model, View, ViewModel로 3등분으로 구성된다.   그림 상세내용(참고)      View는 UI를 표현하고 버튼 클릭이나 텍스트 입력과 같은 이벤트를 ViewModel으로 전달한다.   ViewModel은 View(UI)와 관련한 로직을 모두 처리하거나 상태를 보유한다. 또한 View에서 전달된 이벤트에 따라 바뀐 상태나 바뀐 UI 관련 로직을 처리하고 필요시 ViewController에게 바로 상태를 전달하고, 만약 더 핵심적인 비즈니스 로직(API 호츌)이 필요하면 Model에 전달하여 Model에서 핵심 비즈니스 로직을 처리하고 데이터를 다시 ViewModel로 전달해주고 ViewModel에서 UI적인 로직을 처리하여 ViewController에게 상태나 데이터를 전달한다.   MVVM 구성                  구성 요소       역할                       Model       데이터와 비즈니스 로직 (API 통신, 데이터 가공 등)                 ViewModel       View에 필요한 상태와 로직을 관리 (UI 상태 결정, 이벤트 처리)                 View (UI)       사용자 입력, 화면 표시 (이벤트는 ViewModel로 전달)           🔁 의존성 방향      View → ViewModel: View는 ViewModel에 의존 (버튼 클릭 → 메서드 호출 등)   ViewModel → Model: ViewModel은 데이터가 필요할 때 Model에 요청   Model은 아무것도 모름 (하위 계층은 상위 계층을 몰라야 함 = DIP 적용)   의존성의 방향은 잘 변경되는 쪽이 잘 변경되지 않는 쪽을 바라본다, 즉 각 구성요소가 단방향적인 의존성을 지키고 있다.         SOLID 원칙 적용 전 MVVM 코드 (DIP 위반) \t         SOLID 원칙 적용 후 MVVM 코드 (DIP, OCP 등 만족) \t     Interface   클린아키텍처를 이해하기위해 인터페이스 개념을 다시 한번 알고 가자.   인터페이스란?      우리가 흔이 말하는 앱의 유저 인터페이스(UI)는 사용자가 직접 마주하는 화면을 의미한다.   어떻게 구성되고, 어떻게 동작하며, 어떤 방식으로 정의한다.   ❄️ 냉장고로 예시를 들어본다면      유저 인터페이스(UI): 손잡이, 버튼, 디스플레이   내부 로직: 온도 조절, 냉각 등 실제 동작   중요한 포인트:      사용자는 내부 로직을 몰라도, 버튼 하나로 냉장고를 조작할 수 있다.      → 즉, “인터페이스만 알면 사용 가능”한 구조다.         냉장고의 UI는 ViewController, 내부 로직은 ViewModel로 비유할 수 있다.   ViewController는 “냉장고 온도를 내려주세요”라고 요청만 한다.   실제 로직(냉각, 온도 계산 등)은 ViewModel이 처리한다.   인터페이스를 정리하자면         ViewController가 ViewModel을 직접 구현이 아닌 인터페이스(Protocol)에 의존하면,   내부 로직이 바뀌더라도 ViewController는 수정 없이 그대로 동작할 수 있다.   이렇게 구현을 감추고 필요한 기능만 정의한 것을 **추상화**라고 한다.  인터페이스를 사용하는이유 = 의존성을 최소화 하기 위해 = 변경을 대응하기 위함.     Clean Architecture     엉글  밥Robert C. Martin)이 제시한 추상적인 개념으로서 관심사를 분리시키고 의존도를 낮추는 것에 목적을 둔 아키텍처이다. 모바일 뿐만 아니라 웹이나 서버 등 여러 곳에서 많이 사용하는 아키텍처이다. 모바일 기준으로는 조금 단순화한 아래 사진을 참고하면 된다.     모바일 기준으로는 크게 3개의 계층(Layer)로 분류한다. Domain Layer, Data Layer, Presentation Layer로 분류한다.     1. Domain Layer   Domain Layer는 프로젝트의 가장 핵심적인 영역이며,    비즈니스의 규칙과 요구사항을 직접 담고 있는 계층이다.   구성 요소      Entity - 모델 정의   UseCase - 핵심적인 비즈니스 로직을 담은 역할            유저 리스트 불러오기       유저 상세 데이터 불러오기       유저를 내부 저장소에 저장하기           Repository Protocol(인터페이스) - UseCase와 Data Layer(서버 API, 로컬 DB)를 연결해주는 중간 다리 역할            UseCase와 Data Layer 사이를 연결하는 추상화 계층       데이터의 출처가 무엇이든 (API, DB 등) UseCase는 몰라도 된다             2. Data Layer   데이터를 가져오는 역할이다.      DB   API   Repository 구현체            API를 사용할지 DB를 사용할지를 Repository를 통해서 가져온다.       Repository를 통해 가져오므로 API나 DB를 직접 의존할 필요가 없다.           왜 Repository를 사용하는가?      UseCase는 데이터가 어디서 오는지 알 필요 없다.            API든, CoreData든, Realm이든 전혀 신경 쓰지 않는다.           Repository가 데이터의 출처를 감싸서 대신 처리해준다.            덕분에 UseCase는 오직 기능 수행에만 집중 가능           Repository는 인터페이스만 존재하며, 실제 구현은 Data Layer에서 처리한다.     3. Presentation Layer      MVVM에서 ViewController(UI)와 ViewModel(Presentor)을 의미한다.            M을 제외한 VVM이 Presentation에 존대한다.       M은 Data/Domain Layer둘다 포함한다.       MVVM에서 클린 아키텍처 확장함에 있어서 M이 세분화 되었다.           UI   Presenters(=ViewModel)       의존성이 바깥에서 안으로 향하고 있다.  고수준(Domain Layer)는 변동이 거의 일어나지 않는다. 저수준(Presentation Layer)는 변동이 자주 발생한다. 의존성의 방향은 자주 변하는 쪽에서 자주 변하지 않는 쪽으로 의존한다.  저수준은 고수준을 의존할 수 있지만. 고수준이 저수준을 의존하면 의존성 역전 원칙 위반이다.   의존성 역전 원칙 위반 예시   // 저수준 Data Layer class Repository {     func getUsers() {} }  // 고수준 Domain Layer class Usecase {     private let repository = Repository() // 2. 고수준(Usecase)이 저수준(Repository)을 의존하고있다 -&gt; 의존성 역전 위반     func getUsers() {         repository.getUsers()     } }  // 저수준 Presentation Layer class ViewModel {     private let usecase = Usecase() // 1. 저수준(ViewModel)이 고수준(usecase)을 의존하고 있다 O }   의존성 역전 시킨 좋은 예시   // 의존성 역전을 하려면 -&gt; Protocol(인터페이스)를 사용하면 된다.  // 인터페이스는 추상화 한 개념이라 변경이 일어나지 않기 때문에 항상 고수준이다. // ViewModel, Repository는 저수준, Usecase는 고수준  // Domain Layer protocol RepositoryProtocol {     func getUsers() }  // 저수준 Data Layer class Repository: RepositoryProtocol {     func getUsers() {} }  // 고수준 Domain Layer class Usecase {     private let repository: RepositoryProtocol // 2. 고수준(Usecase)이 고수준(protocol)을 의존하고있다 -&gt; 의존성 역전 시켜서 클린아키텍처 원칙을 만족 O          init(repository: RepositoryProtocol) {         self.repository = repository     }          func getUsers() {         repository.getUsers()     } }   // 저수준 Presentation Layer class ViewModel {     private let usecase = Usecase(repository: Repository()) // 1. 저수준(ViewModel)이 고수준(usecase)을 의존하고 있다 -&gt; 클린아키텍처 원칙 만족 }        최종 Clean Architecture 구조      ","categories": [],
        "tags": ["CleanArchitecture"],
        "url": "/CleanArchitecture-Clean-Architecture/",
        "teaser": "/assets/img/2025-05-24-%5BCleanArchitecture%5D-Clean%20Architecture/image-20250524210248333.png"
      },{
        "title": "[Xcode] 프로젝트에 SwiftLint적용하기",
        "excerpt":"    프로젝트에 SwiftLint적용하기        brew install swiftlint   공식 사이트  설치는 SPM, Pod 등 여러 방법으로 설치할 수 있다. 다양한 프로젝트에 계속 사용하기 위해 HomeBrew로 설치 진행.         New Run Script Phase 클릭하여 추가한다.  여기 컴파일(Run)시에 추가적으로 수행할 쉘 스크립트를 작성할 수 있다.          // 1번 방식 if which swiftlint &gt;/dev/null; then   swiftlint else   echo \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\" fi  // 2번 방식(나는 이걸로 성공) export PATH=\"$PATH:/opt/homebrew/bin\" if which swiftlint &gt; /dev/null; then   swiftlint else   echo \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\" fi   그다음 이 코드를 스크립트에 추가한다.         Run Script라는 이름을 SwiftLint Script로 바꿔 준 다음, 위치를 Compile Sources위로 올려준다.  컴파일 하기 전에 스크립트를 실행시켜서 SwiftLint를 검사하는 것이 효율적이라고 순서를 이렇게 한다고 한다.         .swiftlint.yml파일을 만들고 빌드(commakd + R) 해보면 Sandbox 관련 오류가 발생한다.            Build Settings -&gt; User Script Sandboxing 검색후 No로 변경해준다.       # swiftlint.yml  # 사용하지 않을 규칙 설정 disabled_rules:   - force_cast               # 강제 형변환 사용 시 경고하지 않음   - trailing_whitespace      # 줄 끝 공백에 대해 경고하지 않음  # 식별자(변수, 상수, 함수 이름 등)의 글자 수 제한 identifier_name:   min_length: 1              # 최소 글자 수: 1자   max_length: 40             # 최대 글자 수: 40자   allowed_symbols: [\"_\"]     # 밑줄(_) 사용 허용   validates_start_with_lowercase: true  # 소문자로 시작해야 함  # 사이클 복잡도 설정 (분기 개수) cyclomatic_complexity:   warning: 20                # 20 이상이면 경고   error: 30                  # 30 이상이면 오류  # 함수 본문의 줄 수 제한 function_body_length:   warning: 120               # 120줄 이상이면 경고   error: 160                 # 160줄 이상이면 오류  # 클래스, 구조체, enum 등의 본문 줄 수 제한 type_body_length:   warning: 500               # 500줄 이상이면 경고   error: 1000                # 1000줄 이상이면 오류  # 한 줄의 최대 길이 제한 line_length:   warning: 200               # 200자 이상이면 경고   error: 300                 # 300자 이상이면 오류   ignores_comments: true     # 주석은 길이 제한에서 제외   ignores_urls: true         # URL은 길이 제한에서 제외    .yml코드 완성을 해주면 끝난다.       Reference      https://dokit.tistory.com/64   https://didu-story.tistory.com/274   ","categories": [],
        "tags": ["Xcode"],
        "url": "/UIKit-SwiftLint/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Programmers] 1. 배열 정렬하기",
        "excerpt":"    문제  https://github.com/dremdeveloper/codingtest_cpp/blob/main/solution/01.cpp    정수 배열 arr을 오름차순으로 정렬해서 반환하는 solution() 함수를 완성하라.   제약조건     arr의 길이는 2 이상 10^5 이하이다.   arr의 원소 값은 -100,000 이상 100,000 이하이다.   입출력 예  [1, -5, 2, 4, 3] -&gt; [-5, 1, 2, 3, 4]    [2, 1, 1, 3, 2, 5,4] -&gt; [1, 1, 2, 2, 3, 4, 5]    [6, 1, 7] -&gt; 1, 6, 7   풀이  기본적인 정렬 사용법이 요구되었다.  import Foundation  func solution(_ arr: [Int]) -&gt; [Int] {     return arr.sorted() }  // 결과를 출력하는 함수 func printSolution(_ vec: [Int]) {     print(vec.map { String($0) }.joined(separator: \" \")) }  // 메인 함수 func start() {     printSolution(solution([1, -5, 2, 4, 3]))     printSolution(solution([2, 1, 1, 3, 2, 5, 4]))     printSolution(solution([6, 1, 7])) }  @main struct Main {     static func main() {         start()     } }   #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  vector&lt;int&gt; solution(vector&lt;int&gt; arr) {     sort(arr.begin(), arr.end());     return arr; }  // 테스트 코드 #include &lt;iostream&gt; void print(vector&lt;int&gt; vec) {     copy(vec.begin(), vec.end(), std::ostream_iterator&lt;int&gt;(cout, \" \"));     cout &lt;&lt; endl; }  int main() {     print(solution({1, -5, 2, 4, 3}));      // -5 1 2 3 4     print(solution({2, 1, 1, 3, 2, 5, 4})); // 1 1 2 2 3 4 5     print(solution({6, 1, 7}));             // 1 6 7          return 0; }  ","categories": [],
        "tags": ["Programmers"],
        "url": "/Programmers-1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Programmers] 2. 배열 제어하기",
        "excerpt":"    문제  https://github.com/dremdeveloper/codingtest_cpp/blob/main/solution/02.cpp    정수 배열 lst가 주어진다. 배열의 중복값을 제거하고 배열 데이터를 내림차순으로 정렬해서 반환하는 solution()함수를 구현하라.   제약조건     lst의 길이는 2 이상 1,000 이하이다.   lst의 원소 값은 -100,000 이상 100,000 이하이다.   입출력 예  [4, 2, 2, 1, 3, 4] -&gt; [4, 3, 2, 1]    [2, 1, 1, 3, 2, 5, 4] -&gt; [5, 4, 3, 2, 1]   풀이  배열과 Set 사용법이 요구되었다.   import Foundation  func compare(_ a: Int, _ b: Int) -&gt; Bool {     return a &gt; b }  func solution(_ lst: [Int]) -&gt; [Int] {     let setList = Array(Set(lst))                // O(n)      let sortedList = setList.sorted(by: compare) // O(n logn) -&gt; Timsort     return sortedList }  // 결과를 출력하는 함수 func printSolution(_ vec: [Int]) {     print(vec.map { String($0) }.joined(separator: \" \")) }  // 메인 함수 func main() {     printSolution(solution([4, 2, 2, 1, 1, 3, 4])) // 4 3 2 1     printSolution(solution([2, 1, 1, 3, 2, 5, 4])) // 5 4 3 2 1 }  main()   #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  bool compare(int a, int b) {     return a &gt; b; }  // sort(시작 반복자, 끝 반복자) // sort(시작 반복자, 끝 반복자, 비교 함수)    비교 함수는 반환값이 false일 때 원소의 위치를 바꾼다 // sort(v.rbegin(), v.rend()) vector&lt;int&gt; solution(vector&lt;int&gt; lst) {     //sort(lst.rbegin(), lst.rend());     sort(lst.begin(), lst.end(), compare);                // O(n log n) -&gt; IntroSort     lst.erase(unique(lst.begin(), lst.end()), lst.end()); // O(n)     return lst; }  #include &lt;iterator&gt; void print(vector&lt;int&gt; vec) {     copy(vec.begin(), vec.end(), std::ostream_iterator&lt;int&gt;(cout, \" \"));     cout &lt;&lt; endl; }  int main() {     print(solution({4, 2, 2, 1, 1, 3, 4})); // 4 3 2 1     print(solution({2, 1, 1, 3, 2, 5, 4})); // 5 4 3 2 1          return 0; }  ","categories": [],
        "tags": ["Programmers"],
        "url": "/Programmers-2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Programmers] 3. 두 수를 뽑아서 더하기",
        "excerpt":"    문제  https://github.com/dremdeveloper/codingtest_cpp/blob/main/solution/03.cpp    정수 배열 numbers가 주어진다. numbers에서 서로 다른 인덱스에 있는 2개의 수를 뽑아 더해 만들 수 있는 모든 수를 배열에 오름차순으로 담아 반환하는 solution() 함수를 완성하라.   제약조건     numbers의 길이는 2 이상 100 이하이다.   numbers의 모든 수는 0 이상 100 이하이다.   입출력 예  [2, 1, 3, 4, 1] -&gt; [2, 3, 4, 5, 6, 7]    [5, 0, 2, 7] -&gt; [2, 5, 7, 9, 12]   풀이      조합 nCr - 순서가 중요하지 않음       공통 공식:    \\(C(n, r) = \\frac{n!}{(n - r)! \\cdot r!}\\)   예시: 5명 중 2명을 뽑는 경우    \\(C(5, 2) = \\frac{5!}{3! \\cdot 2!} = \\frac{120}{6 \\cdot 2} = 10\\)      순열 nPr - 순서가 중요함       공통 공식:    \\(P(n, r) = \\frac{n!}{(n - r)!}\\)   예시: 5명 중 2명을 뽑아 순서를 나누는 경우    \\(P(5, 2) = \\frac{5!}{3!} = \\frac{120}{6} = 20\\)   이 문제에서는 조합으로 풀면 된다.  /*      4 2 2 1 1 3 4      2 2 1 1 3 4      2 1 1 3 4      1 1 3 4      1 3 4      3 4      4 */ import Foundation  func solution(_ numbers: [Int]) -&gt; [Int] {      // 배열 크기     let cnt = numbers.count          // 두 수의 합을 저장할 공간     var set = Set&lt;Int&gt;()          for i in 0..&lt;cnt {         for j in i+1..&lt;cnt {             // 모든 조합의 합             set.insert(numbers[i] + numbers[j]) // O(n^2)          }      }     return Array(set).sorted()                  // Set -&gt; Array O(n)                                                 // sorted() O(n^2 log n) }  func printSolution(_ vec: [Int]) {     print(vec.map { String($0) }.joined(separator: \" \")) }  func main() {     printSolution(solution([2, 1, 3, 4, 1])) // 2 3 4 5 6 7     printSolution(solution([5, 0, 2, 7]))    // 2 5 7 9 12 }  main()   #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std;  // 내가한 방법 vector&lt;int&gt; solution2(vector&lt;int&gt; numbers) {     vector&lt;int&gt; arr;     for (int i=0; i&lt;numbers.size(); i++) {         for (int j=i+1; j&lt;numbers.size(); j++)         arr.push_back(numbers[i] + numbers[j]); // O(n^2)     }     sort(arr.begin(), arr.end());               // O(n^2 log n^2) = O(n^2 log n)     arr.erase(unique(arr.begin(), arr.end()), arr.end()); // O(n^2)     return arr; }  // 모범 답안 // set은 중복값을 자동으로 제거해주고, 오름차순으로 데이터를 정렬해준다 vector&lt;int&gt; solution(vector&lt;int&gt; numbers) {     set&lt;int&gt; sum;     for (int i=0; i&lt;numbers.size(); i++) {         for (int j=i+1; j&lt;numbers.size(); j++) {               sum.insert(numbers[i] + numbers[j]); // O(n^2 log n)         }     }     vector&lt;int&gt; answer(sum.begin(), sum.end());     return answer; }  ","categories": [],
        "tags": ["Programmers"],
        "url": "/Programmers-3/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Programmers] 4. 모의고사",
        "excerpt":"    문제  https://github.com/dremdeveloper/codingtest_cpp/blob/main/solution/04.cpp    https://school.programmers.co.kr/learn/courses/30/lessons/42840    수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다.     수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.   1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …    2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …    3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, …    1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.   제약조건     시험은 최대 10,000 문제로 구성되어있습니다.   문제의 정답은 1, 2, 3, 4, 5중 하나입니다.   가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.   입출력 예  [1, 2, 3, 4, 5]\t-&gt; [1]    [1, 3, 2, 4, 2] -&gt; [1, 2, 3]   풀이  import Foundation  func solution(_ answers: [Int]) -&gt; [Int] {          let firstPattern = [1, 2, 3, 4, 5]     let secondPattern = [2, 1, 2, 3, 2, 4, 2, 5]     let thirdParrern = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]     var scoreBox = Array(repeating: 0, count: 3)     var answer: [Int] = []          for i in 0..&lt;answers.count {         if answers[i] == firstPattern[i%firstPattern.count] { scoreBox[0] += 1 }         if answers[i] == secondPattern[i%secondPattern.count] { scoreBox[1] += 1 }         if answers[i] == thirdParrern[i%thirdParrern.count] { scoreBox[2] += 1 }     }          let maxScore: Int = scoreBox.max()!          for i in 0..&lt;3 {         if maxScore == scoreBox[i] {             answer.append(i+1)         }     }     return answer }   #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  vector&lt;int&gt; solution(vector&lt;int&gt; answers) {     vector&lt;int&gt; firstVec({1, 2, 3, 4, 5});     vector&lt;int&gt; secondVec({2, 1, 2, 3, 2, 4, 2, 5});     vector&lt;int&gt; thirdVec({3, 3, 1, 1, 2, 2, 4, 4, 5, 5});     vector&lt;int&gt; scoreBox(3, 0);  // 실제 정답과 비교하여 수포자들의 패턴을 비교해서 맞춘 개수     vector&lt;int&gt; answer;          // 가장 문제를 많이 맞춘 사람이 저장될 벡터          for (int i=0; i&lt;answers.size(); i++) {         if (answers[i] == firstVec[i%firstVec.size()]) {             scoreBox[0] += 1;         }         if (answers[i] == secondVec[i%secondVec.size()]) {             scoreBox[1] += 1;         }         if (answers[i] == thirdVec[i%thirdVec.size()]) {             scoreBox[2] += 1;         }     }     // 가장 많이 맞춘 수포자가 얻은 점수     int maxScore = *max_element(scoreBox.begin(), scoreBox.end());          // 가장 많이 맞춘 수포자의 번호를 저장     for (int i=0; i&lt;3; i++) {         if (scoreBox[i] == maxScore) {             answer.push_back(i+1);         }     }          return answer; }  #include &lt;iostream&gt; void print(vector&lt;int&gt; vec) {     copy(vec.begin(), vec.end(), std::ostream_iterator&lt;int&gt;(cout, \" \"));     cout &lt;&lt; endl; }  int main() {     print(solution({1, 2, 3, 4, 5}));     // 1     print(solution({1, 3, 2, 4, 2}));     // 1, 2, 3     return 0; }  ","categories": [],
        "tags": ["Programmers"],
        "url": "/Programmers-4/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Xcode] fastlane 에러 해결",
        "excerpt":"    fastlane 에러 해결   깃 저장소에서 관련 내용 삭제  ## 각 명령에서 질문 나오면 y 눌러주기 -&gt; 깃허브에서 제거됨 fastlane match nuke distribution fastlane match nuke development   ## 인증서 &amp; 프로비저닝 프로파일 생성 -&gt; 깃허브에 저장됨 fastlane match appstore fastlane match development   ## 팀원이 같은 인증서를 내려받을 때 fastlane match appstore --readonly fastlane match development --readonly   ","categories": [],
        "tags": ["Xcode"],
        "url": "/UIKit-fastlaneError/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Library] Kingfisher",
        "excerpt":"    Kingfisher 기능     이미지 로드 기능(url을 넘겨주면 이미지를 로드한다)   이미지 캐시 기능   UIImageView에 편리하게 round 처리 기능   이미지 다운로드 기능   이미지 로드 기능  private func loadImage() {     guard let url = URL(string: \"https:\\\\...\")     myImageView.kf.setImage(with: url) }   Indicator 기능  myImageView.kf.indicatorType = .activity myImageView.kf.setImage(     with: url,     placeHolder: nil,     options: nil.     completionHandler: nil )   예제코드  import UIKit import Kingfisher  final class KingfisherViewController: UIViewController {          private lazy var myImageView: UIImageView = {         let image = UIImageView()         image.layer.cornerRadius = 30         image.clipsToBounds = true         return image     }()          override func viewDidLoad() {         super.viewDidLoad()                  makeUI()         constraints()         loadImage()     }          private func makeUI() {         view.backgroundColor = .white         view.addSubview(myImageView)         myImageView.translatesAutoresizingMaskIntoConstraints = false     }          private func constraints() {         NSLayoutConstraint.activate([             myImageView.centerYAnchor.constraint(equalTo: view.centerYAnchor),             myImageView.centerXAnchor.constraint(equalTo: view.centerXAnchor),                          myImageView.widthAnchor.constraint(equalToConstant: 300),             myImageView.heightAnchor.constraint(equalToConstant: 200)         ])     }          private func loadImage() {         guard let url = URL(string: \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQv8sv01DK7BoJGaJMZ972ig5mQ_JBbqxdINQ&amp;s\") else { return }                          myImageView.kf.setImage(with: url)     } }  #Preview {     KingfisherViewController() }       Reference      https://ios-development.tistory.com/793  ","categories": [],
        "tags": ["Library"],
        "url": "/Library-Kingfisher/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Programmers] 5. 행렬의 곱셈",
        "excerpt":"    문제  https://github.com/dremdeveloper/codingtest_cpp/blob/main/solution/05.cpp    https://school.programmers.co.kr/learn/courses/30/lessons/12949  2차원 배열 arr1과 arr2를 입력받아 arr1에 arr2를 행렬 곱한 결과를 반환하는 solution() 함수를 완성하라   제약조건     배열 arr1, arr2의 행과 열의 길이는 2이상 100 이하이다.   배열 arr1, arr2의 데이터는 -10 이상 20 이하인 자연수다.   행렬 곱 할 수 있는 배열만 주어진다.   입출력 예  [[1, 4], [3, 2], [4, 1]]   [[3, 3], [3, 3]]  -&gt; [[15, 15], [15, 15], [15, 15]]   [[2, 3, 2], [4, 2, 4], [3, 1, 4]]  [[5, 4, 3], [2, 4, 1], [3, 1, 1]]  -&gt; [[22, 22, 11], [36, 28, 18], [29, 20, 14]]   풀이  행렬 ( A ) (크기 ( m \\times n ))와 행렬 ( B ) (크기 ( n \\times p ))의 곱은 행렬 ( C = AB ) (크기 ( m \\times p ))로 정의된다.   \\[C_{ij} = \\sum_{k=1}^{n} A_{ik} \\cdot B_{kj}\\]  즉, ( C )의 ( i )행 ( j )열 원소는 ( A )의 ( i )행과 ( B )의 ( j )열의 내적이다.     🔢 예시 1: 2x2 행렬 곱셈   \\[A = \\begin{bmatrix} 1 &amp; 2 \\\\\\\\ 3 &amp; 4 \\end{bmatrix}, \\quad B = \\begin{bmatrix} 5 &amp; 6 \\\\\\\\ 7 &amp; 8 \\end{bmatrix}\\]  \\[AB = \\begin{bmatrix} 1 \\cdot 5 + 2 \\cdot 7 &amp; 1 \\cdot 6 + 2 \\cdot 8 \\\\\\\\ 3 \\cdot 5 + 4 \\cdot 7 &amp; 3 \\cdot 6 + 4 \\cdot 8 \\end{bmatrix} = \\begin{bmatrix} 19 &amp; 22 \\\\\\\\ 43 &amp; 50 \\end{bmatrix}\\]    🔢 예시 2: 3x3 행렬 곱셈   \\[A = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\\\\\ 4 &amp; 5 &amp; 6 \\\\\\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix}, \\quad B = \\begin{bmatrix} 9 &amp; 8 &amp; 7 \\\\\\\\ 6 &amp; 5 &amp; 4 \\\\\\\\ 3 &amp; 2 &amp; 1 \\end{bmatrix}\\]  \\[AB = \\begin{bmatrix} 30 &amp; 24 &amp; 18 \\\\\\\\ 84 &amp; 69 &amp; 54 \\\\\\\\ 138 &amp; 114 &amp; 90 \\end{bmatrix}\\]  A 행렬의 크기가 (MK)이고, B 행렬의 크기가 (KN)일 때 두 행렬의 곱 연산은 행렬 A의 행의 개수(K)와 행렬 B의 열의 개수(k)가 같아야 하며 K를 기준으로 곱하기 때문에 행렬 곱 결과는 M * N이 된다.   import Foundation  func solution(_ arr1: [[Int]], _ arr2: [[Int]]) -&gt; [[Int]] {          let rows = arr1.count     let cols = arr2[0].count      // 최종 행렬 곱 결과를 저장할 배열 선언     var answer = Array(repeating: Array(repeating: 0, count: cols), count: rows)          // arr1의 각 행과 arr2의 각 열에 대해 반복문 수행     for row in 0..&lt;rows {         for col in 0..&lt;cols {             for k in 0..&lt;arr2.count {                 answer[row][col] += arr1[row][k] * arr2[k][col]             }         }     }             return answer }  func print2D(_ vec: [[Int]]) {     for row in vec {         print(row.map { String($0) }.joined(separator: \" \"))     }     print() }  func main() {     print2D(solution(         [             [1, 4],             [2, 3],             [4, 1]         ],         [             [3, 3],             [3, 3]         ]))          print2D(solution(         [            [2, 3, 2],            [4 ,2, 4],            [3, 1, 4]         ],         [             [5, 4, 3],             [2, 4, 1],             [3, 1, 1]         ])) }  main()   #include &lt;string&gt; #include &lt;vector&gt;  using namespace std;  vector&lt;vector&lt;int&gt;&gt; solution(vector&lt;vector&lt;int&gt;&gt; arr1, vector&lt;vector&lt;int&gt;&gt; arr2) {          // 최종 행렬 곱 결과를 저장할 벡터 선언     vector&lt;vector&lt;int&gt;&gt; answer;          // arr1, arr2 행렬 곱을 수행했을 때 최종 행렬의 크기만큼 공간을 할당     answer.assign(arr1.size(), vector&lt;int&gt;(arr2[1].size(), 0));          // arr1의 각 행과 arr2의 각 열에 대해 반복문 수행     for (int i=0; i&lt;arr1.size(); i++) {         for (int j=0; j&lt;arr2[0].size(); j++) {             for (int k=0; k&lt;arr2.size(); k++) {                 answer[i][j] += arr1[i][k] * arr2[k][j];             }         }     }          return answer; }  ","categories": [],
        "tags": ["Programmers"],
        "url": "/Programmers-5/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[RxSwift] 3. RX + MVVM + Input/output 패턴",
        "excerpt":"RX - MVVM 예시   기존 코드 - view와 viewModel 구분 없이 하나의 코드로 작성  import UIKit import FirebaseAuth import RxSwift  final class SettingViewController: UIViewController {          private let disposeBaag = DisposeBag()          weak var coordinator: HomeCoordinator?      private let viewModel = SettingViewModel()     private let homeViewModel: HomeViewModelType          init(homeViewModel: HomeViewModelType) {         self.homeViewModel = homeViewModel         super.init(nibName: nil, bundle: nil)     }          required init?(coder: NSCoder) {         fatalError(\"init(coder:) has not been implemented\")     }          // MARK: - UI Component     private lazy var logoutBtn: UIButton = {         let button = UIButton(type: .system)         button.setTitle(\"로그아웃\", for: .normal)         button.addTarget(self, action: #selector(logout), for: .touchUpInside)         return button     }()      // MARK: - LifeCycle     override func viewDidLoad() {         super.viewDidLoad()         makeUI()         constraints()     }          // MARK: - UI Setting     private func makeUI() {         view.backgroundColor = .background                  [logoutBtn].forEach {             view.addSubview($0)             $0.translatesAutoresizingMaskIntoConstraints = false         }     }          private func constraints() {         NSLayoutConstraint.activate([             logoutBtn.centerXAnchor.constraint(equalTo: view.centerXAnchor),             logoutBtn.centerYAnchor.constraint(equalTo: view.centerYAnchor),         ])     }              @objc func logout() {         do {             UserDefaultsManager.shared.removeUser()             UserDefaultsManager.shared.removeGroup()             try Auth.auth().signOut()             print(\"로그아웃 성공\")             coordinator?.showLogin()             homeViewModel.stopObservingGroup()                                   } catch let signOutError as NSError {             print(\"로그아웃 실패: %@\", signOutError)         }     } }  #Preview {     SettingViewController(homeViewModel: StubHomeViewModel(previewPost: .samplePosts[0])) }   개선 코드 - view와 viewModel 구분  // View import UIKit import FirebaseAuth import RxSwift  final class SettingViewController: UIViewController {          private let disposeBaag = DisposeBag()          weak var coordinator: HomeCoordinator?      private let viewModel = SettingViewModel()     private let homeViewModel: HomeViewModelType          init(homeViewModel: HomeViewModelType) {         self.homeViewModel = homeViewModel         super.init(nibName: nil, bundle: nil)     }          required init?(coder: NSCoder) {         fatalError(\"init(coder:) has not been implemented\")     }          // MARK: - UI Component     private lazy var logoutBtn: UIButton = {         let button = UIButton(type: .system)         button.setTitle(\"로그아웃\", for: .normal)         return button     }()      // MARK: - LifeCycle     override func viewDidLoad() {         super.viewDidLoad()         makeUI()         constraints()         bindViewModdel()     }          // MARK: - UI Setting     private func makeUI() {         view.backgroundColor = .background                  [logoutBtn].forEach {             view.addSubview($0)             $0.translatesAutoresizingMaskIntoConstraints = false         }     }          private func constraints() {         NSLayoutConstraint.activate([             logoutBtn.centerXAnchor.constraint(equalTo: view.centerXAnchor),             logoutBtn.centerYAnchor.constraint(equalTo: view.centerYAnchor),         ])     }          // MARK: - Binding     private func bindViewModdel() {                  // [Input] 로그아웃 버튼 탭 이벤트를 ViewModel에 전달         logoutBtn.rx.tap             .bind(onNext: { [weak self] in                 guard let self = self else { return }                 self.viewModel.logout()             })             .disposed(by: disposeBaag)                  // [Output] 로그아웃 처리 결과에 따라 UI 반응         viewModel.logoutResult             .observe(on: MainScheduler.instance)             .subscribe(onNext: { [weak self] result in                 guard let self = self else { return }                                  switch result {                 case .success:                     print(\"로그아웃 성공\")                     self.coordinator?.showLogin()                 case .failure(let error):                     print(\"로그아웃 실패: \\(error.localizedDescription)\")                 }             })             .disposed(by: disposeBaag)     } }   // ViewModel import FirebaseAuth import RxSwift import RxCocoa  protocol SettingViewModelType {     func logout() }  final class SettingViewModel: SettingViewModelType {          // 로그아웃 결과 이벤트     // 로그아웃 결과는 상태가 아닌 한번 일어나는 일회성 이벤트     let logoutResult = PublishRelay&lt;Result&lt;Void, Error&gt;&gt;()          func logout() {         do {             try Auth.auth().signOut()             logoutResult.accept(.success(()))             UserDefaultsManager.shared.removeUser()             UserDefaultsManager.shared.removeGroup()         } catch {             logoutResult.accept(.failure(error))         }     } }   개선 코드 - view와 viewModel 구분 및 Input/Output 패턴 추가  // View import UIKit import FirebaseAuth import RxSwift  final class SettingViewController: UIViewController {          private let disposeBaag = DisposeBag()          weak var coordinator: HomeCoordinator?      private let viewModel = SettingViewModel()     private let homeViewModel: HomeViewModelType          init(homeViewModel: HomeViewModelType) {         self.homeViewModel = homeViewModel         super.init(nibName: nil, bundle: nil)     }          required init?(coder: NSCoder) {         fatalError(\"init(coder:) has not been implemented\")     }          // MARK: - UI Component     private lazy var logoutBtn: UIButton = {         let button = UIButton(type: .system)         button.setTitle(\"로그아웃\", for: .normal)         return button     }()      // MARK: - LifeCycle     override func viewDidLoad() {         super.viewDidLoad()         makeUI()         constraints()         bindViewModel()     }          // MARK: - UI Setting     private func makeUI() {         view.backgroundColor = .background                  [logoutBtn].forEach {             view.addSubview($0)             $0.translatesAutoresizingMaskIntoConstraints = false         }     }          private func constraints() {         NSLayoutConstraint.activate([             logoutBtn.centerXAnchor.constraint(equalTo: view.centerXAnchor),             logoutBtn.centerYAnchor.constraint(equalTo: view.centerYAnchor),         ])     }          // MARK: - Binding     private func bindViewModel() {         // Input: 버튼 탭 이벤트를 viewModel로 전달         let input = SettingViewModel.Input(logoutTapped: logoutBtn.rx.tap.asObservable())                  // Output: transform으로부터 결과 스트림 반환         let output = viewModel.transform(input: input)                      // Output에 따라 UI 처리         output.logoutResult             .drive(onNext: { [weak self] result in                 guard let self = self else { return }                                  switch result {                 case .success:                     print(\"로그아웃 성공\")                     self.coordinator?.showLogin()                 case .failure(let error):                     print(\"로그아웃 실패: \\(error.localizedDescription)\")                 }                              }).disposed(by: disposeBaag)     } }   // ViewModel import FirebaseAuth import RxSwift import RxCocoa  final class SettingViewModel {          // Rx 리소스 해제를 위한 DisposeBag     private let disposeBag = DisposeBag()          // View로부터 전달받을 사용자 이벤트 정의     struct Input {         // 로그아웃 버튼 탭이벤트         let logoutTapped: Observable&lt;Void&gt;     }          // View에 전달할 출력 데이터 정의     struct Output {         // 로그아웃 성공 또는 실패에 대한 결과 스트림         // Driver를 사용하여 메인스레드에서 UI 바인딩에 안전하게 처리         let logoutResult: Driver&lt;Result&lt;Void, LoginError&gt;&gt;     }          /// Input을 받아 내부 로직을 수행 후 Output을 반환하는 함수     /// - Parameter input: View에서 발생한 이벤트     /// - Returns: 로그아웃 결과를 포함하는 Output     func transform(input: Input) -&gt; Output {                  // 로그아웃 버튼 탭시 로직을 수행하고 결과를 result로 반환         let result = input.logoutTapped             .map { _ -&gt; Result&lt;Void, LoginError&gt; in                 do {                     try Auth.auth().signOut()                     UserDefaultsManager.shared.removeUser()                     UserDefaultsManager.shared.removeGroup()                     return .success(())                 } catch {                     return .failure(.logoutError)                 }                 // 에러가 발생하더라도 UI가 멈추지 않고 기본 오류값으로 처리             }.asDriver(onErrorJustReturn: .failure(.logoutError))                  // View에서 사용할 Output rntjd         return Output(logoutResult: result)     } }  ","categories": [],
        "tags": ["ReactiveX","RxSwift"],
        "url": "/RxSwift-RxSwift-3/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[UIComponent] 네비게이션 버튼",
        "excerpt":"    ##   private func setupNavigation() {         self.navigationItem.rightBarButtonItem = UIBarButtonItem(             image: UIImage(systemName: \"gearshape.fill\"),             style: .plain,             target: self,             action: #selector(test)         )     }  ","categories": [],
        "tags": ["UIKit","UIComponent"],
        "url": "/UIKit-%EB%84%A4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98-%EB%B2%84%ED%8A%BC/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Xcode] 라이브러리 설치 에러 해결",
        "excerpt":"    해결법   ✅ Package.resolved 삭제 명령어  rm -f ./Package.resolved  rm -f ./EUMMEYO.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved  두 파일이 둘 다 존재할 수 있으니, 둘 다 삭제하는 게 좋습니다.  ✅ 이후 조치  Xcode 완전히 종료 (⌘ + Q)  다시 Xcode 실행  메뉴에서 → File → Packages → Resolve Package Versions 선택  🔁 그래도 안 되면?  Xcode &gt; Preferences &gt; Locations &gt; DerivedData 열기 → 전체 삭제  또는 터미널에서:  rm -rf ~/Library/Developer/Xcode/DerivedData   ","categories": [],
        "tags": ["Xcode"],
        "url": "/Xcode-XcodeError/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Ubuntu] 우분투 원격 서버 설정",
        "excerpt":"    우분투 원격 서버 설정   kt 공유기 링크  장치설정 -&gt; 트래픽 관리 -&gt; 포트포워딩 추가      CUI 세팅 및 접속  sudo apt update sudo apt install openssh-server  # 직접 실행 sudo systemctl start ssh  # 부팅 시 자동 실행 sudo systemctl enable ssh  # 서버 접속 ssh 로그인유저@링크 -p 포트번호     GUI 세틸 및 접속  # xrdp, xfce4, lightdm sudo apt update sudo apt install xrdp xfce4 lightdm -y  # .xsession 파일 재설정 echo \"startxfce4\" &gt; ~/.xsession chmod +x ~/.xsession  # 권한/세션 파일 정리 rm -f ~/.Xauthority ~/.ICEauthority  # xrdp 서비스 재시작 sudo systemctl restart xrdp  # lightdm 디스플레이 매니저로 고정 sudo dpkg-reconfigure lightdm  # Windows APP 프로그램으로 GUI 접속 진행   우분투 wake on lan 설정  # ethtool 설치 sudo apt update sudo apt install ethtool -y  # 현재 설정 확인 (유선 NIC명 확인, 예: enp1s0) -&gt; enp1s0, eth0 등 유선랜 이름 확인 ip link  # \"Wake-on: g\" 라고 나오면 WOL 지원 sudo ethtool enp1s0  # d로 되있으면 wake on lan 활성화 sudo ethtool -s enp1s0 wol g sudo ethtool enp1s0  # 재부팅 시 자동으로 WOL이 켜지도록, sudo nmcli connection show  # NAME            UUID                                  TYPE      DEVICE  # netplan-enp1s0  cac41fbe-bc18-3d87-bba7-af2af7f8ffab  ethernet  enp1s0  # lo              5ee3992e-8232-483a-88d7-6cf21f44d700  loopback  lo       # 아래 명령어를 입력 sudo nmcli connection modify \"netplan-enp1s0\" 802-3-ethernet.wake-on-lan magic sudo systemctl restart NetworkManager      ","categories": [],
        "tags": ["Xcode"],
        "url": "/Ubuntu-Ubuntu1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[CustomView] 커스텀 캘린더뷰 만들기",
        "excerpt":"    iOS 16부터 기본 제공되는 캘린더   기본 캘린더  import UIKit  final class BasicCalendarViewController: UIViewController {          // MARK: - UI Conponent     private lazy var calendarView: UICalendarView = {         let view = UICalendarView()         view.translatesAutoresizingMaskIntoConstraints = false         /// 점이나 뱃지 표시 등 달력 Custom 하기 위해 설정해야 하는 속성         view.wantsDateDecorations = true         return view     }()         override func viewDidLoad() {         super.viewDidLoad()                  makeUI()         constraints()     }          private func makeUI() {         view.backgroundColor = .white         view.addSubview(calendarView)     }          private func constraints() {         let calendarViewConstraints = [             calendarView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),             calendarView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 20),             calendarView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -20)         ]                  NSLayoutConstraint.activate(calendarViewConstraints)     } }   UICalendarSelectionSingleDateDelegate를 설정하여 날짜 선택시 이모지 표시  import UIKit  final class BasicCalendarViewController: UIViewController {          /// 현재 선택된 날짜     var selectedDate: DateComponents? = nil          // MARK: - UI Conponent     /// 날짜별 데코레이션(점, 이모지 등)을 지원하는 캘린더 뷰     private lazy var calendarView: UICalendarView = {         let view = UICalendarView()         view.locale = Locale(identifier: \"ko_KR\")         view.translatesAutoresizingMaskIntoConstraints = false         /// 점이나 뱃지 표시 등 달력 Custom 하기 위해 설정해야 하는 속성         view.wantsDateDecorations = true         return view     }()         override func viewDidLoad() {         super.viewDidLoad()                  self.makeUI()         self.constraints()         self.setCalendar()     }          /// 캘린더 delegate 및 날짜 선택 동작 설정     private func setCalendar() {         self.calendarView.delegate = self                  /// 한 번에 한 날짜만 선택 가능         let dateSection = UICalendarSelectionSingleDate(delegate: self)         /// 선택 이벤트(날짜 선택 시 콜백)를 BasicCalendarViewController에서 직접 처리하겠다         calendarView.selectionBehavior = dateSection     }          private func makeUI() {         view.backgroundColor = .white         view.addSubview(calendarView)     }          private func constraints() {         let calendarViewConstraints = [             calendarView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),             calendarView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 20),             calendarView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -20)         ]                  NSLayoutConstraint.activate(calendarViewConstraints)     }          /// 특정 날짜 셀만 데코레이션 새로고침(이모지 추가)     private func reloadDateView(date: Date?) {         if date == nil { return }         let calendar = Calendar.current         calendarView.reloadDecorations(forDateComponents: [calendar.dateComponents([.day, .month, .year], from: date!)], animated: true)     } }  // MARK: - 캘린더 Delegate extension BasicCalendarViewController: UICalendarViewDelegate, UICalendarSelectionSingleDateDelegate {          /// 날짜별 데코레이션 표시 커스텀(필요시 구현)     /// 선택된 날자의 셀에 이모지로 커스텀 데코레이션을 보여준다     func calendarView(_ calendarView: UICalendarView, decorationFor dateComponents: DateComponents) -&gt; UICalendarView.Decoration? {         if let selectedDate = selectedDate, selectedDate == dateComponents {             return .customView {                 let label = UILabel()                 label.text = \"🐶\"                 label.textAlignment = .center                 return label             }         }         return nil     }          /// 날짜 선택 시 동작     func dateSelection(_ selection: UICalendarSelectionSingleDate, didSelectDate dateComponents: DateComponents?) {         /// selection 객체에 저장         selection.setSelected(dateComponents, animated: true)         /// selectedDate 프로퍼티를 업데이트         selectedDate = dateComponents         /// 선택한 날짜 셀의 데코레이션만 새로고침(🐶 이모지가 바로 반영되게)         reloadDateView(date: Calendar.current.date(from: dateComponents!))     } }      참고: 한국어로 설정해도 시뮬레이터에서는 요일이 영어로 보이는 버그가 있다.   Reference      https://ohwhatisthis.tistory.com/23   https://maramincho.tistory.com/106   https://dongdida.tistory.com/128   https://velog.io/@xanxnu/iOSSwift-UICalendarView-사용해-보기  ","categories": [],
        "tags": ["CustomView"],
        "url": "/CustomView-CalendarView/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[CustomView] Segmented Control 기본",
        "excerpt":"    UIKit 세그먼 컨트롤 커스텀 사용법            import UIKit  final class SegmentControlVC: UIViewController {          // MARK: - UI Component     private lazy var segmentControl: UISegmentedControl = {         let segment = UISegmentedControl()         segment.insertSegment(withTitle: \"피드\", at: 0, animated: true)         segment.insertSegment(withTitle: \"캘린더\", at: 1, animated: true)         segment.selectedSegmentIndex = 0                  /// 탭의 글자 색상 및 폰트 커스텀 (일반/선택 상태별로 다르게)         segment.setTitleTextAttributes([             NSAttributedString.Key.foregroundColor: UIColor.systemGray2,             NSAttributedString.Key.font: UIFont.preferredFont(forTextStyle: .caption1)         ], for: .normal)         segment.setTitleTextAttributes([             NSAttributedString.Key.foregroundColor: UIColor.black,             NSAttributedString.Key.font: UIFont.preferredFont(forTextStyle: .caption1)         ], for: .selected)                  /// Segment 선택되었을 때 변하는 tintColor 제거         segment.selectedSegmentTintColor = .clear                  /// divider 제거         segment.setDividerImage(UIImage(), forLeftSegmentState: .normal, rightSegmentState: .normal, barMetrics: .default)                  /// 값이 변경될 때 underline 애니메이션을 위한 타겟 액션 등록         segment.addTarget(self, action: #selector(changeUnderLinePosition), for: .valueChanged)         return segment     }()          private let underLineView: UIView = {         let view = UIView()         view.backgroundColor = .black         return view     }()          override func viewDidLoad() {         super.viewDidLoad()                  makeUI()         constraints()     }          private func makeUI() {         view.backgroundColor = .white                  [segmentControl, underLineView].forEach {             view.addSubview($0)             $0.translatesAutoresizingMaskIntoConstraints = false         }                  // 세그먼트 회색 이미지를 흰색으로 설정         segmentControl.setBackgroundImage(imageWithColor(.white), for: .normal, barMetrics: .default)     }          private func constraints() {         NSLayoutConstraint.activate([             /// segmentControl: 화면 중앙, 가로 폭은 safeArea의 40%, 높이 20             segmentControl.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),             segmentControl.centerXAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerXAnchor),             segmentControl.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 0.4),             segmentControl.heightAnchor.constraint(equalToConstant: 20),                          /// underLineView: 세그먼트 하단에 배치, 가로폭은 세그먼트의 50% (즉, 한 탭과 크기 동일), 높이 2             underLineView.topAnchor.constraint(equalTo: segmentControl.bottomAnchor, constant: 10),             underLineView.leadingAnchor.constraint(equalTo: segmentControl.leadingAnchor),             underLineView.widthAnchor.constraint(equalTo: segmentControl.widthAnchor, multiplier: 0.5),             underLineView.heightAnchor.constraint(equalToConstant: 2)         ])     }          @objc     private func changeUnderLinePosition(_ segment: UISegmentedControl) {         let halfWidth = segmentControl.frame.width / 2         let xPosition = segmentControl.frame.origin.x + (halfWidth * CGFloat(segmentControl.selectedSegmentIndex))                          UIView.animate(withDuration: 0.2) {             self.underLineView.frame.origin.x = xPosition         }     } }  extension SegmentControlVC {     // 흰색 배경 이미지를 만들어주는 함수     /// 원하는 색의 1x32 사이즈 이미지를 만드는 함수 (세그먼트 배경 이미지용)     private func imageWithColor(_ color: UIColor, size: CGSize = CGSize(width: 1, height: 32)) -&gt; UIImage {         UIGraphicsBeginImageContextWithOptions(size, false, 0)         color.setFill()         UIRectFill(CGRect(origin: .zero, size: size))         let image = UIGraphicsGetImageFromCurrentImageContext() ?? UIImage()         UIGraphicsEndImageContext()         return image     } }  #Preview  {     SegmentControlVC() }   import UIKit  final class SegmentControlVC: UIViewController {          // MARK: - UI Component     private lazy var segmentControl: UISegmentedControl = {         let segment = UISegmentedControl()         segment.insertSegment(withTitle: \"피드\", at: 0, animated: true)         segment.insertSegment(withTitle: \"캘린더\", at: 1, animated: true)         segment.selectedSegmentIndex = 0                  /// 탭의 글자 색상 및 폰트 커스텀 (일반/선택 상태별로 다르게)         segment.setTitleTextAttributes([             NSAttributedString.Key.foregroundColor: UIColor.systemGray2,             NSAttributedString.Key.font: UIFont.preferredFont(forTextStyle: .caption1)         ], for: .normal)         segment.setTitleTextAttributes([             NSAttributedString.Key.foregroundColor: UIColor.black,             NSAttributedString.Key.font: UIFont.preferredFont(forTextStyle: .caption1)         ], for: .selected)                  /// Segment 선택되었을 때 변하는 tintColor 제거         segment.selectedSegmentTintColor = .clear                  /// divider 제거         segment.setDividerImage(UIImage(), forLeftSegmentState: .normal, rightSegmentState: .normal, barMetrics: .default)                  /// 값이 변경될 때 underline 애니메이션을 위한 타겟 액션 등록         segment.addTarget(self, action: #selector(changeUnderLinePosition), for: .valueChanged)         segment.addTarget(self, action: #selector(segmentChanged), for: .valueChanged)         return segment     }()          private let underLineView: UIView = {         let view = UIView()         view.backgroundColor = .black         return view     }()          private let aView: UIView = {         let view = UIView()         view.backgroundColor = .systemTeal         return view     }()          private let bView: UIView = {         let view = UIView()         view.backgroundColor = .systemYellow         return view     }()               // MARK: - LifeCycle     override func viewDidLoad() {         super.viewDidLoad()                  makeUI()         constraints()         updateViewForSelectedSegment()     }          private func makeUI() {         view.backgroundColor = .white                  [segmentControl, underLineView, aView, bView].forEach {             view.addSubview($0)             $0.translatesAutoresizingMaskIntoConstraints = false         }                  // 세그먼트 회색 이미지를 흰색으로 설정         segmentControl.setBackgroundImage(imageWithColor(.white), for: .normal, barMetrics: .default)     }          private func constraints() {         NSLayoutConstraint.activate([             /// segmentControl: 화면 중앙, 가로 폭은 safeArea의 40%, 높이 20             segmentControl.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),             segmentControl.centerXAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerXAnchor),             segmentControl.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 0.4),             segmentControl.heightAnchor.constraint(equalToConstant: 20),                          /// underLineView: 세그먼트 하단에 배치, 가로폭은 세그먼트의 50% (즉, 한 탭과 크기 동일), 높이 2             underLineView.topAnchor.constraint(equalTo: segmentControl.bottomAnchor, constant: 10),             underLineView.leadingAnchor.constraint(equalTo: segmentControl.leadingAnchor),             underLineView.widthAnchor.constraint(equalTo: segmentControl.widthAnchor, multiplier: 0.5),             underLineView.heightAnchor.constraint(equalToConstant: 2),                          // aView             aView.topAnchor.constraint(equalTo: underLineView.bottomAnchor, constant: 0),             aView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),             aView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),             aView.bottomAnchor.constraint(equalTo: view.bottomAnchor),                          // bView             bView.topAnchor.constraint(equalTo: underLineView.bottomAnchor, constant: 0),             bView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),             bView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),             bView.bottomAnchor.constraint(equalTo: view.bottomAnchor),                      ])     } }  extension SegmentControlVC {               /// 세그먼트 값 변경 시 언더라인(Indicator) 이동 애니메이션     @objc     private func changeUnderLinePosition(_ segment: UISegmentedControl) {         let halfWidth = segmentControl.frame.width / 2         let xPosition = segmentControl.frame.origin.x + (halfWidth * CGFloat(segmentControl.selectedSegmentIndex))                          UIView.animate(withDuration: 0.2) {             self.underLineView.frame.origin.x = xPosition         }     }          // 흰색 배경 이미지를 만들어주는 함수     /// 원하는 색의 1x32 사이즈 이미지를 만드는 함수 (세그먼트 배경 이미지용)     private func imageWithColor(_ color: UIColor, size: CGSize = CGSize(width: 1, height: 32)) -&gt; UIImage {         UIGraphicsBeginImageContextWithOptions(size, false, 0)         color.setFill()         UIRectFill(CGRect(origin: .zero, size: size))         let image = UIGraphicsGetImageFromCurrentImageContext() ?? UIImage()         UIGraphicsEndImageContext()         return image     }          // 세그먼트 탭 전환시 뷰 보이기 /숨기기     @objc private func segmentChanged(_ segment: UISegmentedControl) {         updateViewForSelectedSegment()     }          /// 현재 선택된 인덱스에 따라 aView/bView만 보이도록 처리     private func updateViewForSelectedSegment() {         aView.isHidden = segmentControl.selectedSegmentIndex != 0         bView.isHidden = segmentControl.selectedSegmentIndex != 1     } }  #Preview  {     SegmentControlVC() }   커스텀View  /// 상단 탭바+Indicator 커스텀 UIView (재사용 가능) final class SegmentedTabBarView: UIView {      // MARK: - Properties     private let segmentControl: UISegmentedControl          private let underlineView: UIView = {         let view = UIView()         view.backgroundColor = .mainWhite         return view     }()          private var underlineLeadingConstraint: NSLayoutConstraint!      // 선택된 인덱스 콜백     var onIndexChanged: ((Int) -&gt; Void)?      // MARK: - Init     init(items: [String]) {         self.segmentControl = UISegmentedControl(items: items)         super.init(frame: .zero)         makeUI()         constraints()         setSelected(index: 0, animated: false)     }     required init?(coder: NSCoder) { fatalError() }      // MARK: - UI     private func makeUI() {         // 커스텀 스타일         segmentControl.selectedSegmentIndex = 0                  // 미선택시         segmentControl.setTitleTextAttributes([             .foregroundColor: UIColor.systemGray2,             .font: UIFont.hcFont(.light, size: 20.scaled)         ], for: .normal)                  // 선택시         segmentControl.setTitleTextAttributes([             .foregroundColor: UIColor.mainWhite,             .font: UIFont.hcFont(.bold, size: 20.scaled)         ], for: .selected)                  segmentControl.selectedSegmentTintColor = .clear         segmentControl.setDividerImage(UIImage(), forLeftSegmentState: .normal, rightSegmentState: .normal, barMetrics: .default)         segmentControl.setBackgroundImage(imageWithColor(.mainBlack), for: .normal, barMetrics: .default)          segmentControl.addTarget(self, action: #selector(segmentChanged(_:)), for: .valueChanged)         addSubview(segmentControl)         addSubview(underlineView)     }      private func constraints() {         segmentControl.translatesAutoresizingMaskIntoConstraints = false         underlineView.translatesAutoresizingMaskIntoConstraints = false          NSLayoutConstraint.activate([             segmentControl.topAnchor.constraint(equalTo: topAnchor),             segmentControl.leadingAnchor.constraint(equalTo: leadingAnchor),             segmentControl.trailingAnchor.constraint(equalTo: trailingAnchor),             segmentControl.bottomAnchor.constraint(equalTo: bottomAnchor),              underlineView.topAnchor.constraint(equalTo: segmentControl.bottomAnchor, constant: 5),             underlineView.heightAnchor.constraint(equalToConstant: 2),             underlineView.widthAnchor.constraint(equalTo: segmentControl.widthAnchor, multiplier: 1 / CGFloat(segmentControl.numberOfSegments))         ])         // 밑줄의 leading 제약조건은 따로 저장해 이동시킨다         underlineLeadingConstraint = underlineView.leadingAnchor.constraint(equalTo: segmentControl.leadingAnchor)         underlineLeadingConstraint.isActive = true     }      // MARK: - Action     @objc private func segmentChanged(_ sender: UISegmentedControl) {         setSelected(index: sender.selectedSegmentIndex, animated: true)         onIndexChanged?(sender.selectedSegmentIndex)     }      // 인덱스 바꾸기 + 밑줄 이동     func setSelected(index: Int, animated: Bool) {         let segmentWidth = segmentControl.frame.width / CGFloat(segmentControl.numberOfSegments)         underlineLeadingConstraint.constant = segmentWidth * CGFloat(index)         if animated {             UIView.animate(withDuration: 0.2) { self.layoutIfNeeded() }         } else {             self.layoutIfNeeded()         }         segmentControl.selectedSegmentIndex = index     }      // 유틸: 흰색 배경 이미지 만들기     private func imageWithColor(_ color: UIColor, size: CGSize = CGSize(width: 1, height: 32)) -&gt; UIImage {         UIGraphicsBeginImageContextWithOptions(size, false, 0)         color.setFill()         UIRectFill(CGRect(origin: .zero, size: size))         let image = UIGraphicsGetImageFromCurrentImageContext() ?? UIImage()         UIGraphicsEndImageContext()         return image     } }  // SegmentedTabBarView.swift extension SegmentedTabBarView {     /// 원하는 segment의 title을 동적으로 변경     func setSegmentTitle(_ title: String, at index: Int) {         segmentControl.setTitle(title, forSegmentAt: index)     } }   Reference     https://chokotingchock.tistory.com/entry/스위프트-UIKit-custom-segmented-control   https://velog.io/@panther222128/UISegmentedControl-and-UITableView   https://ios-development.tistory.com/962  ","categories": [],
        "tags": ["CustomView"],
        "url": "/CustomView-Segmented-Control/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[CustomView] Segmented Control 커스텀 with PageViewController",
        "excerpt":"             UIKit 세그먼 컨트롤 커스텀 사용법   // //  CustomSegmentControlVC.swift //  UIComponentTutorial // //  Created by 김동현 on 6/2/25. //  import UIKit  final class CustomSegmentControl: UISegmentedControl {      // MARK: - UI     private let underlineView: UIView = {         let view = UIView()         view.backgroundColor = .black         return view     }()          private var underlineLeadingConstraint: NSLayoutConstraint!     private var underlineWidthConstraint: NSLayoutConstraint!     private let underlineHeight: CGFloat = 4.0 // 원하는 두께로 변경      override init(frame: CGRect) {         super.init(frame: frame)         setup()     }      override init(items: [Any]?) {         super.init(items: items)         setup()     }      required init?(coder: NSCoder) {         fatalError(\"init(coder:) has not been implemented\")     }      private func setup() {         self.removeBackgroundAndDivider()          underlineView.backgroundColor = .black         underlineView.translatesAutoresizingMaskIntoConstraints = false         underlineView.layer.cornerRadius = 0         addSubview(underlineView)                  NSLayoutConstraint.activate([                      ])                   // 초기 제약조건         let width = bounds.width &gt; 0 ? bounds.width / CGFloat(numberOfSegments) : 0         underlineLeadingConstraint = underlineView.leadingAnchor.constraint(equalTo: leadingAnchor)         underlineWidthConstraint = underlineView.widthAnchor.constraint(equalToConstant: width)          NSLayoutConstraint.activate([             underlineLeadingConstraint,             underlineWidthConstraint,             underlineView.bottomAnchor.constraint(equalTo: bottomAnchor),             underlineView.heightAnchor.constraint(equalToConstant: 20)         ])     }      override func layoutSubviews() {         super.layoutSubviews()         // 항상 최신 크기/위치 반영         updateUnderlinePosition(animated: false)     }      func updateUnderlinePosition(animated: Bool = true) {         let width = bounds.width / CGFloat(numberOfSegments)         let leading = CGFloat(selectedSegmentIndex) * width          underlineWidthConstraint.constant = width         underlineLeadingConstraint.constant = leading          if animated {             UIView.animate(withDuration: 0.15) {                 self.layoutIfNeeded()             }         } else {             self.layoutIfNeeded()         }     }      private func removeBackgroundAndDivider() {         let image = UIImage()         setBackgroundImage(image, for: .normal, barMetrics: .default)         setBackgroundImage(image, for: .selected, barMetrics: .default)         setBackgroundImage(image, for: .highlighted, barMetrics: .default)         setDividerImage(image, forLeftSegmentState: .selected, rightSegmentState: .normal, barMetrics: .default)     } }    final class CustomSegmentControlVC: UIViewController {      private let segmentedControl: UISegmentedControl = {         let segment = UISegmentedControl(items: [\"첫번째\", \"두번째\", \"세번째\"])         segment.translatesAutoresizingMaskIntoConstraints = false         segment.selectedSegmentIndex = 0         // 스타일 커스텀         segment.setTitleTextAttributes([             NSAttributedString.Key.foregroundColor: UIColor.gray         ], for: .normal)         segment.setTitleTextAttributes([             NSAttributedString.Key.foregroundColor: UIColor.invertedSystemBackground,             .font: UIFont.systemFont(ofSize: 15, weight: .bold)         ], for: .selected)         segment.selectedSegmentTintColor = .clear         let image = UIImage()         segment.setBackgroundImage(image, for: .normal, barMetrics: .default)         segment.setBackgroundImage(image, for: .selected, barMetrics: .default)         segment.setBackgroundImage(image, for: .highlighted, barMetrics: .default)         segment.setDividerImage(image, forLeftSegmentState: .selected, rightSegmentState: .normal, barMetrics: .default)         return segment     }()      private let underlineView: UIView = {         let view = UIView()         view.backgroundColor = .invertedSystemBackground         view.layer.cornerRadius = 0         return view     }()      private let vc1: UIViewController = {         let vc = UIViewController()         vc.view.backgroundColor = .red         return vc     }()     private let vc2: UIViewController = {         let vc = UIViewController()         vc.view.backgroundColor = .blue         return vc     }()     private let vc3: UIViewController = {         let vc = UIViewController()         vc.view.backgroundColor = .green         return vc     }()     var dataViewControllers: [UIViewController] { [vc1, vc2, vc3] }      private lazy var pageViewController: UIPageViewController = {         let vc = UIPageViewController(transitionStyle: .scroll, navigationOrientation: .horizontal)         vc.setViewControllers([self.dataViewControllers[0]], direction: .forward, animated: true)         vc.delegate = self         vc.dataSource = self         vc.view.translatesAutoresizingMaskIntoConstraints = false         return vc     }()      var currentPage: Int = 0 {         didSet {             let direction: UIPageViewController.NavigationDirection = oldValue &lt;= self.currentPage ? .forward : .reverse             self.pageViewController.setViewControllers(                 [dataViewControllers[self.currentPage]],                 direction: direction,                 animated: true,                 completion: nil             )             moveUnderline(animated: true)         }     }      override func viewDidLoad() {         super.viewDidLoad()         self.view.addSubview(self.segmentedControl)         self.view.addSubview(self.underlineView)         self.view.addSubview(self.pageViewController.view)          NSLayoutConstraint.activate([             segmentedControl.leadingAnchor.constraint(equalTo: view.leadingAnchor),             segmentedControl.trailingAnchor.constraint(equalTo: view.trailingAnchor),             segmentedControl.topAnchor.constraint(equalTo: view.topAnchor, constant: 80),             segmentedControl.heightAnchor.constraint(equalToConstant: 50),              pageViewController.view.leadingAnchor.constraint(equalTo: view.leadingAnchor),             pageViewController.view.trailingAnchor.constraint(equalTo: view.trailingAnchor),             pageViewController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor),             pageViewController.view.topAnchor.constraint(equalTo: segmentedControl.bottomAnchor),         ])          // 언더라인의 높이와 최초 위치 설정 (width, x는 viewDidLayoutSubviews에서)         underlineView.frame = CGRect(x: 0, y: 0, width: 0, height: 4)          segmentedControl.addTarget(self, action: #selector(changeValue(control:)), for: .valueChanged)         segmentedControl.selectedSegmentIndex = 0         changeValue(control: segmentedControl)     }      override func viewDidLayoutSubviews() {         super.viewDidLayoutSubviews()         // 최초 렌더링 시 언더라인 위치 정확히 세팅         moveUnderline(animated: false)         // 언더라인의 y위치를 세그먼트 하단에 맞추기         let segFrame = segmentedControl.frame         underlineView.frame.origin.y = segFrame.maxY - 4         underlineView.frame.size.height = 4     }      @objc private func changeValue(control: UISegmentedControl) {         self.currentPage = control.selectedSegmentIndex     }      /// 언더라인 이동 (frame 연산)     private func moveUnderline(animated: Bool) {         let segFrame = segmentedControl.frame         let segmentCount = CGFloat(segmentedControl.numberOfSegments)         let segmentWidth = segFrame.width / segmentCount         let targetX = segFrame.minX + segmentWidth * CGFloat(segmentedControl.selectedSegmentIndex)          let newFrame = CGRect(x: targetX,                               y: segFrame.maxY - 4,                               width: segmentWidth,                               height: 4)         if animated {             UIView.animate(withDuration: 0.2) {                 self.underlineView.frame = newFrame             }         } else {             self.underlineView.frame = newFrame         }     } }  extension CustomSegmentControlVC: UIPageViewControllerDataSource, UIPageViewControllerDelegate {     func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -&gt; UIViewController? {         guard let index = self.dataViewControllers.firstIndex(of: viewController), index - 1 &gt;= 0 else { return nil }         return self.dataViewControllers[index - 1]     }     func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -&gt; UIViewController? {         guard let index = self.dataViewControllers.firstIndex(of: viewController), index + 1 &lt; self.dataViewControllers.count else { return nil }         return self.dataViewControllers[index + 1]     }     func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {         guard let viewController = pageViewController.viewControllers?[0], let index = self.dataViewControllers.firstIndex(of: viewController) else { return }         self.currentPage = index         self.segmentedControl.selectedSegmentIndex = index         self.moveUnderline(animated: true)     } }  #Preview {     CustomSegmentControlVC() }  extension UIColor {     static var invertedSystemBackground: UIColor {         return UIColor { traitCollection in             switch traitCollection.userInterfaceStyle {             case .dark:                 // 다크 모드에서는 밝은 배경색                 return .white             default:                 // 라이트 모드에서는 어두운 배경색                 return .black             }         }     } }   ","categories": [],
        "tags": ["CustomView"],
        "url": "/CustomView-Segmented-Control2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "Star Bridge: 생일카페 알리미",
        "excerpt":"소개      서비스 설명: K-pop 팬들을 위한 생일카페 정보를 자동으로 수집하고, 알림으로 제공하는 스케줄 앱   프로젝트 유형: 팀 프로젝트 (졸업작품)   개발 기간: 24.03 ~ 24.12   Github 링크: https://github.com/indextrown/senior-project   기술 스택: SwiftUI, Selenium, AWS EC2, Firebase   기여한 부분     SNS 기반 생일카페 스케줄 자동화 시스템 설계 및 구현   도입 배경  Swift를 배우기 시작하던 시기에 졸업 프로젝트에 합류하게 되어 앱 UI 구현보다는 시스템 개발 파트에 더 집중할 수 있었습니다.    크롤링 → GPT로 데이터 정제 → API 연동으로 백엔드 중심의 구조를 직접 설계하며, 정보를 어떻게 모으고, 걸러내고, 사용자에게 전달할지를 하나의 흐름으로 구현해보는 데 초점을 맞췄습니다.   해결 방법          크롤링 자동화            로그인 및 차단 문제 해결을 위해, 수동 로그인 후 발급한 쿠키를 저장하고 이를 크롤링 시 재사용하여 안정성 확보.           GPT 기반 정보 정제            크롤링된 게시물에서 연예인 이름, 날짜, 장소를 GPT API로 추출.           Google Maps API 장소 검증            GPT가 추출한 장소를 지도 API로 확인, 유효하지 않은 데이터는 자동 제외.           실시간 앱 연동            1~3단계 결과를 AWS EC2 서버에서 30분 주기로 자동화.       정제된 데이터를 MySQL에 저장하고, SwiftUI 앱에서 실시간 조회 가능하게 구성.           성과      2024 한국멀티미디어학회 Best Paper 수상.   SNS 크롤링 → GPT 정제 → 장소 검증 → 앱 연동까지 자동화 파이프라인 완성.   데이터 정확도 98.0%, 알림 98.5% 달성.   Swift 학습 초기였지만, 앱과 서버를 연동하고 데이터 흐름을 설계하며 실질적인 서비스 구축 경험 쌓음.  ","categories": [],
        "tags": ["SwiftUI","Selenium","AWS EC2","Firebase"],
        "url": "/projects/star-bridge/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "반창고: 건강 관리 앱",
        "excerpt":"소개      서비스 설명: 주변 약국 위치를 지도에서 확인하고, 걸음 수와 칼로리를 기록·조회할 수 있는 건강 관리 앱   프로젝트 유형: 개인 프로젝트   개발 기간: 24.11 ~ 24.12   Github 링크: https://github.com/indextrown/Ban-Chang-Go   기술 스택: SwiftUI, MapKit, CoreLocation, CoreMotion, Firebase   기여한 부분     약국 운영 여부 포함 리스트 구성 (async / await 기반 연쇄 API 흐름 구조)   도입 배경     위치 기반 약국 API는 약국명과 위치만 제공하고 실제 운영 중인지 알 수 없었습니다.   반면 운영 여부 API는 약국 이름만 검색이 가능해 단독으로는 사용할 수 없었습니다.   사용자에게 실시간으로 문을 연 약국만 보여주기 위해 두 API의 흐름을 연결하는 구조가 필요했습니다.   해결 방법      위치 API로 받은 약국 리스트를 기준으로, 운영 여부 API를 순차 호출하는 구조 설계.   지도 이동 시 과도한 호출은 DispatchWorkItem과 Debounce로 조정.   이미 조회한 약국은 Set에 저장해 중복 호출 방지.   성과      운영 중인 약국은 빨간 핀, 종료 약국은 회색 핀으로 표시해 직관성 향상.   지도 이동 시 API 중복 호출을 차단해, 핀 렌더링 속도를 평균 1.2초 → 0.4초로 단축.  ","categories": [],
        "tags": ["SwiftUI","MapKit","CoreLocation","CoreMotion","Firebase"],
        "url": "/projects/banchanggo/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "코드라운지: 개발자 Q&A 학습 서비스",
        "excerpt":"소개      서비스 설명: CS, iOS 면접 질문과 답변을 마크다운 형식으로 정리하여 제공하는 학습용 서비스   프로젝트 유형: 개인 프로젝트   개발 기간: 24.11 ~ 25.01   Github 링크: https://github.com/team-GitDeulida/CodeLounge-iOS   기술 스택: SwiftUI, Combine, fastlane, Firebase   기여한 부분     SwiftUI 기반 마크다운 렌더링 직접 구현   도입 배경     코드라운지는 CS·iOS 면접 질문과 답변을 제공하는 학습 앱입니다.   SwiftUI 기본 Text 컴포넌트는 표현과 커스터마이징에 한계가 있어, 고급 마크다운 처리가 가능한 파서를 직접 구현하게 되었습니다.   해결 방법          대학에서 배운 프로그래밍언어 과목의 EBNF 문법과 Top-Down, 재귀 하강 파싱 개념을 앱에 적용.   전체 문서를 EBNF 기반으로 문법적으로 정의한 후, Heading, ListItem, Paragraph 등 Top Down 방식의 블록 단위 파싱을 구현.   줄 내에 있는 Bold, Underline 등은 재귀 하강 파싱으로 중첩 구조까지 분석.   파싱된 결과는 SwiftUI에서 Text, HStack, VStack 등으로 동적으로 렌더링.   성과      텍스트 강조, 코드블럭, 밑줄 표현이 가능한 마크다운 메서드 구현.   긴 텍스트를 가독성 높게 표현할 수 있게 됨.   다양한 기기에서도 일관된 텍스트 크기와 여백을 자동으로 조정하는 라이브러리 구현.   기능을 범용 라이브러리 형태로 분리하여 프로젝트 간 재사용이 가능하도록 모듈화.  ","categories": [],
        "tags": ["SwiftUI","Combine","fastlane","Firebase"],
        "url": "/projects/codelounge/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "음메요: 음성 메모 요약 서비스",
        "excerpt":"소개      서비스 설명: 음메요는 음성 메모 요약의 줄임말로, 음성 또는 텍스트를 메모로 남기면 GPT가 자동으로 핵심 내용을 요약해주는 메모 정리 알림 서비스입니다.   프로젝트 유형: 팀 프로젝트   개발 기간: 24.09 ~ 25.04   Github 링크: https://github.com/team-RETI/EUMMEYO   기술 스택: SwiftUI, Combine, OpenAI, MVVM + CleanArchitecture, Firebase   기여한 부분     GPT 기반 음성 감정 기록 및 요약 처리 시스템 구현 (Whisper API + GPT API 연계)   도입 배경     기존 메모 앱은 키보드 입력 중심이라 사용자의 기록 부담이 컸고, 음성 기록 기능이 있어도 단순 저장에 그치는 경우가 많았습니다.   음메요는 음성 또는 텍스트로 기록 → 핵심 요약 → 텍스트 저장으로 이어지는 연쇄적인 비동기 호출 구조가 요구되었습니다.   해결 방법      Whisper API로 음성을 한국어 텍스트로 변환.   변환된 텍스트를 GPT-4o mini API로 보내 감정 요약.   Swift Combine flatMap으로 연동, 오류는 enum 기반 에러로 세분화 처리.   성과      Whisper → GPT → 요약까지 이어지는 연쇄 비동기 흐름을 앱 내부에 안정적으로 구현.   음성 감정 기록을 자동 요약해 실제 사용자 최고 경험 향상.        클린 아키텍처로 프로젝트 구조 개선하기   도입 배경     초기에는 대부분의 기능을 하나의 ViewModel에 구현하고, 모든 파일을 단일 폴더에 구성하는 방식으로 개발을 진행했습니다. 하지만 음성 인식, GPT 요약, 메모 저장 등 기능이 점차 늘어나면서 ViewModel이 비대해졌고, 수정 시 다른 화면이나 컴포넌트까지 영향이 미치는 문제가 발생했습니다. 이러한 복잡도를 해소하고, 코드 간 경계를 명확히 구분하기 위해 MVVM + Clean Architecture 구조로 전환하게 되었습니다.   해결 방법      View → ViewModel → Service → Repository 계층 분리.   외부 의존성(Firebase, OpenAI 등)은 모두 Repository에서 관리하고, ViewModel은 비즈니스 로직에만 집중하도록 구조화.   DIP(의존성 역전 원칙)를 적용하여 인터페이스 기반 설계를 통해 각 계층 간 느슨한 결합을 유지.   성과      ViewModel 크기가 줄고, 각 기능이 책임 기반으로 분리되어 유지보수성과 확장성이 크게 향상.   구조가 명확해짐에 따라 신규 기능 추가나 다른 기능에 영향을 주지 않는 독립적인 개발 구조 확보.   팀 프로젝트에서 책임 구분이 명확해져 코드 리뷰와 협업 효율 증가.  ","categories": [],
        "tags": ["SwiftUI","Combine","OpenAI","MVVM + CleanArchitecture","Firebase"],
        "url": "/projects/eummeyo/",
        "teaser": "/assets/logos/background.png"
      }]
