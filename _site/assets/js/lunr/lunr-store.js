var store = [{
        "title": "[Combine] 개념 및 예제",
        "excerpt":"  Combine이란  2019년에 Apple에서 출시한 비동기처리 이벤트를 처리하기 위한 first-party 프레임워크이다.    Combine은 앱 내에서 일어나는 이벤트들의 진행 결과 등을 선언적으로 코딩할 수 있게끔 도와준다.    어떠한 이벤트를 추적할 떄 Delegate패턴을 사용하거나, Completion 클로저를 사용하는 대신 Combine을 활용해볼 수 있다.   Combine 주요 개념  Stream     데이터의 흐름이라고도 부르며 시간에 따라 순차적으로 전달되는 값들의 흐름이다   이 데이터는 비동기적으로 전달가능하다   전달 과정에서 변환, 필터링, 결합 등이 가능하다   Publisher     데이터를 만들어내고 이를 스트림 형태로 방출한다   값을 방출하거나 성공적으로 완료하거나 오류로 실패한다   Subscriber     Publisher로부터 완료 신호를 수신하는 역할을 한다   Publisher가 방출하는 값을 처리하고, 완료나 실패 이벤트를 받으면 스트림을 정리한다   Operator     Publisher가 생성하는 이벤트를 변환하거나 처리하는 데 사용된다   map, filter, reduce등의 연산자가 존재한다   연산자를 사용하면 복잡한 비동기 작업을 쉽게 구성할 수 있다   sink     Combine 퍼블리셔(Publisher)에서 방출된 데이터를 소비(consume)하기 위해 사용하는 구독자(Subscriber)이다   퍼블리셔가 내보내는 데이터를 받아서 처리하는 역할을 한다   sink를 호출하면 퍼블리셔를 구독한다   sink 메서드는 두 가지 클로저를 전달받는다   receiveCompletion: 스트림이 종료될 때(완료 또는 에러 발생 시) 호출되는 클로저   receiveValue: 스트림에서 방출된 값을 처리하는 클로저   receiveCompletion     sink 메서드의 첫번째 클로저   스트림이 종료(completion) 또는 에러 발생시 호출   두가지 상태를 처리한다   finished(스트림 정상 종료)   failure(스트림에서 에러가 발생하여 종료)   receiveValue     sink메서드의 두번째 클로저   퍼블리셔가 방출한 값을 받을 때 호출   여기서 값을 처리하거나 화면에 표시하는 등의 작업을 수행   .store(in: &amp;cancellables)     sink 연산자로 반환된 AnyCancellable 객체를 cancellables에 저장한다   스트림이 종료되거나 cancellables가 해제되면 자동으로 구독이 취소된다   cancellables:     Set 타입의 저장소이다   여기 저장된 AnyCancellable 객체는 구독이 유지되는 동안 메모리에서 해제되지 않도록 보장한다   스트림의 중요한 특징     시간 기반(스트림은 데이터가 시간에 따라 순차적으로 흘러가는 형태)   비동기 처리(스트림은 데이터가 준비될 때마다 이벤트 발생시키므로 비동기 작업과 어울림)   연속성(데이터가 중단되지 않고 계속 흐를 수도 있고, 완료(completion) 또는 에러(error)가 발생하여 종료될 수 있다   예제   예제 1) sink     AnyCancellable 객체를 반환한다   퍼블리셔와 구독자의 생명주기를 관리하는 데 사용된다   구독 취소 전까지 스트림이 유지된다   AnyCancellable을 저장하지 않으면 구독이 즉시 해제되어 데이터 스트림이 동작하지 않는다   // AnyCancellable을 저장할 곳 var cancellables = Set&lt;AnyCancellable&gt;()          // 퍼블리셔 let stream = [1, 2, 3].publisher  stream     .sink { completion in         print(\"스트림 완료: \\(completion)\")     } receiveValue: { value in         print(\"받은 값: \\(value)\")     }     // 구독 저장(반환된 AnyCancellable 저장)     .store(in: &amp;cancellables)  /* 받은 값: 1 받은 값: 2 받은 값: 3 스트림 완료: finished */  예제 2) Fail  // 커스텀 에러 타입 정의 enum MyError: Error {     case testError }  // AnyCancellable을 저장할 곳 var cancellables = Set&lt;AnyCancellable&gt;()  // 퍼블리셔 let publisher = Fail&lt;Int, MyError&gt;(error: .testError)  publisher     .sink { completion in         switch completion {         case .finished:             print(\"스트림 완료\")         case .failure(let error):             print(\"스트림 에러 (항상)발생: \\(error)\")         }     } receiveValue: { value in         print(\"받은 값: \\(value)\")     }     .store(in: &amp;cancellables)  // 스트림 에러 (항상)발생: testError   예제 3) Just     단 하나의 값을 방출하는 Publisher   값을 방출한 후 즉시 완료(finished)된다   실패하지 않는다(Failure 타입이 Never)   var cancellables = Set&lt;AnyCancellable&gt;()          let justPublisher = Just(100)  let subscription = justPublisher.sink { completion in     print(\"완료: \\(completion)\") } receiveValue: { value in     print(\"받은 값: \\(value)\") }  /* 받은 값: 100 완료: finished */   예제 4) Empty     값을 생성하지 않고 완료만 하는 Publisher   에러 없이(failure == Never) 종료한다   주로 기본값이 없거나, 특정 조건에서 Publisher를 반환해야 할 때 사용된다   var cancellables = Set&lt;AnyCancellable&gt;()          let emptyPublisher = Empty&lt;Int, Never&gt;()  emptyPublisher.sink { completion in     print(\"완료: \\(completion)\") } receiveValue: { value in     print(\"받은 값: \\(value)\") }.store(in: &amp;cancellables)  // 완료: finished  예제 5) Future     비동기 작업을 처리할 때 유용   ex) 네트워크 요청, 파일 읽기, 데이터베이스 작업   한번만 값을 방출(Just와 유사하지만 비동기적으로 동작)   성공(.success(value)) 또는 실패(.failure(error))로 완료됨   import Combine import SwiftUI  func fetchData() -&gt; Future&lt;String, Error&gt; {     return Future { promise in         DispatchQueue.global().asyncAfter(deadline: .now() + 2) {             // let success = Bool.random()             let success = false                          if success {                 promise(.success(\"데이터 가져오기 성공\"))             } else {                 promise(.failure(URLError(.badServerResponse)))             }         }     } }  // AnyCancellable을 저장할 곳 var cancellables = Set&lt;AnyCancellable&gt;()  let cancellable = fetchData()     .sink { completion in         switch completion {         case .finished:             print(\"스트림 완료\")         case .failure(let error):             print(\"에러 발생: \\(error)\")         }     } receiveValue: { value in         print(\"받은 값: \\(value)\")     }.store(in: &amp;cancellables)  // RunLoop를 사용해 비동기 작업 대기 RunLoop.main.run(until: Date(timeIntervalSinceNow: 5))   // 1. 구독 저장소 var cancellables = Set&lt;AnyCancellable&gt;()  // 2. 비동기 작업을 수행하는 Future Publisher 생성 let futurePublisher = Future&lt;Int, Error&gt; { promise in     DispatchQueue.global().asyncAfter(deadline: .now() + 1) {         let result = 42 // 비동기 작업 결과         promise(.success(result)) // 성공적으로 값을 방출     } }  // 3. 구독 시작 및 결과 처리 futurePublisher     .sink { completion in         switch completion {         case .finished:             print(\"스트림 완료\")         case .failure(let error):             print(\"에러 발생: \\(error.localizedDescription)\")         }     } receiveValue: { value in         print(\"받은 값: \\(value)\")     }     .store(in: &amp;cancellables) // 구독 유지  // RunLoop를 사용해 비동기 작업 대기 RunLoop.main.run(until: Date(timeIntervalSinceNow: 2))    ","categories": [],
        "tags": ["Combine"],
        "url": "/Combine-Framework/",
        "teaser": "/assets/img/Combine/Combine.png"
      },{
        "title": "[SwiftUI] 프로젝트에서 `UserDBRepository`, `UserService`, `ViewModel` 계층의 역할과 사용법",
        "excerpt":"1. SwiftUI 프로젝트에서 UserDBRepository, UserService, ViewModel 계층의 역할과 사용법   목차     UserDBRepository와 UserService의 개념 및 역할   계층을 나눈 이유   데이터 모델(User vs UserObject)의 차이점   비즈니스 로직 정의와 예시   Mermaid 다이어그램   코드 예시   UserDBRepository  UserDBRepository는 데이터베이스에 직접적으로 접근하는 계층이다.    Firebase Realtime Database와 같은 외부 데이터베이스와의 통신을 담당하며, 데이터 추가 ,조회, 업데이트, 삭제 등의 CRUD 작업을 제공한다   주요 역할     Firebase와의 직접 통신: Firebase 데이터베이스를 호출하여 데이터를 가져오거나 저장한다.   데이터 변환: 앱의 모델 데이터를 JSON 형식으로 변환하거나, 데이터베이스에서 가져온 데이터를 앱에서 사용할 수 있는 모델로 변환한다.   비동기 처리: Combine이나 async/await를 통해 비동기 작업을 처리한다   코드 예시  func getUser(userId: String) async throws -&gt; UserObject {     guard let value = try await self.db.child(DBKey.Users).child(userId).getData().value else {         throw DBError.emptyValue     }     let data = try JSONSerialization.data(withJSONObject: value)     return try JSONDecoder().decode(UserObject.self, from: data) }     UserService  UserService는 앱의 비즈니스 로직을 담당하며, 뷰모델(ViewModel)과 데이터베이스 리포지토리(Repository) 사이의 중간 계층 역할을 한다. UserDBRepository에서 데이터를 가져와 가공하거나, 데이터를 업데이트 하기 전에 추가적인 로직을 처리한다.   주요 역할     비즈니스 로직 처리: Repository에서 데이터를 가져온 후 추가적인 가공 또는 검증 로직을 수행한다.   모델 변환: 앱에서 사용하는 데이터 모델(User)와 데이터베이스 객체(UserObject)간의 변환을 수행한다.   의존성 주입: Repository를 주입받아 느슨한 결합(Lose Coupling)을 유지한다.   2. UserDBRepository, UserService 계층을 나눈 이유     책임 분리            UserDBRepository는 데이터베이스에 직접 통신하는 역할을, UserService는 비즈니스 로직 처리를 담당한다.       데이터베이스와 비즈니스 로직 간의 의존성을 줄여 각각 독립적으로 개발, 수정이 가능하다           테스트 용이성            UserService는 데이터베이스와 독립적으로 동작하므로, 단위 테스트에서 Mock이나 Stub을 사용해 테스트하기 용이하다.           유연성 확보            데이터베이스가 Firebase에서 다른 데이터베이스로 변경되더라도 UserDBRepository만 수정하면 된다.       UserService와 ViewModel은 변경에 영향을 받지 않는다.           3. 앱에서 사용하는 데이터 모델(User)과 데이터베이스 객체(UserObject)차이  UserObject:     데이터베이스와 직접적으로 관련된 구조이다. 데이터베이스에 저장하거나 가져오는 형태로 디자인되어있다.   데이터베이스와의 의존성이 있는 구조체로, 데이터 저장 형식(JSON, Dictionary등)에 최적화되어있다.   예를 들어 Firebase Realtime Database는 Json 기반으로 데이터를 저장하므로, UserObject는 이러한 데이터 포멧을 고려한 구조를 가진다.   ex) Double 타입으로 변환된 createdAt 값을 사용.   // 데이터베이스와 통신하기 위해 설계된 데이터 모델 // 데이터베이스(Firebase 등)의 JSON 형식에 맞게 데이터를 저장하거나 읽어오기 위해 존재 // 단순하고 직렬화 가능(Codable)하도록 설계  // -&gt; Codable 프로토콜을 사용해 JSON과 UserObject 간 변환을 쉽게 처리 struct UserObject: Codable {     var id: String     var name: String     var description: String     var createdAt: Double // Firebase timestamp }   User     앱 내부에서 사용되는 모델로, UI와 비즈니스 로직에 맞게 설계되어 있다.   데이터베이스와 무관하며, 앱의 화면 및 로직 처리에 필요한 형태와 속성을 가진다.   ex) Date 타입으로 변환된 createdAt 값을 사용.   // UserObject에는 없는 추가적인 계산이나 데이터를 포함할 수 있다 // ex) 사용자 이름을 \"Mr. DongHyeon Kim\"형태로 가공하여 표시 가능 struct User {     var id: String     var name: String     var description: String     var createdAt: Date // Swift의 Date 객체 }     차이점 요약     책임 분리            UserObject는 데이터베이스와 통신하며, User는 앱의 비즈니스 로직 및 UI에 사용된다.           유연성과 확장성            데이터베이스 변경 시 UserObject만 수정하면 되고, User는 변경되지 않는다.           타입 안정성            JSON 데이터를 다루는 UserObject는 Firebase와의 호환성을, User는 앱에서의 타입 안전성을 보장한다.             4. 비즈니스 로직 정의와 예시   비즈니스 로직이란?  비즈니스 로직은 소프트웨어에서 특정 도메인의 요구사항을 처리하기 위한 규칙, 절차, 계산, 데이터 처리 및 제약 조건을 정의하고 실행하는 코드이다.      역할:            단순 데이터 저장 및 읽기 이상의 추가 처리(가공, 검증 등)를 담당.       특정 도메인의 요구사항을 반영하여 데이터를 처리.             UserService에서의 비즈니스 로직 예시   예 1: 사용자 상태 메시지 검증  사용자가 상태 메시지를 입력할 때 길이가 140자를 초과하지 않도록 제한.  func validateStatusMessage(_ message: String) -&gt; Bool {     return message.count &lt;= 140 }   예 2: Firebase 시간 데이터를 로컬 시간으로 변환  Firebase에서 저장된 UTC 시간을 사용자의 로컬 시간으로 변환.  func convertToUserLocalTime(utcTimestamp: Double) -&gt; Date {     let date = Date(timeIntervalSince1970: utcTimestamp)     let userTimeZone = TimeZone.current     let secondsFromGMT = userTimeZone.secondsFromGMT(for: date)     return date.addingTimeInterval(Double(secondsFromGMT)) }   예 3: 데이터 업데이트 로직  상태 메시지를 업데이트하기 전에 비즈니스 검증 로직을 추가.  func updateDescription(userId: String, description: String) async throws {     guard validateStatusMessage(description) else {         throw ValidationError.invalidMessage     }     try await dbRepository.updateUser(userid: userId, key: \"description\", value: description) }     5. Mermaid 다이어그램  sequenceDiagram     participant View as MyProfileView     participant ViewModel as MyProfileViewModel     participant Service as UserService     participant Repository as UserDBRepository     participant Firebase as Firebase      View-&gt;&gt;ViewModel: .task { await getUser() }     ViewModel-&gt;&gt;Service: getUser(userId)     Service-&gt;&gt;Repository: getUser(userId)     Repository-&gt;&gt;Firebase: 데이터 조회     Firebase--&gt;&gt;Repository: UserObject     Repository--&gt;&gt;Service: UserObject 변환     Service--&gt;&gt;ViewModel: User     ViewModel--&gt;&gt;View: userInfo 업데이트   6. 코드 예시  데이터 모델 변환  extension UserObject {     func toModel() -&gt; User {         return User(             id: self.id,             name: self.name,             description: self.description,             createdAt: Date(timeIntervalSince1970: self.createdAt)         )     } }  extension User {     func toObject() -&gt; UserObject {         return UserObject(             id: self.id,             name: self.name,             description: self.description,             createdAt: self.createdAt.timeIntervalSince1970         )     } }     결론  UserDBRepository와 UserService는 데이터베이스와 비즈니스 로직을 명확히 분리하여 코드의 유지보수성과 확장성을 높인다.    비즈니스 로직은 데이터를 검증하거나 변환하여 UI와 사용자 경험의 품질을 보장한다.  ","categories": [""],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-UserDBRepository-,-UserService-,-ViewModel-%EA%B3%84%EC%B8%B5%EC%9D%98-%EC%97%AD%ED%95%A0%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[SwiftUI] Calendar 구현",
        "excerpt":"SwiftUI에서 제공하는 캘린더   SwiftUI에서 제공하는 DatePicker를 사용하여 간단한 캘린더를 구현할 수 있습니다.             import SwiftUI  struct ProfileView: View {     @State private var selectedDate = Date()          var body: some View {         VStack {             Text(\"선택한 날짜: \\(selectedDate, formatter: dateFormatter)\")                 .padding()                          DatePicker(                 \"Start Date\",                 selection: $selectedDate,                 displayedComponents: [.date]                    // 날짜만 표시 (시간은 제외)             )             .datePickerStyle(GraphicalDatePickerStyle())        // 그래픽 스타일             .environment(\\.locale, Locale(identifier: \"ko_KR\")) // 한국 로케일 설정                          Spacer()         }     }          // 날짜 형식을 지정하기 위한 Formatter    private var dateFormatter: DateFormatter {        let formatter = DateFormatter()        formatter.dateStyle = .medium        return formatter    } }  #Preview {     ProfileView() }                              위 코드와 이미지를 참고하여 SwiftUI에서 제공하는 DatePicker의 기본적인 사용법을 익혀보세요.   ","categories": [""],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-calendar/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[SwiftUI] Animation 구현",
        "excerpt":"SwiftUI에서 제공하는 애니메이션             import SwiftUI  // MARK: - 애니메이션 struct AnimationView: View {     @State var currentTab: Int  // 현재 선택된 탭의 인덱스          // MARK: - NAMESPACE     @Namespace var namespace          let text = [\"hello\", \"world\", \"my\", \"name\", \"is\", \"index\"]     var body: some View {         HStack(spacing: -50) {             ForEach(text.indices, id: \\.self) { index in                 let title = text[index]                 UnderBarItem(currentTab: $currentTab,                               title: title,                              tab: index,                              namespace: namespace                 )             }         }     } }  struct UnderBarItem: View {     @Binding var currentTab: Int    // 부모 뷰에서 전달받은 선택된 탭의 인덱스     var title: String     var tab: Int                    // 각 버튼이 고유하게 가지는 인덱스          // MARK: - NAMESPACE     let namespace: Namespace.ID          var body: some View {         Button {             currentTab = tab        // SwuftUI는 currentTab변경을 감지하여 뷰를 다시 렌더링 한다         } label: {             VStack {                 Text(title)                 if currentTab == tab {  // 터치된 버튼이면 언더바 표시                     Color.black                         .frame(height: 2)                         .padding(.horizontal, 30)                         // MARK: - NAMESPACE                         .matchedGeometryEffect(id: \"underline\", in: namespace.self)                 } else {                     Color.clear                         .frame(height: 2)                         .padding(.horizontal, 30)                 }             }             // response: 애니메이션의 지속 시간.             // dampingFraction: 감속의 강도 (0에 가까울수록 많이 진동).             // blendDuration: 애니메이션이 다른 변경 사항과 섞이는 데 걸리는 시간.             .animation(.spring(response: 0.5, dampingFraction: 0.7, blendDuration: 0.5), value: currentTab)             //.animation(.spring(), value: currentTab)    // value가 변할 때 애니메이션 적용         }     } }  #Preview {     AnimationView(currentTab: 0) }                               위 코드와 이미지를 참고하여 SwiftUI에서 제공하는 애니메이션의 기본적인 사용법을 익혀보세요.   ","categories": [""],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-Animation/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[SwiftUI] List + 기본 TextField 문제점",
        "excerpt":"📌 1. 기존 문제 원인 분석 (SwiftUI List + 기본 TextField)   ✅ 원인 1: SwiftUI TextField가 List와 충돌     List는 UIKit의 UITabView를 래핑한 SwiftUI 컴포넌트이다.   SwiftUI의 TextField는 입력시 상태 @Binding var text가 변경될 때마다 전체 List를 다시 그릴 수 있다.   이 과정에서 SwiftUI가 배경을 다시 렌더링하면서 검은색 잔상이 나타나게 된다.     ➡ 즉, List가 자동으로 다시 그려지면서 백그라운드 깜빡임이 발생한다       struct ErrorMainTabView: View {     @State var searchText: String     var body: some View {                  ZStack {             Color.mainBlack                 .ignoresSafeArea()                          VStack {                 TextField(\"검색\", text: $searchText)                     .padding()                     .background(Color.subBlack)                     .cornerRadius(10)                     .padding()                                  List {                     Section(header:                         Text(\"Numbers\")                         .foregroundColor(Color.mainGreen)                         .font(.system(size: 17, weight: .bold))                         .padding(.leading, -10)                     ) {                         ForEach(0...5, id: \\.self) { memo in                             Button {                                                              } label: {                                 Text(String(memo))                                     .foregroundColor(.white) // ✅ 텍스트 색상                                     .frame(maxWidth: .infinity, alignment: .leading) // ✅ 왼쪽 정렬                                                              }                             .listRowBackground(Color.subBlack) // ✅ 각 행의 배경색 지정                             .listRowSeparatorTint(Color.gray.opacity(0.4), edges: .bottom) // ✅ 구분선 색상 지정                         }                     }                 }                 .scrollContentBackground(.hidden) // ✅ 리스트 기본 배경 제거                 .background(Color.mainBlack) // ✅ 전체 리스트 배경 변경             }         }     } }   📌 2. 커스텀 UITextField를 사용했을 때 해결   ✅ 해결된 원인 1: UITextField는 List를 리렌더링하지 않음     UITextField는 UIKit 기반이므로, 입력 시 List를 다시 렌더링하지 않음.   SwiftUI의 TextField와 달리, @Binding 값이 바뀌어도 SwiftUI 전체 뷰를 다시 그리지 않음.   즉, UITextField를 사용하면서 List의 불필요한 리렌더링이 사라짐.     ➡ 커스텀 UITextField를 사용하면 SwiftUI의 TextField가 가지던 불필요한 리렌더링 문제를 방지할 수 있다.      struct CustomTextField: UIViewRepresentable {  @Binding var text: String  var placeholder: String  var horizontalPadding: CGFloat = 15 // ✅ 좌우 패딩 값을 하나의 변수로 추가   final class Coordinator: NSObject, UITextFieldDelegate {      var parent: CustomTextField       init(parent: CustomTextField) {          self.parent = parent      }       func textFieldDidChangeSelection(_ textField: UITextField) {          parent.text = textField.text ?? \"\"      }       func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {          textField.resignFirstResponder() // ✅ 엔터 누르면 키보드 닫기          return true      }  }   func makeCoordinator() -&gt; Coordinator {      return Coordinator(parent: self)  }   func makeUIView(context: Context) -&gt; UITextField {      let textField = UITextField()      textField.delegate = context.coordinator      textField.placeholder = placeholder      textField.backgroundColor = UIColor(Color.subBlack)      textField.layer.cornerRadius = 10      textField.textColor = .white      textField.returnKeyType = .done       // ✅ 좌측 패딩 추가      let leftPaddingView = UIView(frame: CGRect(x: 0, y: 0, width: horizontalPadding, height: textField.frame.height))      textField.leftView = leftPaddingView      textField.leftViewMode = .always       // ✅ 우측 패딩 추가      let rightPaddingView = UIView(frame: CGRect(x: 0, y: 0, width: horizontalPadding, height: textField.frame.height))      textField.rightView = rightPaddingView      textField.rightViewMode = .always       textField.addTarget(context.coordinator, action: #selector(Coordinator.textFieldDidChangeSelection(_:)), for: .editingChanged)      return textField  }   func updateUIView(_ uiView: UITextField, context: Context) {      uiView.text = text      uiView.placeholder = placeholder  }       // ✅ 외부 터치 시 키보드를 닫는 메서드 추가  static func hideKeyboard() {      UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)  } }          ","categories": [],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-List-+-%EA%B8%B0%EB%B3%B8-TextField-%EB%AC%B8%EC%A0%9C%EC%A0%90/",
        "teaser": "/assets/img/Swift/SwiftWhite.png"
      },{
        "title": "[SwiftUI] TabView",
        "excerpt":"기본 TabView     사용목적: 여러 개의 화면을 탭으로 관리할 수 있다.   제약사항: TabView에는 자체적으로 배경색을 변경할 수 있는 modifier가 없다.   UITabBar.appearance().backgroundColor = .white 같은 UIKit 코드를 사용해야 한다.   원하는 디자인을 만들기 위해 번거러운 작업이 필요하다.         import SwiftUI  struct ContentView: View {     @State private var selectedTab = 0      var body: some View {         TabView(selection: $selectedTab) {             Text(\"홈 화면\")                 .tabItem {                     Image(systemName: \"house.fill\")                     Text(\"홈\")                 }                 .tag(0)                  Text(\"검색 화면\")                 .tabItem {                     Image(systemName: \"magnifyingglass\")                     Text(\"검색\")                 }                 .tag(1)                  Text(\"설정 화면\")                 .tabItem {                     Image(systemName: \"gearshape.fill\")                     Text(\"설정\")                 }                 .tag(2)         }     } }                   커스텀 탭뷰   커스텁 탭뷰 타입  enum MainTabType: CaseIterable {     case csView     case iosView     case aosView     case profileView          var title: String {         switch self {         case .csView:             return \"CS\"         case .iosView:             return \"iOS\"         case .aosView:             return \"aOS\"         case .profileView:             return \"profile\"         }     }          func imageName(isSelected: Bool) -&gt; String {         switch self {         case .csView:             return isSelected ? \"desktopcomputer\" : \"desktopcomputer\"         case .iosView:             return isSelected ? \"apple.logo\" : \"apple.logo\"         case .aosView:             return isSelected ? \"smartphone\" : \"smartphone\"         case .profileView:             return isSelected ? \"person.fill\" : \"person\"         }     } }  커스텀 탭뷰  struct CustomMaintabView: View {          @State private var selectedTab: MainTabType = .csView          var body: some View {         ZStack {             Color.black                          VStack(spacing: 0) {                 switch selectedTab {                 case .csView:                     CSView()                 case .iosView:                     iOSView()                 case .aosView:                     AosView()                 case .profileView:                     ProfileView()                 }             }              VStack(spacing: 0) {                 Spacer()                                  Rectangle()                     .fill(Color.gray.opacity(0.3))                     .frame(height: 1)                                  HStack {                     ForEach(MainTabType.allCases, id: \\.self) { tab in                                                  Spacer()                             .frame(width: 10)                                                  VStack {                             Spacer()                                 .frame(height: 5)                             Image(systemName: tab.imageName(isSelected: selectedTab == tab))                                 .font(.system(size: 24))                                 .foregroundColor(selectedTab == tab ? .white : .gray)                             Text(tab.title)                                 .font(.caption2)                                 .foregroundColor(selectedTab == tab ? .white : .gray)                             Spacer()                                 .frame(height: 20)                         }                         .padding(.horizontal, 20) // 좌우 터치 영역 추가                         .frame(maxWidth: .infinity)                         .contentShape(Rectangle()) // 터치 가능한 영역을 명시적으로 지정                         .onTapGesture {                             // 진동 발생                             let generator = UIImpactFeedbackGenerator(style: .medium)                             generator.impactOccurred()                             selectedTab = tab                         }                         Spacer()                             .frame(width: 10)                     }                     .frame(height: 100) // 고정 높이                 }                 .background(.black)             }         }         .ignoresSafeArea(edges: .all)     } }  ","categories": [],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-TabView/",
        "teaser": "/assets/img/Swift/SwiftWhite.png"
      },{
        "title": "[Firebase] cloud functions",
        "excerpt":"Cloud Functions     Cloud Functions는 Firebase의 기능과 HTTP 요청에 의해서 Trigger 되는 이벤트에 응답하여 백엔드 코드를 자동으로 실행시켜주는 서버리스 프레임워크   ✅ 1. Firebase Cloud Functions 설정     먼저 Firebase CLI를 설치하고 프로젝트에 Cloud Functions를 추가   # Firebase CLI 설치 (설치 안 되어 있다면) brew install firebase-cli  # 설치가 끝나면 아래 명령어로 정상적으로 설치되었는지 확인 firebase --version  # Firebase 로그인 firebase login  # Firebase Functions 초기화 firebase init functions  # 환경변수 추가 (필요할 경우) echo 'export PATH=\"/opt/homebrew/bin:$PATH\"' &gt;&gt; ~/.zshrc source ~/.zshrc   ✅ 2. (Gmail + Nodemailer 사용)     Google 앱 비밀번호에서 비밀번호를 생성   Gmail -&gt; 설정 -&gt; 전달 및 POP/IMAP -&gt; IMAP 사용   ✅ 3. Cloud Functions 코드 작성 (index.js)     Gmail + Nodemailer를 활용   ✅ 닉네임이 처음 생성될 때만 이메일 전송 + 구글 시트 추가   ✅ 닉네임이 변경되거나 다른 정보가 변경될 경우, 이메일 없이 시트만 업데이트   ✅ 유저가 삭제되면 ‘탈퇴’로 표시   const { onValueUpdated, onValueDeleted } = require(\"firebase-functions/v2/database\"); const admin = require(\"firebase-admin\"); const { google } = require(\"googleapis\"); const nodemailer = require(\"nodemailer\");  admin.initializeApp();  // ✅ Gmail 설정 (앱 비밀번호 사용) const GMAIL_EMAIL = \"indextrown@gmail.com\"; const GMAIL_PASSWORD = \"\";  // ✅ Nodemailer 설정 const transporter = nodemailer.createTransport({     host: \"smtp.gmail.com\",     port: 465,     secure: true,     auth: {         user: GMAIL_EMAIL,         pass: GMAIL_PASSWORD     },     tls: {         rejectUnauthorized: false     } });  // ✅ Google Sheets API 설정 const SHEET_ID = \"\"; const SCOPES = [\"https://www.googleapis.com/auth/spreadsheets\"]; const keyFilePath = \"/workspace/codeloungeusers-a47a950f7b06.json\";  async function getGoogleSheetsClient() {     const auth = new google.auth.GoogleAuth({         keyFile: keyFilePath,         scopes: SCOPES     });     return google.sheets({ version: \"v4\", auth }); }  // ✅ 유저 정보를 구글 시트에 업데이트 (닉네임 변경 시 이메일 전송 X) async function updateUserInGoogleSheet(userData) {     try {         const sheets = await getGoogleSheetsClient();                  const readRes = await sheets.spreadsheets.values.get({             spreadsheetId: SHEET_ID,             range: \"Users!A:G\"         });          let values = readRes.data.values || [];         let userRowIndex = values.findIndex(row =&gt; row[1] === userData.id);          if (userRowIndex !== -1) {             // ✅ 기존 행 업데이트             values[userRowIndex] = [                 userData.nickname,                 userData.id,                 userData.loginPlatform,                 userData.gender,                 userData.birthdayDate,                 userData.registerDate,                 \"\" // 탈퇴 여부 비움             ];              await sheets.spreadsheets.values.update({                 spreadsheetId: SHEET_ID,                 range: `Users!A${userRowIndex + 1}:G${userRowIndex + 1}`,                 valueInputOption: \"RAW\",                 resource: { values: [values[userRowIndex]] }             });             console.log(`✅ 구글 시트 업데이트 완료: ${userData.id}`);         } else {             console.log(`⚠️ 업데이트할 유저를 찾을 수 없음: ${userData.id}`);         }     } catch (error) {         console.error(\"❌ 구글 시트 업데이트 오류:\", error);     } }  // ✅ 유저가 처음 닉네임을 설정할 때 이메일 전송 &amp; 시트에 추가 async function addUserToGoogleSheet(userData) {     try {         const sheets = await getGoogleSheetsClient();          await sheets.spreadsheets.values.append({             spreadsheetId: SHEET_ID,             range: \"Users!A:G\",             valueInputOption: \"RAW\",             resource: { values: [[                 userData.nickname,                 userData.id,                 userData.loginPlatform,                 userData.gender,                 userData.birthdayDate,                 userData.registerDate,                 \"\" // 신규 가입이므로 탈퇴 X             ]] }         });         console.log(`✅ 새로운 유저 추가: ${userData.id}`);          // ✅ 관리자에게 이메일 전송         const mailOptions = {             from: GMAIL_EMAIL,             to: \"indextrown@gmail.com\",             subject: \"[코드라운지] 새 사용자가 가입했습니다.\",             text: `📢 새 사용자 정보: 닉네임: ${userData.nickname} ID: ${userData.id} 플랫폼: ${userData.loginPlatform} 성별: ${userData.gender} 생일: ${userData.birthdayDate} 가입 날짜: ${userData.registerDate}`         };          await transporter.sendMail(mailOptions);         console.log(\"✅ 관리자에게 메일 전송 성공!\");     } catch (error) {         console.error(\"❌ 유저 추가 오류:\", error);     } }  // ✅ 유저 삭제 감지 → 구글 시트에서 \"탈퇴\"로 표시 async function markUserAsDeleted(userId) {     try {         const sheets = await getGoogleSheetsClient();                  const readRes = await sheets.spreadsheets.values.get({             spreadsheetId: SHEET_ID,             range: \"Users!A:G\"         });          let values = readRes.data.values || [];         let userRowIndex = values.findIndex(row =&gt; row[1] === userId);          if (userRowIndex !== -1) {             values[userRowIndex][6] = \"탈퇴\";               await sheets.spreadsheets.values.update({                 spreadsheetId: SHEET_ID,                 range: `Users!A${userRowIndex + 1}:G${userRowIndex + 1}`,                 valueInputOption: \"RAW\",                 resource: { values: [values[userRowIndex]] }             });             console.log(`🚨 유저 삭제 감지 - 탈퇴 처리 완료: ${userId}`);         } else {             console.log(`⚠️ 삭제된 유저를 찾을 수 없음: ${userId}`);         }     } catch (error) {         console.error(\"❌ 구글 시트 탈퇴 처리 오류:\", error);     } }  // ✅ 닉네임이 처음 생성될 때만 이메일 전송 &amp; 시트 추가 exports.addNewUser = onValueUpdated(\"/Users/{userId}\", async (event) =&gt; {     const beforeData = event.data.before.val();     const afterData = event.data.after.val();      if (!afterData) return console.error(\"❌ 오류: 데이터 없음\");      // ✅ 닉네임이 처음 설정될 때만 이메일 발송     if ((!beforeData || !beforeData.nickname) &amp;&amp; afterData.nickname) {         console.log(`📢 새로운 닉네임 생성 감지: ${afterData.nickname}`);         await addUserToGoogleSheet(afterData);     } else {         console.log(`ℹ️ 기존 유저 정보 업데이트 감지: ${afterData.id}`);         await updateUserInGoogleSheet(afterData);     } });  // ✅ 유저 삭제 감지 (삭제되면 \"탈퇴\"로 업데이트) exports.markUserDeletedInSheet = onValueDeleted(\"/Users/{userId}\", async (event) =&gt; {     const userId = event.params.userId;     console.log(`🚨 유저 삭제 감지: ${userId}`);      await markUserAsDeleted(userId); });   ✅ 4. 버전 문제 해결     firebase –version   npm list firebase-functions   functions@ /Users/kimdonghyeon/functions └── firebase-functions@4.3.0 // firebase-functions@4.3.0이면 2nd Gen (v4.x) 사용 중 // firebase-functions@3.26.0이면 1st Gen (v3.x) 사용 중   ✅ 5. 구글 스프레드 시트  5-1     googleapis 모듈 설치 필요   # nvm을 사용하여 Node.js 22로 변경 brew install nvm  # 터미널 재시작 후 Node.js 22 설치 nvm install 22  # Node.js 22로 버전 변경 nvm use 22  # 현재 버전 확인 node -v  # googleapis 설치 npm install googleapis   📌 Firebase 환경 변수에 JSON 키 저장  firebase functions:config:set google_sheets.service_account_json=\"$(cat service-account.json)\"     ⚠️ Firebase 환경 변수 업데이트 후 Functions를 다시 배포해야 함     firebase deploy --only functions           📌 설정이 정상적으로 저장되었는지 확인하는 방법:     firebase functions:config:get           ✅ 6. 구글 시트 연동 및 api(json)발급은 아래 링크 참고     https://velog.io/@junsugi/Google-Sheet-연동하기-feat.-Google-API  ","categories": [],
        "tags": ["Firebase"],
        "url": "/Firebase-Cloud-Function/",
        "teaser": "/assets/img/Swift/SwiftWhite.png"
      },{
        "title": "[알고리즘] 그래프 이론",
        "excerpt":"정점과 간선   정점(Vertex)      노드라고 불리며 그래프를 형성하는 기본 단위다.   분할할 수 없는 객체이자 점으로 표현되는 위치, 사람, 물건 등이 될 수 있다.   간선(Edge)      정점을 잇는 선을 의미한다.   관계 경로 등이 될 수 있다.   예시      “어떠한 위치나 어떠한 사람(정점)” 으로부터 “무언가를 통해(간선)“간다.   Index(정점)가 길(간선)을 걸어 아파트로(정점) 간다   단방향 간선      남자가 여자를 좋아한다. 여자는 남자를 좋아하지 않는다.(짝사랑)   양방향 간선      남자와 여자가 서로 좋아한다.   그래프 이론에서 일반적으로 사용되는 기호      u - 시작점(from)   v - 도착점(to)   indegree &amp; outdegree           U에서 V로 가는 경로가 3가지가 있을 때 표현 방법  -&gt; u의 outdegree(나가는 간선) = 3개            V에서 U로 가는 경로가 7가지 있을 때 표현 방법  -&gt; u의 indegree(들어오는  간선) = 7개       가중치      정점과 정점 사이에 드는 비용을 의미한다   1번노드에서 2번노드까지 가는 비용이 한칸이면 가중치는 한칸이다.   그래프      정점과 간선으로 이루어진 집합이다.   트리      자식노드와 부모노드로 이루어진 계층적인 구조를 가지며 무방향 그래프의 일종이자 사이클이 없는 자료구조를 의미한다.   트리의 특징      부모, 자식 계층구조를 가진다. 같은 경로 상에서 어떤 노드보다 위에 있으면 부모, 아래에 있으면 자식 노드가 된다.   E = V - 1 이다. 간선수 = 노드수 - 1   임의의 두 노드 사이의 경로는 반드시 있으며 하나밖에 없다.  ","categories": [],
        "tags": ["Algorithm"],
        "url": "/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%B4%EB%A1%A0/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[알고리즘] 깊이우선탐색(DFS)",
        "excerpt":"깊이우선탐색(Depth First Search)  그래프를 탐색할 때 쓰는 알고리즘으로 어떤 노드부터 시작해 인접한 노드들을 재귀적으로 방문하며 방문한 정점은 다시 반복하지 않고 각 분기마다 가능한 가장 멀리 있는 노드까지 탐색하는 알고리즘이다.   DFS PseudoCode  DFS(u, adj)     u.visited = true     for each v ∈ adj[u]         if v.visited == false             DFS(v, adj)     어떠한 정점 U의 visited를 참으로 바꾸고 연결되어있는 V지점을 탐색한다.   이 때 방문되지 않은 노드에 대해 재귀적으로 DFS를 호출한다.   DFS 탐색 예제   graph TD;     1((1)) --&gt; 2((2));     2((2)) --&gt; 4((4));     1((1)) --&gt; 3((3));     2((2)) --&gt; 5((5));     4((4)) --&gt; 2((2));  style 1 stroke:#333,stroke-width:3px,font-size:30px style 2 stroke:#333,stroke-width:3px,font-size:30px style 3 stroke:#333,stroke-width:3px,font-size:30px style 4 stroke:#333,stroke-width:3px,font-size:30px style 5 stroke:#333,stroke-width:3px,font-size:30px     1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3   let n: Int = 6 var adj: [[Int]] = Array(repeating: [Int](), count: n) var visited: [Bool] = Array(repeating: false, count: n)  func dfs(_ here: Int) {     visited[here] = true     print(here, terminator: \" \")          for there in adj[here] {         if visited[there] { continue }         dfs(there)     } }  @main struct Main {     static func main() {         adj[1].append(2)         adj[1].append(3)         adj[2].append(4)         adj[4].append(2)         adj[2].append(5)         dfs(1)     } }  // 결과: 1 2 3 4 5 3  ","categories": [],
        "tags": ["Algorithm"],
        "url": "/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B9%8A%EC%9D%B4%EC%9A%B0%EC%84%A0%ED%83%90%EC%83%89(DFS)/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Blog] 깃블로그 이미지 편하게 작성하는법",
        "excerpt":"깃블로그 이미지 편하게 작성하는법           Typora 다운            실행 후 좌측 상단바 Typora -&gt; 설정 -&gt; 이미지 -&gt; 사용자 정의 폴더로 이미지복사            ../assets/img/${filename} 지정            가능하다면 상대적 위치 사용 체크            post 상단에 typora-root-url: ../ 추가          ","categories": [],
        "tags": ["Blog"],
        "url": "/Blog-%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%8E%B8%ED%95%98%EA%B2%8C-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94%EB%B2%95/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[SwiftUI] 이미지 캐시 구현",
        "excerpt":"iOS file System      sandbox   iOS는 보안을 위해 앱 설치시 os내부 설치 프로그램이 그 앱에 자체 독립 공간(sandbox)을 생성한다.  (sandbox) 내부에는 각 역할을 가진 컨테이너 디렉터리들이 생성된다. 즉 각 iOS App은 자체 독립돈 공간 (sandbox)를 가지고 이 공간에서 앱 data와 파일을 관리하고, 다른 App에서 Access 하지 못하도록 보장한다. 각 App의 file, data는 App의 Container 내에서만 Access 가능한다. 또한 iOS는 특정 메커니즘을 사용해 앱 사이의 통신을 지원하며, 제한된 방식으로 상호작용 할 수 있다.(ex: url Scheme)  또한 root 권한이 없는 상태에서 App이 실행되므로 보안을 높이는 역할을 하고, 사용자에게 권한 요청을 통해(연락처 요청..) 승인이 안될 시 해당 기능을 사용할 수 없다.   특징      앱 격리   파일 시스템 제한   앱 간 통신   보안성   권한 관리   Bundle Container   앱의 번들을 소유하고 있다. 앱과 앱을 실핼할 수 있는 이미지, icon, storyboard등 리소스들이 모두 포함되어 있다. 이 폴더는 읽기 전용이라 쓰기가 불가능하며 변조 방지를 위해 이 디렉토리는 설치 시 서명된다.   Data Contaier   App과 사용자를 위한 데이터를 담고 있다.      Cache   기기 안에 자주 사용되는 데이터나 값을 미리 저장하여, 빠르게 접근 가능한 임시 저장소다. 네트워크를 통해 이미지를 받고 뷰를 그리고, 갱신이 된다면 네트워크를 통해 다시 불필요한 리소스를 사용하게 되는데 이러한 자원 낭비를 해결하기 위해 이미지 캐시는 앱개발에서 필수적이다.   이미지 캐시 구현      url을 통해 이미지를 받아오면 이미지를 캐시로 저장하여 view를 다시 그릴 때 네트워크를 통해 이미지 데이터를 불러올 필요 없도록 개발 진행.   Memory storage와 Disk storage를 생성  -&gt; Memory storage(NSCache): iOS에서 지원해주는 캐시, key, value 쌍을 저장,  기기 전원을 종료하면 사라진다.   Disk Storage  -&gt; Cache Directory로 폴더를 만들어서 사용.   플로우      Memory storage(NSCache)에 해당 이미지가 존재하는지 확인 후 없으면 Disk Storage에 해당 경로에 이미지가 있는지 체크를 한 후 네트워크 통신을 하여 가져오고, 각 Storage에 저장한다.   ","categories": [],
        "tags": ["SwiftUI"],
        "url": "/SwiftUI-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%BA%90%EC%8B%9C-%EA%B5%AC%ED%98%84/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] Swift 비동기 처리방식",
        "excerpt":"📝 Swift 비동기 처리방식   1. NSThread      Object-C 시절부터 사용되었다   직접 스레드를 셍성하고 괸리해야 한다.   수동으로 동기화 해야하다.   GCD나 OperationQueue에 비해 사용성이 떨어진다.        ❌ 현재 사용 여부: 현재 거의 사용되지 않는다.       let thread = Thread {     print(\"Background 작업 실행\") }    thread.start()           2. OperationQueue (iOS 2.0/2008)      GCD보다 객체 지향적이고 세밀한 제어 가능하다.   여러 작업을 동시에 실행 가능하다.   의존성(Dependency) 설절 가능하다.        ✅ 현재 사용 여부: 여러 작업 간 의존성이 있는 경우 사용된다.       let queue = OperationQueue() let operation = BlockOperation {     print(\"Background 작업 실행\") } queue.addOperation(operation)           3. GCD(Grand Central Dispatch) (iOS 4.0/2010)      백그라운드 실행이 간편하다.   성능 최적화된 C 기반 API이다.   메인 스레드에서 UI 업데이트 가능하다.        ✅ 현재 사용 여부: 많이 사용된다. (백그라운드 처리, UI 업데이트)       DispatchQueue.gloal(qos: .background).async {     // Background 작업 실행     let result = heavyTask()           DispatchQueue.main.async {         updateUI(with: result)     } }           4. RxSwift (ReactiveX)      오픈소스 라이브러리이다.   리액티브 프로그래밍을 위한 강력한 프레임워크다.   비동기 데이터 스트림을 선언적으로 처리 가능하다.   Obserable과 Observer 패턴 사용한다.        ✅ 현재 사용 여부: 많이 사용된다. (MVVM 아키텍쳐에서 활용됨)       import RxSwift    let disposeBag = DisposeBag() let observable = Observable.just(\"Background 작업 실행\")    observable.subscribe(onNext: { value in     print(value) }).disposed(by: disposeBag)           5. Combine (iOS 13.0/2019)      리액티브 프로그래밍 프레임워크이다.   데이터 스트림을 다룰 때 유용하다.   Publisher와 Subscriber 패턴을 사용한다.        ✅ 현재 사용 여부: 특정 상황에서 사용된다. (API 응답, 데이터 스트림 처리 등)       import Combine    let publisher = Just(\"Background 작업 실행\") let cancellable = publisher.sink { value in     print(value)                                 }           6. Async/await (Switt Concurrency) (iOS 15.0/2021/Swift5.5)      가독성이 뛰어난 최신 비동기 처리 방식이다.   동기 코드처럼 작성 가능하다   Task를 활용해 SwiftUI에서도 사용 가능하다.   ✅ 현재 사용 여부: 가장 추천되는 방식이다. (Swift 5.5+ 환경에서 최적의 선택)     func fetchData() async -&gt; String {     // Background 작업 실행     try await Task.sleep(nanoseconds: 1_000_000_000) // 1초 대기     return \"Fetched Data\" }  Task {     let data = await fetchData()     print(data) }           ✅ 정리 (비동기 처리 방식 비교)                  도입 순서       비동기 방식       특징       현재 사용 여부                       1       NSThread       직접 스레드 관리, 수동 동기화 필요       거의 안 씀 ❌                 2       OperationQueue       객체 지향적, 작업 의존성 설정 가능       사용됨 ✅                 3       GCD (DispatchQueue)       백그라운드 처리, UI 업데이트 가능       많이 사용됨 ✅                 4       RxSwift       리액티브 프로그래밍, Observable 활용       많이 사용됨 ✅                 5       Combine       데이터 스트림을 다루는 리액티브 프로그래밍       특정 상황에서 사용됨 ✅                 6       async/await       최신 Swift 비동기 처리 방식, 가독성이 좋음       가장 추천됨 🚀✅          ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-01-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%8B%9D/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 변수와 상수 그리고 타입",
        "excerpt":"1. 변수(Variable) var          데이터를 담을 수 있는 공간름            프로그래밍 동작의 첫번째 단계: 변수 선언       // 변수를 선언하면서 저장 // 3이라는 숫자를 a라는 공간에 저장한다 var a = 3\t var b = 7    // 변수를 여러개 한꺼번에 선언 var x = 1, y = 2, z = 3    // 새로운 공간을 만들고 값을 복사(Copy)해서 저장 var newSpace = a           String Interpolation (문자열 보간법)           변수를 문자열 안에서 출력방법       // \\(변수이름)    var name = \"Index\" print(\"Hello \\(name)\")           2. 상수(constants) let           변하지 않는 데이터를 담을 수 있는 공간            식별자(한 영역에 유일한 이름만 사용): 상수의 이름       let name = \"Index\" print(\"Hello \\(name)\")           3. 타입(Type)   Swift 기본 타입                  타입(키워드 = 약속어)       내용       예시                       Int       정수(8바이트)       1, 2, 3                 Float       부동소수(4바이트), 6자리       3.14                 Double       부동소수(8바이트), 15자리       3.14                 Character       문자       “I”                 String       문자열       “Hello Index”                 Bool       참/거짓       true, false                 기타       UInt                   Swift 변수 특징                  종류       설명       예시                       타입 주석 (Type annotation)       변수를 선언하면서 타입을 명시적으로 선언하는 방법.       var name: String = “Index”                 타입 추론       데이터 타입을 명시하지 않아도 컴파일러가 타입을 유추해서 알맞는 타입으로 저장하는 방법.       var name = “Index”                 타입 안전성       어떤 변수가 특정 타입으로 선언되면 그 변수에는 해당 타입만 담을 수 있다.       var number = 1  number=3.14(❌ 컴파일 에러)           ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-01-%EB%B3%80%EC%88%98%EC%99%80-%EC%83%81%EC%88%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%ED%83%80%EC%9E%85/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 기본 연산자",
        "excerpt":"1. 기본 연산자  ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-02-%EA%B8%B0%EB%B3%B8-%EC%97%B0%EC%82%B0%EC%9E%90/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 프로그래밍 기본 원리와 조건문",
        "excerpt":"1. 프로그래밍 기본 원리      순차   조건   반복   순차           개발자가 정한 규칙으로 실행한다.       print(\"1\") print(\"2\") print(\"3\")           조건(if)           조건이 참이면 {}를 실행하고 거짓이면 아무 직업도 하지 않는다.            참과 거짓을 판단할 수 있는 문장을 조건이라고 부르고, 조건을 콤마로 여러개 연결 가능하다(and연산자이다).            ⚠️ if문에서 ,(콤마)는 and 역할이다.       if 참과 거짓을 판단할 수 있는 문장 {    }       조건(switch)      if문보다 한정적인 상황에서 사용한다.   각각의 case 에 break을 사용할 필요 없다.   가능한 모든 경우의 수를 다루어야 한다.   반드시 default문이 있어야 한다. (모든 케이스를 빠짐없이 봐야하기 때문)   default문에는 일을 안한다면 break문을 써야 한다.   fallthrough: 무조건 아래 문장 실행해라.   범위 연산자/패턴 매칭 연산자를 사용해라.   ⚠️ switch문에서 ,(콤마)는 or 역할이다.   ⚠️ case에서 부등식을 사용할 수 없다 범위 연산자로 만들어진 범위 값으로 케이스를 정의해야 한다.        기본 방식       switch 변수 { case 값1:     // code case 값2, 값3:     // code case 값4:     // code default:   \tbreak // 실행하려는 코드가 없으면 반드시 break 입력 }                패턴 매칭       switch age { case 10...19:\t// 10...19 ~= age   \t// code case 20...29:   \t// code case 30...39:   \t// code default:   \tbreak }                case를 조건에 따라 처리하는 경우       switch num { case let x where x%2==0:\t\t// num변수를 x 상수에 바인딩 후, where 조건절에서 케이스가 조건에 해당하는지 여부 확인     print(\"짝수 숫자: \\(x)\") default:     print(\"홀수 숫자: \\(num)\") }           범위 연산자           … 연산자       0...50  // 0부터 50까지 0..&lt;5\t  // 0, 1, 2, 3 ,4 ..&lt;0\t\t  // 정수의 범위에서 가장 낮은 숫자부터 0까지           패턴 매칭 연산자           ~= 연산자            오른쪽 변수가 왼쪽 범위에 포함되는지에 따라 참과 거짓을 알려주는 연산자       0...50 ~= num // 0~50 범위내에 num이 속한다면 Bool 타입으로 알려주는 기호                          if       switch                       조건 2개 사용가능 및 응용 범위가 넓다       if문보다 가독성이 좋다 실제 앱개발 시 분기처리에 많이 사용한다                                     2. 연습문제   연습문제1   /* 가위 / 바위 / 보 게임을 if문을 사용해서 구현해 봅니다. 컴퓨터는 가 위, 바위, 보 중에서 랜덤(무작위)으로 선택하게 되고, 당신은 한가지 를 고릅니다. 그리고 결과적으로  “무승부입니다.”, “당신은 졌습니다.”, “당신이 이겼습니다.” 이 셋 중에 한가지가 출력되도록 합니다. 가위: 0 바위: 1 보: 2 */  // 컴퓨터가 무작위로 선택(0, 1, 2) // 사용자: 0, 1, 2 중 입력  print(\"(가위: 0, 바위: 1, 보: 2)입력: \", terminator: \"\") let comNum: Int = Int.random(in: 0...2) let user: String = readLine()!  if let userNum = Int(user) {     if 0...2~=userNum {         if userNum == 0, comNum == 0 {             print(\"무승부\")         } else if userNum == 0, comNum == 1 {             print(\"패배\")         } else if userNum == 0, comNum == 2 {             print(\"승리\")         }          else if userNum == 1, comNum == 0 {             print(\"승리\")         }         else if userNum == 1, comNum == 1 {             print(\"무승부\")         }         else if userNum == 1, comNum == 2 {             print(\"패배\")         }          else if userNum == 2, comNum == 0 {             print(\"패배\")         }         else if userNum == 2, comNum == 1 {             print(\"승리\")         }         else if userNum == 2, comNum == 2 {             print(\"무승부\")         }      } else {         print(\"0~2 사이의 값을 입력하세요\")     } } else {     print(\"숫자를 입력해주세요\") }    개선1   @main struct Main {     static func main() {         let comNum: Int = Int.random(in: 0...2)          print(\"(가위: 0, 바위: 1, 보: 2) 입력: \", terminator: \"\")                  // 안전한 입력 처리         guard let userInput = readLine(), let userNum = Int(userInput), (0...2).contains(userNum) else {             print(\"❌ 0~2 사이의 숫자를 입력하세요.\")             return         }                  // 승패 판별 로직 (배열 활용)         let resultMatrix = [             [\"무승부\", \"패배\", \"승리\"],  // userNum == 0 (가위)             [\"승리\", \"무승부\", \"패배\"],  // userNum == 1 (바위)             [\"패배\", \"승리\", \"무승부\"]   // userNum == 2 (보)         ]                  let result = resultMatrix[userNum][comNum]         print(\"컴퓨터: \\(comNum) → 결과: \\(result)\")     } }   개선2   @main struct Main {     static func main() {         let comNum = Int.random(in: 0...2)  // 0: 가위, 1: 바위, 2: 보          print(\"(가위: 0, 바위: 1, 보: 2) 입력: \", terminator: \"\")          // 안전한 입력 처리         guard let userInput = readLine(), let userNum = Int(userInput), (0...2).contains(userNum) else {             print(\"❌ 0~2 사이의 숫자를 입력하세요.\")             return         }          print(\"컴퓨터: \\(comNum), 사용자: \\(userNum)\")          // 승패 판별 로직 (switch 문 활용)         switch (userNum, comNum) {         case let (u, c) where u == c:             print(\"무승부\")         case (0, 1), (1, 2), (2, 0):  // 사용자가 졌을 경우             print(\"패배\")         case (0, 2), (1, 0), (2, 1):  // 사용자가 이긴 경우             print(\"승리\")         default:             print(\"오류 발생\")         }     } }   연습문제2   /* 컴퓨터가 1부터 10사이의 정수에서 랜덤 값을 선택하고, 저장하 도록 합니다. 그리고 당신은 1부터 10사이의 정수를 선택합니다. 컴퓨터가 선택한 랜덤값과 당신의 값을 비교하고 당신의 숫자가 더 높은 경우는 “Down”, 당신의 숫자가 더 낮은 경우는 “Up”, 당신의 숫자와 동일한 경우 “Bingo”가 출력되도록 합니다. */  while true {     print(\"1부터 10 사이 원하는 숫자를 입력하세요(힌트: \\(comNum)): \", terminator: \"\")     let userNum = readLine()!      if let userNum = Int(userNum) {         // if !(0...10).contains(userNum) {}          /*          switch userNum {          case let x where !(0...10).contains(x):          print(\"❌ 1부터 10 사이의 숫자를 입력하세요.\")          default:          print(\"✅ 입력한 숫자: \\(userNum)\")          }          */          /*          switch userNum {          case 0...10:          // print(\"🎉 입력한 숫자: \\(userNum), 컴퓨터 숫자: \\(comNum)\")          default:          print(\"❌ 1부터 10 사이의 숫자를 입력하세요.\")          }          */          switch userNum {         case let x where x == comNum:             print(\"Bingo\")             return         case let x where x &gt; comNum:             print(\"Down\")         case let x where x &lt; comNum:             print(\"Up\")         default:             print(\"❌ 1부터 10 사이의 숫자를 입력하세요.\")         }     } }   ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-03-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%A1%B0%EA%B1%B4%EB%AC%B8/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 튜플(Tuple)",
        "excerpt":"1. 튜플      원하는 연관된 데이터의 조합으로 만들 수 있는 타입이다.        변수를 선언과 동시에 해당 멤버(데이터의 종류 및 개수)가 결정되므로 추가/삭제는 불가능하다.       // 좌표 let position: (Int, Int) = (1, 2)   print(position.0)   print(position.1)    // 3차원 공간 let position3D: (Int, Int, Int) = (1, 2, 3) print(position3D.0) print(position3D.1) print(position3D.2)    // 태입 앨리어스를 이용하여 튜플의 묶음값을 치환해서 사용가능(이 자체가 하나의 타입) typealias GridPoint = (Int, Int)\t let grid: GridPoint = (1, 2) print(grid.0) print(grid.1)              Named Tuple(이름이 매겨진 튜플)           데이터의 각 요소에 이름을 붙일 수 있다.       let iOS = (\"Swift\", \"6.0\") let iOS2 = (language: \"Swift\", version: \"6.0\")    print(iOS.0, iOS.1) print(iOS2.0, iOS2.1) print(iOS2.language, iOS2.version)    // Swift 6.0 // Swift 6.0 // Swift 6.0              Decomposition(튜플의 분해)      튜플의 각 요소를 상수/변수화 가능하다. (바인딩)        특징: 데이터를 분해해서 활용할 수 있다.       let (name, age, address) = (\"홍길동\", 20, \"서울\") print(name) print(address)           튜플과 조건문 활용           if문 활용       let iOS = (\"Swift\", \"6.0\")    if iOS.0 == \"Swift\" &amp;&amp; iOS.1 == \"6.0\" {   \tprint(\"Swift 버전 \\(iOS.1)\") }            switch문 활용        변수의 케이스에 따라 구분할 때 주로 사용한다.       switch iOS { case (\"Swift\", 5):     print(\"스위프트 버전 5\") case (\"Swift\", 6):   \tprint(\"스위프트 버전 6\") default:     break }           튜플의 switch문 바인딩        각 케이스 내에서 튜플의 각 요소를 활용할 때 주로 사용한다.       switch coordinate { case (let x, let y):     print(\"좌표는 (\\(x), \\(y)) 입니다.\") default:     break }           튜플의 switch문 바인딩/where절        특정 조건에 따라 튜플 케이스를 처리하고 싶을 때 주로 사용한다.       switch coordinate { case let (x, y) where x == y:     print(\"좌표는 (\\(x), \\(y)) 입니다.\") default:     break }           튜플을 사용하는 이유 with function      함수는 원칙적으로 리턴값이 하나만 존재하여 여러 값을 반환할 수 없다.        하지만 튜플을 리턴하면 묶음 값으로 반화할 수 있다.       func tuple() -&gt; (String, Int) {     return (\"Index\", 26) } print(tuple())           ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-04-%ED%8A%9C%ED%94%8C/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] (삼항/범위/패턴매칭)연산자",
        "excerpt":"1. 삼항연산자(Ternary Conditional Operator)      세가지 항을 가진 연산자이다.   조건에 따라 선택이 2가지인 경우 사용한다.   ? 와 : 를 사용한다.   조건에 따라 리터럴 값을 선택하여 변수에 대입할 때 사용한다.   if문과 동일하게 사용가능하다.   삼항연산자는 단독으로 사용하기 보다는 결과 값을 대입할 때 주로 사용한다.        ✅ 사용 예시: 어떤 조건에 따라 선택이 두가지인 경우 사용한다.       // if문 if condition { \t\tprint(\"1\") } else {   \tprint(\"2\") }    // 삼항연산자 condition ? print(\"1\") : print(\"2\") var name = a &gt; 5 ? \"스티브\" : \"인덱스\"           2. 범위연산자      Swift에서 범위를 쉽게 표기하는 방법이다.                  폐쇠 범위 연산자(Closed Range Operator)       반폐쇄 범위 연산자(Half-Open Range operator)                       1…10 ClosedRange 1… PartialRangeForm …10 PartialRangeThrough       1..&lt;10 Range ..&lt;10 PartialRangeUpTo           3. 패턴 매칭 연산자(~=)      오른쪽에 있는 표현식이 왼쪽의 범위에 포함되는 지에 따라 참과 거짓을 반환한다.        범위연산자와 함께 쓰이는 연산자이다.       var age = 26 1...9 ~= age    // false 20...29 ~= age  // true           ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-05-%EC%82%BC%ED%95%AD%EB%B2%94%EC%9C%84%ED%8C%A8%ED%84%B4%EB%A7%A4%EC%B9%AD-%EC%97%B0%EC%82%B0%EC%9E%90/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 반복문",
        "excerpt":"1. for문      범위나 컬렉션에서 item을 하나씩 뽑아, 중괄호 안에서 반복 실행한다.   ⚠️ 여기서 item은 반복상수 이다.        즉 for in 반복상수는 매번 새로운 스택 공간에 동일한 식별자로 선언과 동시에 초기화되된다.       for item in 범위 or 컬렉션 { \t\tprint(item) }    for item in 1...5{      }    // 첫 사이클에서 item은 아래와 같다 let item: Int = 숫자              상수를 사용하는 이유      반복변수 item이가 불변(let) 이므로 Stack에 저장된다.   Stack 메모리는 매우 빠르며, var가 필요한 추가적인 메모리 할당 및 변경 비용이 필요없다.   만약 var를 사용하여 값을 변경할 수 있다면 Heap에 메모리를 할당해야 할 가능성이 높아지고 성능이 저하될 수 있음.   var를 사용하면 Swift의 ARC(Auto Reference Counting)가 변경을 추적해야 할 수 도 있다. 하지만 let을 사용하면 ARC가 불필요한 참조 카운트 연산을 수행하지 않아도 되어 성능 향상이 될 수 있다.   와일드카드 패턴      생략을 위해 사용하는 언더바이다. (_)        상수나 변수로 저장할 필요없이, 생략해도 되는 경우에 사용한다.       for _ in 1...5 {      }    let _ = (1...10).reversed()           for문 추가예제           범위에서 많이 사용되는 예제       // 범위 // (1...10).reversed // stride(from: 1, to: 15, by: 2) for item in 범위 {      }           2. while문           참과 거짓을 판단할 수 있는 문장(조건: condition) 즉 조건을 만족하는 동안 중괄호 내부를 반복 실행한다.       while 참과 거짓을 판단할 수 있는 문장 {   \t// 참일 때 계속 실행   \t// 조건에 변화를 주는 문장 }           repeat-while        일단 문장을 실행하고 난 뒤, 조건에 따라 반복적으로 실행할 지 여부 확인 후 반복 실행.       repeat {   \t// 조건에 변화를 주는 문장 } while 참과 거짓을 판단할 수 있는 문장           3. for vs while                  for       While                       반복횟수를 미리 알고 있거나 컬렉션, 범위 등을 이용할 때 또는 반복상수를 사용하는 작업을 해야할 때       반복횟수가 미리 정해져 있지 않고  조건에 따라 바뀔 때                 범위, 컬렉션, 문자열, stride       조건           4. 제어전송문      반복문 내에서 쓰이는 제어전송 명령문(흐름 제어)                  continue       반복문에서 다음 주기로 넘어간다       중첩사용시 가장 인접한 반복문에 영향을 미친다                       Break       반복문을 중지시킨다       중첩사용시 가장 인접한 반복문에 영향을 미친다           ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-06-%EB%B0%98%EB%B3%B5%EB%AC%B8/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Swift] 메모리",
        "excerpt":"1. let 사용이 성능적으로 유리한 이유      Stack 메모리 사용으로 메모리 할당이 빠르다.   컴파일러가 최적화 가능하여 불필요한 연산을 제거한다.   멀티스레드 환경에서 안전하며 동기화 비용이 절감된다.   CPU 명령어 최적화로 실행 속도 증가한다.   ARC 부담 감소로 불피요한 참조 카운트 연산이 감소한다.   Stack vs Heap           Stack              함수나 스코프 내에 선언된 값타입(Valur Type)은 Stack에 저장된다.       메모리 할당과 해제가 빠르다 (LIFO 방식)       let, var 모두 Stack에 저장될 수 있다 (값 타입일 경우)                값 타입(Value Type, Struct, Int, String, Array 등)           func example() {     var number: Int = 10 // 값 타입(Int)이므로 Stack에 저장됨     number += 5 // 여전히 Stack에서 관리됨 }                                Heap              객체(클래스, 클로저 등)처럼 참조 타입(Reference Type) 은 Heap에 저장된다.       여러 변수에서 공유될 수 있으며, ARC로 관리된다.       메모리 할당과 해제가 상대적으로 느리다.                참조 타입(Reference Type, Class, Closure 등)           class Person {     var name: String     init(name: String) {         self.name = name     } }       func example() {     var person1 = Person(name: \"Alice\") // Heap에 저장됨     var person2 = person1 // 같은 객체를 참조 (참조 카운트 증가)           person1.name = \"Bob\" // 변경하면 person2도 영향을 받음 (같은 객체이므로) }                           ###   ","categories": [],
        "tags": ["Swift"],
        "url": "/Swift-07-%EB%A9%94%EB%AA%A8%EB%A6%AC/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] Task-1",
        "excerpt":"1. 기존 동시성 프로그래밍(GCD)      대기열 / 큐를 사용하였다        대기열에 넣어서 2번 cpu에 일을 시키는 방식으로 비동기 처리       // 기존 동시성 프로그래밍(GCD) // 기본적으로 다른 쓰레드로 보내지 않았다면 1번 쓰레드(cpu)에서 실행한다 print(\"메인 쓰레드에서 실행 - 1\") print(\"메인 쓰레드에서 실행 - 2\")    // 무조건 2번(또는 특정의 백그라운드) 스레드로 보내서 실행하겠다는 의미(클로저 내에서는 순차적 실행)  DispatchQueue.global().async {     print(\"백그라운드 쓰레드에서 실행 - 1\")     print(\"백그라운드 쓰레드에서 실행 - 2\") }    print(\"메인 쓰레드에서 실행 - 3\") print(\"메인 쓰레드에서 실행 - 4\")           2. Swift Concurrency(asyc/await/task)   Task      비동기적인 일처리를 할 수 있는 하나의 실행 작업 단위를 만드는 것이다.        기존의 GCD방식과 거의 유사하다. (2번 스레드로 보내서 일을 시킨다는 점에서)       print(\"메인 쓰레드에서 실행 - 1\") print(\"메인 쓰레드에서 실행 - 2\")    Task {     print(\"백그라운드 쓰레드에서 실행 - 1\")     print(\"백그라운드 쓰레드에서 실행 - 2\") }    print(\"메인 쓰레드에서 실행 - 3\") print(\"메인 쓰레드에서 실행 - 4\")            서로 다른 작업 단위      각각의 Task는 다른 작업 단위이다.   예를 들어 Task1은 2번 Cpu에 일을 시킬 수 있고 동시에 Task2는 3번 Cpu에게 일을 시킬 수 있다.   Task는 병렬적으로 동시에 일을 할 수 있도록 해준다.        Task 클로저 내부는 순차적으로 실행된다.       // Task 1: // 2번 cpu Task {     print(\"백그라운드 쓰레드에서 실행 - 1\")     print(\"백그라운드 쓰레드에서 실행 - 2\") }    // Task 2: 3번 cpu Task {     print(\"백그라운드 쓰레드에서 실행 - 3\")     print(\"백그라운드 쓰레드에서 실행 - 4\") }    // -&gt; 2번, 3번 병렬적으로 동시에 일을 할 수 있게 만들어준다              Task를 변수/상수에 담을수도 있다      Task 자체를 타입으로 생성을 해서 변수에/상수에 담을 수 있다.   작업을 변수/상수에 담으면 변수에 접근하여 cancel 메서드(작업 취수) 사용 가능.        Never: 일반적인 구조에서 에러 발생하지 않는다.       let task: Task&lt;Void, Never&gt; = Task {     print(\"비동기적인 일 - 7\")     print(\"비동기적인 일 - 8\") } task.cancel()           Task 작업의 결과로 문자열을 리턴할 수 있다           task에서 문자열을 접근할 수 있다.       let task: Task&lt;String, Never&gt; = Task {     print(\"비동기적인 일 - 1\")     print(\"비동기적인 일 - 2\")     return \"문자열\" } // task.value -&gt; Task 성공의 결과값에 접근 // task.result -&gt; Task를 Result 타입으로 변환 가능           동기 함수 내에서 비동기적인 일처리를 할 수 있다           함수 내부에 작업을 만들어서 비동기적인 일처리 가능하다.       func doSomething() {     Task {         try await Task.sleep(for: .seconds(2))         print(\"함수 내부의 비동기적인 일 - 1\")         print(\"함수 내부의 비동기적인 일 - 2\")     } } /* 함수 내부의 비동기적인 일 - 1 함수 내부의 비동기적인 일 - 2 */    func doSomething2() {     print(\"함수 내부의 동기적인 실행 - 1\")            // 2번 Cpu에서 비동기적인 일 실행 가능     Task {         // 2초동안 일을 멈추는 코드.. 즉 2초정도 걸림         try await Task.sleep(for: .seconds(2))         print(\"함수 내부의 오래걸리는 일\")     }     print(\"함수 내부의 동기적인 실행 - 2\") }    /* 함수 내부의 동기적인 실행 - 1 함수 내부의 동기적인 실행 - 2 함수 내부의 오래걸리는 일 */           작업의 우선순위는 6가지가 존재한다      우선순위 지정은 선택사항이다.        우선순위를 사용하지 않는 방법이 일반적이다.       // 선택사항 우선순위 지정가능 task = Task(priority: .우선순위) {   // 비동기적인 일(비동기 함수 실행) }    // 현재 우선순위를 볼 수 있다 Task(priority: .userInitiated) {   \tprint(\"우선순위: \\(Task.currentPriority)\") }    /// 작업 실행 우선 순위의 종류 /// =============================== /// TaskPriority.userInitiated - 25 /// TaskPriority.high - 25 /// TaskPriority.medium - 21 /// TaskPriority.low - 17 /// TaskPriority.utility - 17 /// TaskPriority.background - 9 /// ===============================           작업은 지금 실행 컨텍스트(실행되고 있는 환경)의 메타데이터를 그대로 상속해서 사용한다(구조적 동시성은 아니다)           내부에서 자동으로 현재의 컨텍스트(어떤 환경에서 실행되는지)를 파악하고            우선순위 -&gt; 실행액터 -&gt; 로컬변수(Task-Local 변수)            취소는 상속되지 않는다.       let task = Task(priority: .background) {     sleep(2)     print(\"비동기적인 일 실행: \\(Task.currentPriority)\")     print(\"Task 내부에서 취소 여부: \\(Task.isCancelled)\")          // 내부의 작업 -&gt; 부모 작업의 메타데이터(우선 순위 등)를 상속 사용(취소는 상속 불가)     // 작업 안에서 작업을 다시 생성하는 것은 구조화를 시키지 않는다(하위 작업이 되는 것이 아니다)     Task {         print(\"비동기적인 일 실행: \\(Task.currentPriority)\")         print(\"Task 내부의 Task에서 취소 여부: \\(Task.isCancelled)\")     } }    // task.cancel() 하더라도 내부 Task는 실행된다 -&gt; 상속이 안되기 때문 task.cancel()    /* print(\"비동기적인 일 실행: \\(Task.currentPriority)\") print(\"Task 내부의 Task에서 취소 여부: \\(Task.isCancelled)\") */           특징           작업은 비동기적인 일처리를 위한 기본단위이다. (모든 비동기적인 일처리는 Task 일부)            우선순위 지정은 선택사항이다.            구조체로 만들어져있다.            인스턴스를 생성하자마자 operation 파라미터에 해당하는 클로저를 전달하면서, 작업(Task)을 생성 및 클로저로 전달된 작업을 즉시 실행한다.            즉 클로저를 할당하여 작업을 만들고 클로저를 바로 실행하여 Task를 생성한다.            Task 클로저 내에서 비동기적인 일 수행 가능하다.            비동기 실행 컨텍스트(비동기 함수기 실행될 수 있는 환경)을 만드는 것이다.            Swift Concurrency에서 작업 Task는 기본 단위이다.            Task는 트레일링 클로저 형태로 사용한다.            작업 클로저를 생성하자마자 작업 즉시 실행한다.            https://developer.apple.com/documentation/swift/task       // 에러를 던지지 않는 함수 Task(priority: &lt;#T##TaskPriority?#&gt;, operation: &lt;#T##() async -&gt; Sendable#&gt;) // 에러를 던질 수 있는 함수 Task(priority: &lt;#T##TaskPriority?#&gt;, operation: &lt;#T##() async throws -&gt; Sendable#&gt;)           ​  ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-Task-1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] Task-2",
        "excerpt":"1. Task      비동기적인 일처리를 할 수 있는 하나의 일(work)의 단위.   작업의 생성한다음 바로 비동기적인 일처리를 시작한다.        Operation 파라미터에 해당하는 클로저를 전달하면서, 작업Task을 생성 및 클로저로 전달된 (비동기적인) 작업을 즉시 실행한다.       // 인스턴스 생성 Task {     // 비동기적인 일(인스턴스를 생성하자마자 비동기 작업 실행한다) }           작업의 취소           변수에 담아서 관리가 가능해진다       task.cancel()           결과값 접근           작업은 Success 또는 Failure를 리턴       await task.value  // 작업의 성공의 결과값에 접근 await task.result // 작업의 결과를 Result 타입으로 변환           작업은 각자 비동기적인 작업 처리를 진행하므로, 각 작업은 병렬적으로 일처리를 진행한다   작업은 현재 실행중인 컨텍스트의 메타데이터를 그대로 상속해서 사용한다      2. 작업의 특징      Swift Concurrency에서 작업은 비동기적인 일처리를 위한 기본 단위이다.   작업은 동시성 코드를 실행하고 그 상태와 관련 데이터를 관리한다.   작업의 내부 코드는 순차적으로 동작한다. (멈췄다가 실행될 수도 있다)   컴파일 시점에 thread-safe하지 않은 코드 작성을 불가능하도록 하여 잠재적 불안정 가능성을 제거한다.   기존의 CGD는 대기열 방식인데 큐 자체가 우선 순위를 보유하기 때문에 반드시 우선순위로 실행되지 않을 수 있다.   기존의 CGD는 비동기 작업에 우선 순위를 지정할 수 있었지만 큐 내에서는 FIFO 방식이어서 기본적으로 대기열에 클로저가 등록된 순서대로 처리된다.   Task는 새로운 비동기 방식으로, 우선 순위로 지정한 일을 먼저 끝낼 수 있다.   Task 에서 새로운 방식 도입      Task 내부에서 실행되는 함수는 잠시 중단되었다가 다시 재개될 수 있다.(새로운 방식)   async/awit 도입한다는 것은 어떤 함수가 실행되다가 중단되었다가 다시 실행될 수 있는 개념을 만들어 주는 것이다.   반드시 Task 안에서 실행을 시켰을 때만 중단이 가능하다.  ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-Task-2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] Task-3",
        "excerpt":"1. Task 클로저에서 self 키워드 사용           Task {} 로 작업을 만들 수 있다.            클로저를 할당하면 클로저를 바로 실행하면서 Task를 생성한다.       struct Work: Sendable {}    class Worker {     var work: Task&lt;Void, Never&gt;?     var result: Work?          deinit {         print(\"인스턴스 해제\")     }     \t     func start() {         // 클로저를 통해 작업 생성         work = Task {             print(\"작업의 시작\")             try? await Task.sleep(for: .seconds(3))             // 주의: Task클로저에서 외부변수 result 접근             // self를 부쳐도 된다(원칙이 아님.. 암시적으로 self를 캡처하기 때문-&gt; 문법적 약속)             // 암시적 캡처란 현재 실행 컨텍스트를 캡처하여 현재의 액터 또는 클래스 인스턴스와 같은 실행 환경을 포함하기 때문에 이미 컴파일러가 self를 안전하게 참조할 수 있도록 처리하기 때문에 명시적으로 캡처할 필요가 없는 것이다.             result = Work()             print(\"작업의 완료\")         }     }     \t     // 클래스 내부에서 @escaping 클로저 사용하는 경우     // (self가 캡처되니 주의해서 사용해라는 의미에서) self 키워드 반드시 필요하다(원칙 -&gt; 문법적 약속)     func start2() {         DispatchQueue.global().async {             self.result = Work()         }     } }           2. Task 클로저에서 [weak self] 사용 필요 x           [weak self] in 쓸 필요 없다.            이유: Task는 작업이 끝나면 self 참조도 해제가 되어 강한 순환 참조가 일어날 수 없다.       class Worker {     var work: Task&lt;Void, Never&gt;?     var result: Work?          deinit {         print(\"인스턴스 해제\")     }     \t     func start() {          work = Task { // [weak self] in // 쓸 필요 없다             // 이유: Task는 작업이 끝나면 self 참조도 해제가 된다             print(\"작업의 시작\")             try? await Task.sleep(for: .seconds(3))             result = Work()             print(\"작업의 완료\")         }     }          func start2() {          // 비동기작업이 20초 걸린다고 가정시 self를 캡처한다면 20초동안 붙잡아두는데 이렇게 오래동안 붙잡아두는 상황을 피하기 위해 [weak self]를 사용은 가능하다. 일반적인 상황에서는 사용하지 않는다.         work = Task { [weak self] in              print(\"작업의 시작\")             try? await Task.sleep(for: .seconds(3))             self?.result = Work()             print(\"작업의 완료\")         }     }          // detached를 붙히면 self 필수이다.      // detached도 작업의 종류 중 하나인데 독립적인 작업을 만드는 것이다.     // 기존의 컨텍스트를 물려받지 않고(메타데이터를 상속해서 사용하지 않고 즉 무시하고) 독립적인 작업을 만든다.     func start3() {            work = Task.detached {               print(\"작업의 시작\")               try? await Task.sleep(for: .seconds(3))               self.result = Work()               print(\"작업의 완료\")           }      }              func start4() {       \tDispatchQueue.global().async { [weak self] in           \tself?.result = Work()         }     } }           ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-Task-3/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] async-await-1",
        "excerpt":"1. 기존의 비동기 함수   기존의 비동기 함수 정의 방법      오래 걸려서 얻는 결과값을 반드시 콜백 클로저 형태로 돌려받아야 했다.        올바르지 않은 형태       // 기존 방식에서 잘못된 함수 설계의 형태 func getImage1() -&gt; UIImage? {     var image: UIImage?            /// 오래 걸리는 일(2번 cpu에게 일을 시킨다)     DispatchQueue.global().async {          sleep(5)         image = UIImage(systemName: \"heart\")     }     ///          /// 1번 cpu에서 일을 한다     return image      /// } // 기다리지 않고 image는 무조건 nil이 나옴..                 올바른 형태       // 올바른 형태 (콜백함수 방식으로 설계해야 한다) func getImage2(callback: @escaping (UIImage?) -&gt; Void) {            // 오래 걸리는 일     DispatchQueue.global().async {         sleep(5)         let image = UIImage(systemName: \"heart\")         callback(image) // 콜백함수를 호출하여 데이터 전달     } }           2. async/await라는 개념이 등장           getImage1()처럼 리턴을 하는 것도 가능하도록 설계 가능해졌다.            ⚠️비동기 작업을 수행하면서도 특정 작업의 순서를 보장하고 싶을 때 await을 사용       // async: (이미지를 받아오는데) \"오래걸리는 함수\" 의미 func getImage() async -&gt; UIImage? {     var image: UIImage?     image = UIImage(systemName: \"heart\")     return image }    // async 함수는 호출시 await로 호출해야한다, Task 내에서 호출해야한다. // Task는 비동기 작업을 의미 Task {     let image1 = await getImage()     let image2 = await getImage()     let image3 = await getImage()     let image4 = await getImage() }                비동기 함수 안에서도 await 호출 가능하다. 이때는 Task 필요 x       func doSomething() async {     let image1 = await getImage()     let image2 = await getImage()     let image3 = await getImage()     let image4 = await getImage() }           기존 방식인 sleep -&gt; Task.sleep 방식으로 변경   Sleep(5)는 해당 CPU가 일을 하지 못하게 만드는 코드였다.(Blocking 방식)   Task.sleep은 함수가 실행되다가 잠깐 멈췄다가 나중에 n초 뒤에 다시 실핼할 수 있다.(non-Blocking 방식)            스레드가 비우게 만들어서 이 스레드에서 다른 일처리를 가능하게 해준다.       Await: 다시 실행되기를 기다리겠다           // async: (이미지를 받아오는데) \"오래걸리는 함수\" 의미 func getImage() async throws -&gt; UIImage? {     var image: UIImage?          // sleep(5)     // 기존 5초간 잠재우는 방식에서 변경     try await Task.sleep(for: .seconds(5))      // try가 들어간 에러를 던질 수 있는 함수이므로 함수 정의부분에 throws 추가(에러를 다시 밖으로 던질 수 있어야 한다)     // 이유: 함수 내부에서 do-catch 문 처리를 하지 않아서 throws 키워드를 붙혀야 한다     // 오래동안 걸리는 비동기 함수로 정의되어서 await도 추가..     \t     image = UIImage(systemName: \"heart\")     return image }       // try? throws즉 에러를 던지지 않아도 된다 // 에러 발생시 nil 리턴 func getImage() async -&gt; UIImage? {         // 이를 실행하면 중단됬다가 5초뒤에 재개가능     // 그동안 이를 사용하는 스레드는 다른 일처리가 가능해짐     // 이미지가 생기는 시점에 다시 일처리가 재개     try? await Task.sleep(for: .seconds(5))      let image = UIImage(systemName: \"heart\")     return image }    // 비동기로 정의된 함수를 await로 호출해야한다는 의미는 (1)비동기는 함수가 오래 걸릴 수 있는 함수임을 의미하기도 하지만 (2)잠시 멈췄다가 다시 실행될 수 있는 함수이다. Task {     let image = await getImage() }           ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-async-await-1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] async-await-2",
        "excerpt":"1. GCD 비동기 vs Swift ConCurrency 비동기   GCD 비동기      다른 쓰레드로 일을 시키고, 기다리지 않는다.        해당 작업이 끝나는 시점에 콜백 함수를 통해 값을 리턴 받거나 끝난 시점을 알려준다.       // 정의 func method(closure: @escaping (String) -&gt; Void) {     // 함수 내부 정의     closure(result) }    // 실행 method { result in     print(result)\t       }           Async 비동기 “함수”      async 키워드를 보면 먼저 생각할 것 “(1) 함수가 오래 걸릴 수 있다” “(2) 실행되던 함수가 중간에 멈췄다가 재개될 수 있다.”   중간에 잠깐 멈췄다가(suspend) 다시 재개(resume)될 수 있는 함수다.        CPU(쓰레드)는 해당 (함수) 작업을 실행시키지만 중간에 멈출 수 있는 포인트(suspension point)에서 작업의 진행상황을 시스템(운영체제)에 잠깐 저장했다가 나중에 다시 실행시킬 수도 있다.            (함수 실행시 비동기 컨텍스트에서 호출해야한다)       // 정의 func asyncMethod() async -&gt; String {     // 함수 내부 정의     let result = await otherMethod()     return result }    // 실행 // Task: 비동기적인 환경을 만들어준다 Task {     let result = await asyncMethod()     print(result) }           2. 비동기(async)함수 정리      중간에 잠깐 멈췄다가(suspend or pause) 재개(resume)될 수 있는 함수이다.   Cpu(쓰레드)는 해당 (비동기 함수) 작업을 실행시키지만 중간에 멈출 수 있는 포인트(suspension point)에서 쓰레드 제어권을 시스템(운영체제)에 넘긴다. 시스템은 다른 작업을 수행할 수 있다.   반드시 작업(Task) 내부 또는 다른 비동기 함수 내부(즉 비동기 컨텍스트)에서만 호출 가능하다.   데드락 원천적 방지(non-blockig 방식) 즉 잠시 멈춘 동안에 쓰레드를양보해서 다른 작업이 사용할 수 있도록 양보.   3. GCD vs async/await (Pyramid of doom)   GCD 불편함      비동기 함수의 일이 종료되는 시점을 연결하기 위해 끊임없는 콜백함수를 연결해야 함.        죽음의 피라미드…       func gcdImageData(completionBlock: (_ result: Image) -&gt; Void) {     loadWebResource(\"dataprofile.txt\") { dataResource in         loadWebResource(\"imagedata.dat\") { imageResource in             decodeImage(dataResource, imageResourc) { imageTMP in                 dewarpAndCleanupImage(imageTMP) { imageResult in                     completionBlock(imageResult)                 }             }         }     } }           async/await      콜백함수를 계속 들여쓰기 할 필요없이 반환(return) 시점을 기다릴 수 있고, 직관적인 코드 처리 가능하다.   오래 걸릴 수 있는 함수를 호출하면 데이터가 생기는 시점에 변수에 바인딩 가능하다.   함수이 호출이 오래걸리더라도 콜백 방식 사용 필요 없디.   동기방식으로 순차적으로 코드를 읽을 수 있다.        ⚠️ 각 비동기 함수가 완료된 후에 다음 줄이 실행된다!          func asyncImageData() async throws -&gt; Image {     let dataResource = try await loadWebResource(\"dataprofile.txt\")     let imageResource = try await loadWebResource(\"imagedata.dat\")     let imageTmp = try await decodeImage(dataResource, imageResource)     let imageResult = try await dewarpAndCleanupImage(imageTMP)     return imageResult }           ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-async-await-2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[Concurrency] async-await-3",
        "excerpt":"1. 에러 처리           에러를 던지는 비동기 함수 정의            에러를 던질 수 있는 비동기함수 실행시 try await            async 다음에 throws가 와야한다.            try 다음에 await이 와야한다.       // 1 func throwingGetImage() async throws -&gt; UIImage? {     // 오래 걸리는 일.., 에러가 던질 수 있는 코드     try await Task.sleep(for: .seconds(2))     return UIImage(systemName: \"heart\") }    // 에러를 던질 수 있는 비동기 함수 정의 func asyncMethod() async throws -&gt; String {     let result = try await otherMethod()     return result }    // 원칙적 방법 Task {     do {         let totalString = try await asyncMethod()         print(totalString)     } catch {         \t     } }    let task = Task {     // 1. asyncMethod는 비동기 함수라서 await 붙혀준다     // 2. 에러를 던질 수 있으므로 try 키워드를 붙혀준다     // 3. 원칙적 처리로는 do-catch가 맞지만 처리하지 않아도 된다     // 이유: Task 자체가 에러를 던질 수 있다     let result = try await asyncMethod()     print(result) }    Task {     await task.result }           2. 비동기 함수 실행방법 2가지                       (1) Task 안에서 async 함수 호출           Task {     let image = await getImage() }                                (2) 다른 async 함수 안에서 async 함수 호출 가능(비동기 컨텍스트)           func getImages() async -&gt; [UIImage?] {     let image1 = await getImage()     let image2 = await getImage()     let image3 = await getImage()       \t     return [image1, image2, image3] }      Task {     let images = await getImages() }                           3. 언제든지 비동기적인 컨텍스트 만드는 것 가능                       비동기함수는 비동기적인 컨텍스트에서 호출되야한다           func someSyncFunc() {     print(\"동기적인 작업 시작\")     Task {         try await Task.sleep(for: .seconds(2))         print(\"비동기적인 작업내에서의 작업\")     }     print(\"동기함수 작업 종료\") }                           4. 비동기 함수 내에서 비동기 함수 호출              각각의 함수 자체가 중간에 멈췄다가 다시 실행할 수 있다.       순서대로 진행된다.       비동기 함수 내에서 다른 비동기 함수를 호출을 하는것은 현재의 실행 컨텍스트 내에서 실행을 시키는 것이다(취소 전파도 가능하고, 하위 작업을 만드는 것이 아니다).                즉 구조적 동시성이 아니다.           func parentFuncgion() async throws {     // async 함수 내에서 다른 async 함수 호출: 동일한 비동기 컨텍스트 내에서의 실행(작업의 입루)     try await asyncFunction()     try await asyncFunction()      // Task를 사용하여 명시적으로 다른 작업(Task) 생성 가능(구조적 동시성은 아니고 따로 작업을 만든다) 병렬 실행     // 자식 작업의 생성 방식은 아니다     Task {         try await asyncParentFunction()         try await asyncParentFunction()     }              print(\"비동기 함수 실행의 종료\") }                           ","categories": [],
        "tags": ["Concurrency"],
        "url": "/Concurrency-async-await-3/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[알고리즘] 인접행렬",
        "excerpt":"1.  인접행렬      그래프와 정점과 간선의 관계를 나타내는 bool 타입의 정사각형 행렬이다.   정사각형 행렬의 각 요소가 0 또는 1의 값을 가짐을 의미한다.   0: 두 정점 사이의 경로가 없다.   1: 두 정점 사이의 경로가 있다.            import Foundation  let n = 4 let arr: [[Int]] = [     [0, 1, 1, 1],     [1, 0, 1, 0],     [1, 1, 0, 0],     [1, 0, 0, 0] ]  for i in 0..&lt;n {     for j in 0..&lt;n {         if arr[i][j] != 0 {             print(\"\\(i)부터 \\(j)까지 경로가 있습니다\")         }     } }   예제 1) 3번부터 5번 노드로 가는 단방향 경로가 있고 이를 인접행렬로 표현한다면?   a[3][5] = 1   예제 2) 3번노드에서 5번노드로 가는 양방향 경로가 있고 이를 인접행렬로 표현한다면?   a[3][5] = 1 a[5][3] = 1   예제 3) 정점의 개수가 20개인 그래프가 존재할 때, 이를 인접행렬로 표현하되 메모리를 최소로 사용하려면?   var a: [[Bool]] = Array(repeating: Array(repeating: false, count: 20), count: 20)   예제 4) 노드 1, 2, 3이 있으며, 1번 노드에서 2번 노드로 가는 단방향 경로와 2번 노드에서 3번 노드로 가는 단방향 경로를 인접행렬로 표현한다면?   [0, 1, 0] [0, 0, 1] [0, 0, 0]   예제 5) 1~4노드로 이루어진 4개의 노드가 존재한다. 1-&gt;2, 2-&gt;3, 3-&gt;4로 이동하는 노드경로가 있을 때 인접행렬로 표현한다면?   [0, 1, 0, 0] [0, 0, 3, 0] [0, 0, 0, 1] [0, 0, 0, 0]   예제 6) 1번부터 5번의 노드가 존재할 때, 모든 노드가 서로 연결되어있는 완전 그래프의 인접행렬을 표현하려면?   [0, 1, 1, 1, 1] [1, 0, 1, 1, 1] [1, 1, 0, 1, 1] [1, 1, 1, 0, 1] [1, 1, 1, 1, 0]   예제 7) 노드 1, 2, 3이 있으며 1-&gt; 3노드로 가는 단방향 경로가 있고, 3 -&gt; 2노드로 가는 단방향 경로가 있다. 또한 2 -&gt; 1노드로 가는 경로가 있을 때 인접행렬로 표현하려면?   [0, 0, 1] [1, 0, 0] [0, 1, 0]   예제 8-1) 정점은 0번 부터 9번까지 10개의 노드가 있다. 1 - 2 / 1 - 3 / 3 - 4 라는 경로가 있다. (1번과 2번, 1번과 3번, 3번과 4번은 연결되어있다.) 이를 인접행렬로 표현하라.   a[1][2] = 1; a[1][3] = 1; a[3][4] = 1; a[2][1] = 1; a[3][1] = 1; a[4][3] = 1;   예제 8-2) 0번부터 방문안한 노드를 찾고 해당 노드부터 방문, 연결된 노드를 이어서 방문해서 출력하는 재귀함수를 만들어라. 여기서 정점을 방문하고 다시 방문하지 않게 만들어야 한다.      Swift에서 &amp;&amp; 연산자는 단락 평가(short-circuit evaluation)를 수행하기 때문에    visited[i]가 false이면 adjMatrix[from][i]가 평가되지 않는다.    즉, 불필요한 배열 접근이 발생하지 않으므로 continue 방식과 성능이 동일하다.   let v: Int = 10 var adjMatrix: [[Bool]] = Array(repeating: Array(repeating: false, count: v), count: v) var visited: [Bool] = Array(repeating: false, count: v)  // 재귀함수 func go(_ from: Int) {     visited[from] = true     print(from)          for i in 0..&lt;v {         /*         1번방식         만약 방문하였으면 다음루프로         if visited[i] { continue }                  만약 두 정점 사이의 경로가 있다면 탐색         if adjMatrix[from][i] {             go(i)         }          */                  // 2번방식         if !visited[i] &amp;&amp; adjMatrix[from][i] {             go(i)         }     } }  // 그래프 간선 추가(무방향 그래프) adjMatrix[1][2] = true; adjMatrix[1][3] = true; adjMatrix[3][4] = true; adjMatrix[2][1] = true; adjMatrix[3][1] = true; adjMatrix[4][3] = true;  for i in 0..&lt;v {     for j in 0..&lt;v {         // 만약 두 정점 사이의 경로가 있고 &amp; 방문하지 않았으면 탐색하자         if !visited[i] &amp;&amp; adjMatrix[i][j] {             go(i)         }     } }   ","categories": [],
        "tags": ["Algorithm"],
        "url": "/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B8%EC%A0%91%ED%96%89%EB%A0%AC/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[자료구조] Queue",
        "excerpt":"Queue   struct DoubleStackQueue&lt;T&gt; {     private var enqueueStack: [T] = []     private var dequeueStack: [T] = []          var size: Int {         return enqueueStack.count + dequeueStack.count     }          var isEmpty: Bool {         return enqueueStack.isEmpty &amp;&amp; dequeueStack.isEmpty     }          mutating func enqueue(_ element: T) {         enqueueStack.append(element)               // O(1)     }          @discardableResult     mutating func dequeue() -&gt; T? {         if dequeueStack.isEmpty {             dequeueStack = enqueueStack.reversed() // O{n}             enqueueStack.removeAll()               // O(1)         }         return dequeueStack.popLast()              // O(1)     } }  @main struct Main {     static func main() {         let times = 1_000_000 // 100만 개 삽입         var myQueue = DoubleStackQueue&lt;Int&gt;()          // 🔹 Enqueue 시간 측정         var startTime = CFAbsoluteTimeGetCurrent()         for i in 1...times {             myQueue.enqueue(i)          }         var durationTime = CFAbsoluteTimeGetCurrent() - startTime         print(\"DoubleStackQueue enqueue time: \\(durationTime) seconds\")          // 🔹 Dequeue 시간 측정         startTime = CFAbsoluteTimeGetCurrent()         for _ in 1...times {             myQueue.dequeue()          }         durationTime = CFAbsoluteTimeGetCurrent() - startTime         print(\"DoubleStackQueue dequeue time: \\(durationTime) seconds\\n\")     } }   Result  DoubleStackQueue enqueue time: 0.25131893157958984 seconds DoubleStackQueue dequeue time: 0.34246695041656494 seconds  ","categories": [],
        "tags": ["Data Structure"],
        "url": "/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Queue/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[AutoLayout]-오토레이아웃-1",
        "excerpt":"1. 오토레이아웃이란?      오토레이아웃이란 뷰 계층구조에 있는 모든 뷰의 크기와 위치를 제약조건(constraints)에 따라 동적으로 계산한다.   즉 자동으로 레이아웃을 그린다는 의미이다.   2. Constraints란?      제약조건(Constraints)란 뷰의 위치와 크기를 다른 객체로부터 상대적으로 나타내는 방법이다.   오토 레이아웃은 제약조건(Constraints)을 이용해서 크기와 위치를  정한다.   view의 frame을 직접 지정해주는 것이 아니라 다른 객체(SafeArea)를 이용해 상대적으로 제약을 주는 것이다   3. 예시   기준 객체(Safe Area)로부터 왼쪽으로 30, 오른쪽으로 30, 위로 100만큼의 margin이 있고 heigh가 200이라는 제약조건이 있는 UIView를 그려보자.      UIView의 width를 정해주지 않았지만 Leading / Trailing Constraints에 의해 서로 당기는 성질이 있어서 해상도 별로 width가 자동으로 저장된다.   만약 가로의 크기가 100인 해상도일 경우 UIView는 100 - 30 - 30 = 40만큼의 width를 가질 것이다.   오토 레이아웃은 크기와 위치가 제일 중요하다.   여기서 크기는 height: 200, width: SafeArea에서 좌우 margin(30)을 뺀 나머지 값(해상도별로 동적으로 변함)   여기서 위치는 Leading: 30, Trailing: 30, Top: 50        ","categories": [],
        "tags": ["AutoLayout"],
        "url": "/AutoLayout-AutoLayout-1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[CleanArchitecture] 클린 아키텍처",
        "excerpt":"  Clean Architecture란?  로버트 C 마틴(Robert C. Martin), 별명으로는 엉클 밥(Uncle Bob)이 제안한 아키텍처로 소프트웨어를 다양한 계층(Layer)으로 분리해서 다음과 같은 목표를 추구한다     아키텍처는 특정 소프트웨어 라이브러리에 의존하지 않는다.   비즈니스 로직은 UI, DB, 웹 또는 기타 외부 요소 없이 테스트 할 수 있다.   UI는 비즈니스 로직과 분리되어, 시스템 로직을 변경하지 않고도 UI를 교체할 수 있다.   비즈니스 로직은 데이터베이스와 바인딩되어 있지 않다.   비즈니스 로직은 외부 세계(입출력 등)에 대해 아무것도 알지 못한다.      요약하자면, 소프트웨어를 역할별로 레이어를 나누고     각 레이어를 완전히 분리하여 의존성을 낮추는 것  이 클린아키텍처의 핵심이다.    이를 통해 변화에 유연하고 테스트하기 쉬운 구조를 만들 수 있다.    왜 아키텍처가 필요한가?  개발자는 돈을 받고 코드를 만드는 사람이다.    회서에서 가장 즁요한 것은     낮은 인건비로   결함이 적은 소프트웨어를 빠르게 개발하는 것   이다. 하지만 모든 개발자들이 적은 인력으로 유지보수가 가능하면서 결함율이 낮은 소프트웨어를 만들어낼 수 없다.    오히려 많은 인력을가지고도 유지보수도 못하고 버그는 많이 생기는 소프트웨어를 만든다.      소프트웨어를 만드는 건 누구나 할 수 있지만,    적은 인력으로 유지보수가 쉬운 ‘좋은 소프트웨어’를 만드는 건 어렵다.    그렇기 떄문에 좋은 아키텍처 의 개념이 중요하다.    좋은 아키텍처는 변화에 강하고, 유지보수가 쉽고, 테스트가 쉬운 구조를 만드는 데 핵심이 된다.   모바일에서의 클린아키텍처           엉클밥의 클린아키텍처 컨셉을 보면 계층을 4개로 분리하였다.    모바일 설계에서의 클린 아키텍처를 적용하기 위한 방법 중 하나로 3Layer 형태로 주로 사용한다.   1.Domain Layer     Entity와 UseCase 계층을 묶어 Domain Layer 라고 부른다.   Entity            앱의 핵심 데이터구조이다.           UseCase            핵심 비즈니스 로직이다.       유저 리스트 불러오기       유저 상세 데이터 불러오기       유저를 내부 저장소에 저장하기           Repository 인터페이스            UseCase와 Data Layer(서버 API, 로컬 DB)를 연결해주는 중간 다리 역할이다.       Domain Layer에서 Repository는 인터페이스(Protocol)만 존재한다.       실제 구현은 Data Layer에서 한다.           2. Data Layer     통신 및 데이터 관리 로직을 담당하는 계층이다.   DB, API            실제 데이터의 입출력을 담당한다.           Repository 구현체            데이터를 조정하는데 UseCase가 필요로 하는 데이터 저장/수정하는 기능을 한다.       데이터소스(ex. DB)를 Protocol같은 인터페이스 형태로 참조하기 때문에 데이터 소스 객체를 갈아끼울 수 있는 형태로, 외부 API를 호출하거나 로컬 DB에 접근하거나 테스트를 위한 MockObject로 전환할 수 있다.           3. Presentation Layer     UI표시, 애니메이션, 이벤트 핸들링 같은 UI 관련 모든 처리를 담당하는 계층이다.   View(ViewConroller, View)            UI 화면 표시와 사용자의 터치 이벤트를 수신한다.       화면에 그리는게 어떤 의미인지는 모르고, 어떤 색으로 그리는지와 같은 View적인 요소만 결정한다.       단순히 Presentor(ViewModel)에서 받은 데이터나 상태에 따라 뷰의 표시를 전환한다.           Presenter(ViewModel)            MVP/VIPER라면 Presenter역할, MVVM이라면 ViewModel역할과 동일하다.       사용자의 이벤트에 대한 판단과 대응을 진행한다. 뷰에 그려지는게 어떤 의미인지, 무엇을 그려야하는지 알고 있다.           의존성 규칙  클린 아키텍처에서 지켜야 할 규칙으로 의존성 규칙이 있다.     안쪽 원을 향하는 방향이 규칙이므로  Data Layer와 Presentation Layer가 Domain Layer를 바라보는 방향으로 의존성 방향이 지켜져야 한다.       Reference     https://sunny-maneg.tistory.com/entry/iOS-설계에서의-Clean-Architecture   https://yoojin99.github.io/app/클린-아키텍처/   https://mini-min-dev.tistory.com/284   https://velog.io/@woohm402/clean-architecture-short-summary   ","categories": [],
        "tags": ["CleanArchitecture"],
        "url": "/CleanArchitecture-CleanArchitecture/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[CleanArchitecture]-객체 지향 설계의 5원칙 SOLID",
        "excerpt":"SOLID 원칙이란  SOLID 원칙이란 객체지향 설계에서 지켜야 할 5개의 소프트웨어 개발 원칙을 의미한다.     특정 프로그래밍 언어 혹은 프레임워크를 위해 만든 원치이 아니다.   객체 지향 설계의 5원칙 SOLID     단일 책임 원칙 (Single Responsibility Principle)   개방 폐쇄 원칙 (Open Closed Principle)   리스코프 치환 원칙 (Liskov Subsitution Principle)   인터페이스 분리 원칙 (Interface Segregation Principle)   의존 역전 원칙 (Dependency Inversion Principle)   SOLID 원칙은 oop 4가지 특징(추상화, 상속, 캡슐화, 다형성)과 더불어, 객체 지향 프로그래밍의 단골 면접 질문 중 하나이다. 또한 Design Pattern들이 SOLID 설계 원칙에 입각해서 만들어진 것이기 때문에 표준화 작업에서부터 아키텍처 설계에 이르기까지 다양하게 적용되는 이의 근간이 되는 SOLID 원칙에 대해 정확히 이해할 필요가 있다.   좋은 소프트웨어란 변화에 대응을 잘 하는 것을 말한다. 예를 들어 클라이언트가 추가적인 요청을 한다면 구현을 할 때 애로사항없이 잘 대응하기 위해서 소프트웨어 설계 근간이 좋아야 한다.   좋은 설계란 시스템에 새로운 요구사항이나 변경사항이 있을 때, 영향을 받는 범위가 적은 구조를 말한다.    그래서 시스템에 예상치 못한 변경사항이 발생하더라도, 유연하게 대처하고 이후에 확장성있는 시스템 구조를 만들 수 있다.   즉 SOLID 객체 지향 원칙을 적용하면 코드를 확장하고 유지보수 관리가 쉬워지며 불필요한 복잡성을 제거하여 리팩토링 소요 시간을 줄임으로써 프로젝트 개발의 생산성을 높일 수 있다.   ","categories": [],
        "tags": ["CleanArchitecture"],
        "url": "/CleanArchitecture-SOLID/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[하루한컷] 1. iOS 카카오 로그인",
        "excerpt":"1. 카카오 로그인     https://developers.kakao.com/console/app 링크 접속   애플리케이션 추가   플랫폼 iOS 등록   네이티브 앱키를 Config.config파일에 저장   2. 파이어베이스 프로젝트 생성     Authentication 생성   Authentication에서 로그인 방법에서 카카오 로그인을 위해 OIDC 추가(이때 업그레이드 해줘야함)           프로젝트 설정에서 Google-Info.plist다운   3. 코드 설정  AppDelegate.swift  import UIKit  // 파이어베이스 import FirebaseCore import FirebaseAuth  // 카카오톡 import RxKakaoSDKCommon import RxKakaoSDKAuth import KakaoSDKAuth  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {     // Override point for customization after application launch.          // 파이어베이스 설정     FirebaseApp.configure()          // 카카오톡 설정     if let nativeAppKey: String = Bundle.main.infoDictionary?[\"KAKAO_NATIVE_APP_KEY\"] as? String {         RxKakaoSDK.initSDK(appKey: nativeAppKey)     }          return true }  func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -&gt; Bool {     // 카카오톡 로그인     if (AuthApi.isKakaoTalkLoginUrl(url)) {         return AuthController.rx.handleOpenUrl(url: url)     }          return false }   SceenDelegate.swift  func scene(_ scene: UIScene, openURLContexts URLContexts: Set&lt;UIOpenURLContext&gt;) {     // 카카오 로그인     if let url = URLContexts.first?.url {         if (AuthApi.isKakaoTalkLoginUrl(url)) {             _ = AuthController.rx.handleOpenUrl(url: url)         }     } }   MVC.swift   import UIKit import RxSwift  import RxKakaoSDKAuth import KakaoSDKAuth  import RxKakaoSDKUser import KakaoSDKUser   final class LoginViewController: UIViewController {          let disposeBag = DisposeBag()          private lazy var kakaoLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Kakao\")         config.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0)         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"카카오로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(red: 0.8, green: 0.72, blue: 0.0, alpha: 1.0) // 눌렸을 때 진한 노랑             } else {                 config?.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0) // 기본 노랑             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleKakaoLogin), for: .touchUpInside)         return button     }()          private lazy var appleLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Apple\")         config.baseBackgroundColor = .white         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"Apple로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(white: 0.9, alpha: 1.0) // 눌렀을 때 약간 회색             } else {                 config?.baseBackgroundColor = .white // 원래 흰색             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleAppleLogin), for: .touchUpInside)         return button     }()          // 카카오로그인버튼, 애플로그이넙튼 -&gt; 스택뷰에 추가     private lazy var stackView: UIStackView = {         let st = UIStackView(arrangedSubviews: [             kakaoLoginButton,             appleLoginButton         ])         st.spacing = 10         st.axis = .vertical         st.distribution = .fillEqually         st.alignment = .fill         return st     }()          override func viewDidLoad() {         super.viewDidLoad()         makeUI()     }          func makeUI() {         // 배경 색상         view.backgroundColor = #colorLiteral(red: 0.09411741048, green: 0.09411782771, blue: 0.102702044, alpha: 1)                  // 스택뷰 -&gt; 뷰에 추가         view.addSubview(stackView)         stackView.translatesAutoresizingMaskIntoConstraints = false                  // 오토레이아웃 제약 추가         NSLayoutConstraint.activate([             stackView.centerXAnchor.constraint(equalTo: view.centerXAnchor),             stackView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),             stackView.heightAnchor.constraint(equalToConstant: 130)         ])     }          @objc private func handleKakaoLogin() {         print(\"✅ 카카오 로그인 버튼 눌림\")         startKakaoLogin()      }          @objc private func handleAppleLogin() {         print(\"✅ Apple 로그인 버튼 눌림\")     } }  // MARK: - Observable extension LoginViewController {          func startKakaoLogin() {         fetchKakaoOpenIdToken()             .subscribe(onNext: { token in                 print(\"✅ 받은 토큰: \\(token)\")             }, onError: { error in                 print(\"❌ 로그인 에러: \\(error.localizedDescription)\")             })             .disposed(by: disposeBag)     }      private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }  #Preview {     LoginViewController() }   VIewController + ViewModel  ViewController  import UIKit import RxSwift  import RxKakaoSDKAuth import KakaoSDKAuth  import RxKakaoSDKUser import KakaoSDKUser   final class LoginViewController: UIViewController {          let disposeBag = DisposeBag()     private let viewModel = LoginViewModel()                 private func bindViewModel() {         viewModel.loginSuccess             .observe(on: MainScheduler.instance)             .subscribe { token in                 print(\"로그인 성공: \\(token)\")             }             .disposed(by: disposeBag)                  viewModel.loginFailure             .observe(on: MainScheduler.instance)             .subscribe { errorMessage in                 print(\"로그인 실패: \\(errorMessage)\")             }             .disposed(by: disposeBag)     }           private lazy var kakaoLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Kakao\")         config.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0)         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"카카오로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(red: 0.8, green: 0.72, blue: 0.0, alpha: 1.0) // 눌렸을 때 진한 노랑             } else {                 config?.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0) // 기본 노랑             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleKakaoLogin), for: .touchUpInside)         return button     }()          private lazy var appleLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Apple\")         config.baseBackgroundColor = .white         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"Apple로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(white: 0.9, alpha: 1.0) // 눌렀을 때 약간 회색             } else {                 config?.baseBackgroundColor = .white // 원래 흰색             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleAppleLogin), for: .touchUpInside)         return button     }()          // 카카오로그인버튼, 애플로그이넙튼 -&gt; 스택뷰에 추가     private lazy var stackView: UIStackView = {         let st = UIStackView(arrangedSubviews: [             kakaoLoginButton,             appleLoginButton         ])         st.spacing = 10         st.axis = .vertical         st.distribution = .fillEqually         st.alignment = .fill         return st     }()          override func viewDidLoad() {         super.viewDidLoad()         makeUI()         bindViewModel()     }          func makeUI() {         // 배경 색상         view.backgroundColor = #colorLiteral(red: 0.09411741048, green: 0.09411782771, blue: 0.102702044, alpha: 1)                  // 스택뷰 -&gt; 뷰에 추가         view.addSubview(stackView)         stackView.translatesAutoresizingMaskIntoConstraints = false                  // 오토레이아웃 제약 추가         NSLayoutConstraint.activate([             stackView.centerXAnchor.constraint(equalTo: view.centerXAnchor),             stackView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),             stackView.heightAnchor.constraint(equalToConstant: 130)         ])     }          @objc private func handleKakaoLogin() {         print(\"✅ 카카오 로그인 버튼 눌림\")         viewModel.loginWithKakao()     }          @objc private func handleAppleLogin() {         print(\"✅ Apple 로그인 버튼 눌림\")     } }  // MARK: - Observable extension LoginViewController {          func startKakaoLogin() {         fetchKakaoOpenIdToken()             .subscribe(onNext: { token in                 print(\"✅ 받은 토큰: \\(token)\")             }, onError: { error in                 print(\"❌ 로그인 에러: \\(error.localizedDescription)\")             })             .disposed(by: disposeBag)     }      private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }  #Preview {     LoginViewController() }   ViewModel  import Foundation import RxSwift import RxCocoa import KakaoSDKUser import RxKakaoSDKUser import RxKakaoSDKAuth import KakaoSDKAuth  final class LoginViewModel {     private let disposeBag = DisposeBag()           // View에서 구독할 수 있도록 공개용 Subject      let loginSuccess = PublishSubject&lt;String&gt;()      let loginFailure = PublishSubject&lt;String&gt;()          func loginWithKakao() {         fetchKakaoOpenIdToken()             .subscribe { token in                 self.loginSuccess.onNext(token)             } onError: { error in                 self.loginFailure.onNext(error.localizedDescription)             }             .disposed(by: disposeBag)     }          private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }   VIewController + ViewModel + Results  ViewController  import UIKit import RxSwift  import RxKakaoSDKAuth import KakaoSDKAuth  import RxKakaoSDKUser import KakaoSDKUser   final class LoginViewController: UIViewController {          let disposeBag = DisposeBag()     private let viewModel = LoginViewModel()          private func bindViewModel() {         viewModel.loginResult             .observe(on: MainScheduler.instance)             .subscribe { result in                 switch result {                 case .success(let token):                     print(\"로그인 성공: \\(token)\")                 case .failure(let error):                     print(\"로그인 실패: \\(error.localizedDescription)\")                 }             }.disposed(by: disposeBag)     }          private lazy var kakaoLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Kakao\")         config.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0)         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"카카오로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(red: 0.8, green: 0.72, blue: 0.0, alpha: 1.0) // 눌렸을 때 진한 노랑             } else {                 config?.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0) // 기본 노랑             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleKakaoLogin), for: .touchUpInside)         return button     }()          private lazy var appleLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Apple\")         config.baseBackgroundColor = .white         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"Apple로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(white: 0.9, alpha: 1.0) // 눌렀을 때 약간 회색             } else {                 config?.baseBackgroundColor = .white // 원래 흰색             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleAppleLogin), for: .touchUpInside)         return button     }()          // 카카오로그인버튼, 애플로그이넙튼 -&gt; 스택뷰에 추가     private lazy var stackView: UIStackView = {         let st = UIStackView(arrangedSubviews: [             kakaoLoginButton,             appleLoginButton         ])         st.spacing = 10         st.axis = .vertical         st.distribution = .fillEqually         st.alignment = .fill         return st     }()          override func viewDidLoad() {         super.viewDidLoad()         makeUI()         bindViewModel()     }          func makeUI() {         // 배경 색상         view.backgroundColor = #colorLiteral(red: 0.09411741048, green: 0.09411782771, blue: 0.102702044, alpha: 1)                  // 스택뷰 -&gt; 뷰에 추가         view.addSubview(stackView)         stackView.translatesAutoresizingMaskIntoConstraints = false                  // 오토레이아웃 제약 추가         NSLayoutConstraint.activate([             stackView.centerXAnchor.constraint(equalTo: view.centerXAnchor),             stackView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),             stackView.heightAnchor.constraint(equalToConstant: 130)         ])     }          @objc private func handleKakaoLogin() {         print(\"✅ 카카오 로그인 버튼 눌림\")         viewModel.loginWithKakao()     }          @objc private func handleAppleLogin() {         print(\"✅ Apple 로그인 버튼 눌림\")     } }  // MARK: - Observable extension LoginViewController {          func startKakaoLogin() {         fetchKakaoOpenIdToken()             .subscribe(onNext: { token in                 print(\"✅ 받은 토큰: \\(token)\")             }, onError: { error in                 print(\"❌ 로그인 에러: \\(error.localizedDescription)\")             })             .disposed(by: disposeBag)     }      private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }  #Preview {     LoginViewController() }     ViewModel  import Foundation import RxSwift import RxCocoa import KakaoSDKUser import RxKakaoSDKUser import RxKakaoSDKAuth import KakaoSDKAuth  final class LoginViewModel {     private let disposeBag = DisposeBag()          let loginResult = PublishSubject&lt;Result&lt;String, Error&gt;&gt;()          func loginWithKakao() {         fetchKakaoOpenIdToken()             .subscribe { token in                 self.loginResult.onNext(.success(token))             } onError: { error in                 self.loginResult.onNext(.failure(error))             }             .disposed(by: disposeBag)     }          private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }   VIewController + ViewModel + Result + Input/Output  ViewController  import UIKit import RxSwift  import RxKakaoSDKAuth import KakaoSDKAuth  import RxKakaoSDKUser import KakaoSDKUser  final class LoginViewController: UIViewController {          let disposeBag = DisposeBag()     private let viewModel = LoginViewModel()     private let kakaoLoginTapped = PublishSubject&lt;Void&gt;()          private func bindViewModel() {         let input = LoginViewModel.Input(kakaoLoginTapped: kakaoLoginTapped.asObservable())         let output = viewModel.transform(input: input)                  output.loginResult             .observe(on: MainScheduler.instance)             .subscribe { result in                 switch result {                 case .success(let token):                     print(\"로그인 성공: \\(token)\")                 case .failure(let error):                     print(\"로그인 실패: \\(error.localizedDescription)\")                 }             }.disposed(by: disposeBag)     }          private lazy var kakaoLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Kakao\")         config.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0)         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"카카오로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(red: 0.8, green: 0.72, blue: 0.0, alpha: 1.0) // 눌렸을 때 진한 노랑             } else {                 config?.baseBackgroundColor = UIColor(red: 1.0, green: 0.9, blue: 0.0, alpha: 1.0) // 기본 노랑             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleKakaoLogin), for: .touchUpInside)         return button     }()          private lazy var appleLoginButton: UIButton = {         let button = UIButton(type: .system)         var config = UIButton.Configuration.filled()         config.image = UIImage(named: \"Logo Apple\")         config.baseBackgroundColor = .white         config.imagePlacement = .leading    // 이미지가 텍스트 왼쪽에 위치         config.imagePadding = 20            // 이미지와 텍스트 사이 간격         config.title = \"Apple로 계속하기\"         config.baseForegroundColor = .black         // 폰트 설정         config.titleTextAttributesTransformer = UIConfigurationTextAttributesTransformer { incoming in             var outgoing = incoming             outgoing.font = UIFont.systemFont(ofSize: 16, weight: .medium)             return outgoing         }         button.configuration = config         button.layer.cornerRadius = 10         button.clipsToBounds = true         // 상태에 따라 배경색 바꾸기         button.configurationUpdateHandler = { button in             var config = button.configuration             if button.isHighlighted {                 config?.baseBackgroundColor = UIColor(white: 0.9, alpha: 1.0) // 눌렀을 때 약간 회색             } else {                 config?.baseBackgroundColor = .white // 원래 흰색             }             button.configuration = config         }         button.addTarget(self, action: #selector(handleAppleLogin), for: .touchUpInside)         return button     }()          private lazy var stackView: UIStackView = {         // 카카오로그인버튼, 애플로그이넙튼 -&gt; 스택뷰에 추가         let st = UIStackView(arrangedSubviews: [             kakaoLoginButton,             appleLoginButton         ])         st.spacing = 10         st.axis = .vertical         st.distribution = .fillEqually         st.alignment = .fill         return st     }()          override func viewDidLoad() {         super.viewDidLoad()         makeUI()         bindViewModel()     }          func makeUI() {         // 배경 색상         view.backgroundColor = #colorLiteral(red: 0.09411741048, green: 0.09411782771, blue: 0.102702044, alpha: 1)                  // 스택뷰 -&gt; 뷰에 추가         view.addSubview(stackView)         stackView.translatesAutoresizingMaskIntoConstraints = false                  // 오토레이아웃 제약 추가         NSLayoutConstraint.activate([             stackView.centerXAnchor.constraint(equalTo: view.centerXAnchor),             stackView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),             stackView.heightAnchor.constraint(equalToConstant: 130)         ])     }          @objc private func handleKakaoLogin() {         print(\"✅ 카카오 로그인 버튼 눌림\")         kakaoLoginTapped.onNext(())         //viewModel.loginWithKakao()     }          @objc private func handleAppleLogin() {         print(\"✅ Apple 로그인 버튼 눌림\")     } }  #Preview {     LoginViewController() }   ViewModel  import Foundation import RxSwift import RxCocoa import KakaoSDKUser import RxKakaoSDKUser import RxKakaoSDKAuth import KakaoSDKAuth  final class LoginViewModel {     private let disposeBag = DisposeBag()          // let loginResult = PublishSubject&lt;Result&lt;String, Error&gt;&gt;()          struct Input {         let kakaoLoginTapped: Observable&lt;Void&gt;     }          struct Output {         let loginResult: Observable&lt;Result&lt;String, Error&gt;&gt;     }          func transform(input: Input) -&gt; Output {         let result = PublishSubject&lt;Result&lt;String, Error&gt;&gt;()                  input.kakaoLoginTapped             .flatMapLatest { [weak self] _ -&gt; Observable&lt;Result&lt;String, Error&gt;&gt; in                 guard let self = self else { return .empty() }                 return self.fetchKakaoOpenIdToken()                     .map { .success($0) }                     .catch { error in                             .just(.failure(error))                     }             }             .bind(to: result)             .disposed(by: disposeBag)                  return Output(loginResult: result.asObservable())     }          private func fetchKakaoOpenIdToken() -&gt; Observable&lt;String&gt; {         if UserApi.isKakaoTalkLoginAvailable() {             return UserApi.shared.rx.loginWithKakaoTalk()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (앱 로그인)\")                     return idToken                 }         } else {             return UserApi.shared.rx.loginWithKakaoAccount()                 .map { oauthToken in                     guard let idToken = oauthToken.idToken else {                         // print(\"⚠️ idToken이 없습니다\")                         throw NSError(domain: \"TokenError\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"idToken이 없습니다.\"])                     }                     print(\"✅ idToken 추출 성공 (웹 로그인)\")                     return idToken                 }         }     } }  ","categories": [],
        "tags": ["Haruhancut"],
        "url": "/Haruhancut-Haruhancut-1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[ReactiveX] 1. 반응형 프로그래밍이란?",
        "excerpt":"   1. 반응형 프로그래밍이란?  데이터의 흐름 및 변경사항을 전파하는 데 중점을 둔 프로그래밍 패러다임이다.     이 패러다임을 사용할 경우, 주변 환경/데이터 변화가 생길 때 연결된 실행 모델들이 이 이벤트를 받아 동작하도록 설계하는 방식이다.      선(→) : 데이터가 흐르는 경로이며, Observable이라고 부른다.   점(●) : 시간에 따라 발생하는 이벤트(Event) 하나를 의미한다.   debounce 박스 : 이벤트를 필터링하는 Operator(연산자)로, 너무 잦은 이벤트를 제어한다.   아래쪽 선 : debounce 이후 실제로 구독자에게 전달되는 결과 흐름을 보여준다.   비유로 설명  자동차(Event)들이 도로(Ovservable)를 따라 달리고 있을 때,  교통경찰 역할을 하는 debounce가 너무 많은 차를 제어해준다.    지나치게 빠르게 지나가는 차들은 걸러내고, 일정 시간 동안 마지막으로 지나간 차(이벤트)만 통과시킨다.    즉 이벤트가 여러 번 발생하더라도 debounce를 통과한 이벤트만 최종적으로 전달한다.   2. RxSwift란?  Reactive Extension/Programming + Swift로, 관찰 가능한 시퀀스를 사용하여 비동기 및 이벤트 기반 프로그램을 구성하기 위한 라이브러리다.   Swift는 함수형 프로그래밍(Functional Programming) 패러다임을 강조하는 언어이다.     이에 RxSwift는 반응형 프로그래밍(Reactive Programming)을 더하여, Swift에서 FRP(Functional Reactive Programming)을 따를 수 있도록 한다.    즉 Swift를 반응형 프로그래밍 하는 것이다.   예시  Observable     .combineLatest(firstName.rx.text, lastName.rx.text) {  $0 + \" \" $1 }     .map { \"Greetings, \\(#0)\" }     .bind(to: greetingLabel.rx.text)     .disposed(by: DisposeBag)     comBineLatest나 map을 RxSwift에서 Operator라고 부른다.   이러한 연산자를 사용해서 이벤트의 값을 여러 형태로 조합하거나 변경할 수 있다.   또한 MVVM패턴을 적용할 때 View와 ViewModel을 연결해주는, 데이터 바인딩을 수행해야 한다.    이때 bind(정확히 말하자면 bind는 RxCocoa이다) 연산자를 사용하여 쉽게 바인딩이 가능하다.     DisoatchQueue에서 직접 조정해야 했던 작업들을 자동으로 처리해준다.   3. RxSwift 사용 목적  func doSomethingIncredible(forWho: String) throws -&gt; IncredibleThing  // 재시도 doSomethingIncredible(\"me\")     .retry(3)     API 통신을 하다보면, 성공할 때도 있지만 실패할 때도 분명 존재한다.   실패시 단순히 끝나는게 아니라 3번 정도 재시도 할 수 있다면 좋겠지만 재시도 코드는 많이 복잡하고, 재사용하기도 어렵다.   RxSwift를 사용하면 retry연산자를 사용해 쉽게 재시도 코드를 작성할 수 있다.   4. Combine도 같은 개념이다   Swift에서 RxSwift와 동일한 반응형 프로그래밍을 지원하는 Apple 공식 프레임워크가 Combine이다.  Cimbine은 iOS 13부터 내장되어 있으며, RxSwift와 거의 동일한 비동기 이벤트 스트림을 처리할 수 있다.                  개념       RxSwift       Combine                       데이터 스트림       Observable       Publisher                 구독       subscribe()       sink()                 데이터 조작       map, filter, flatMap, combineLatest 등       동일                 메모리 해제       DisposeBag       AnyCancellable (store in Set)                 비동기 이벤트 처리       가능       가능           import Combine  // 텍스트 필드 두 개를 결합해서 라벨에 표시 Publishers.CombineLatest(firstNamePublisher, lastNamePublisher)     .map { \"Greetings, \\($0) \\($1)\" }     .sink { [weak self] in self?.greetingLabel.text = $0 }     .store(in: &amp;cancellables)    Reference     https://velog.io/@gnwjd309/RxSwift-1   https://reactivex.io/intro.html   https://github.com/ReactiveX/RxSwift   https://babbab2.tistory.com/182   https://ios-development.tistory.com/95  ","categories": [],
        "tags": ["RxSwift","Combine"],
        "url": "/ReactiveX-ReactiveX-1/",
        "teaser": "/assets/img/2025-03-25-%5BRxSwift%5D-RxSwift-1/image.png"
      },{
        "title": "[RxSwift] 2. RxSwift개념",
        "excerpt":"   1. Rx란?  파이프라인 연결이다   2. 구성     보내는 것 - Observable   연결 - subScribe   중간처리 - 연산자   3. 큰 개념  보내는 것 - 옴저버블(총알 = 구독 가능한 것)     Observable            가장 기본 베이스, 생성하자마자 이벤트를 전달한다       .onNext(), .onError(), .onCompleted()를 통해 이벤트를 받을 수 있다       .subscribe()를 통해 이벤트를 발행 가능       이벤트를 정의하고, 정적인 스트림 생성(한방향: 선언 -&gt; 구독)            // 1. Observable은 가장 기본적인 Rx 스트림  let observable = Observable&lt;Int&gt;.just(1)       // 2. subscribe를 통해 값을 받아 처리  observable      .subscribe(onNext: { value in          print(\"Received: \\(value)\")      })      .disposed(by: disposeBag)           Subject            Observable(구독 가능한 것)이면서 Observer(관찰자)       일단 연결을 해두고 원하는 시점에 이벤트를 보낸다.       외부에서 직접 값을 넣고, 동적인 스트림 생성(양방향)                 BehaviorSubject - 상태                    초기값 필수           구독 시, 가장 최신값 1개를 즉시 전달받음           이후에는 일반 Observable처럼 .onNext 이벤트를 수신                   // 1. BehaviorSubject는 초기값을 설정하고, 구독 시 가장 최근 값을 전달 let behaviorSubject = BehaviorSubject&lt;String&gt;(value: \"초기값\")        // 2. 구독 설정 → \"초기값\"이 바로 전달됨 behaviorSubject     .subscribe(onNext: { print(\"BehaviorSubject:\", $0) })     .disposed(by: disposeBag)        // 3. 새로운 이벤트 전달 behaviorSubject.onNext(\"새로운 값\")                       PublishSubjcet - 단방향 이벤트                    구독 이후 이벤트만 받음(초기값 없음)           주로 이벤트 전달용                   // 1. PublishSubject는 구독 이후에 발생한 이벤트만 전달 let publishSubject = PublishSubject&lt;String&gt;()  // 2. 구독 설정 publishSubject     .subscribe(onNext: { print(\"PublishSubject:\", $0) })     .disposed(by: disposeBag)  // 3. 이벤트 발생 (구독 이후라 전달됨) publishSubject.onNext(\"첫 번째 이벤트\")                           Relay            Subject의 변형으로, error가 없고 UI바인딩에 최적화              PublishRelay            단방향 이벤트 전달(버튼 클릭)           // 1. PublishRelay는 error가 없고 UI에 최적화된 Subject let publishRelay = PublishRelay&lt;String&gt;()  // 2. 구독 설정 publishRelay     .subscribe(onNext: { print(\"PublishRelay:\", $0) })     .disposed(by: disposeBag)  // 3. 이벤트 발생 → accept()로 전달 publishRelay.accept(\"이벤트 발생!\")           BehaviorRelay            상태 저장, 초기값 필수 -&gt; accept() 사용           // 1. BehaviorRelay는 초기값이 필요하며, 상태 저장에 적합 let behaviorRelay = BehaviorRelay&lt;String&gt;(value: \"기본값\")  // 2. 구독 설정 → \"기본값\"이 바로 전달됨 behaviorRelay     .subscribe(onNext: { print(\"BehaviorRelay:\", $0) })     .disposed(by: disposeBag)  // 3. 값 업데이트 → accept() 사용 behaviorRelay.accept(\"업데이트된 값\")              Driver            메인스레드, share(1)       UI 바인딩 전용으로 사용되는 옵저버블              // 1. Relay에서 값을 가져와 Driver로 변환  let textRelay = BehaviorRelay&lt;String&gt;(value: \"Hello\")   // 2. Driver로 변환 (에러 없이, MainThread에서 작동)  let textDriver = textRelay.asDriver()   // 3. UI 요소에 drive (drive는 MainThread에서 UI 바인딩 시 사용)  textDriver      .drive(label.rx.text)      .disposed(by: disposeBag)           구독     subscribe(onNext:)            next, error, completed 시퀀스 이벤트를 받을 수 있다       직점 onError 처리 가능하다       viewModel 내부, 로직 처리, 이벤트 감지, 에러 대응       Disposable 반환해야한다       모든 Observable계열 구독 가능       bind(onNext:) 보다 범용적, 완료/에러 받을 수 있다            // 1. onNext만 사용하는 기본적인 구독  let observable = Observable.just(\"Hello, RxSwift!\")   observable      .subscribe(onNext: { value in          print(\"onNext:\", value)      })      .disposed(by: disposeBag)   // 2. onNext, onError, onCompleted 모두 명시  let observable = Observable&lt;String&gt;.create { observer in      observer.onNext(\"첫 번째 이벤트\")      observer.onCompleted()      return Disposables.create()  }   observable      .subscribe(          onNext: { print(\"onNext:\", $0) },          onError: { print(\"onError:\", $0.localizedDescription) },          onCompleted: { print(\"onCompleted\") },          onDisposed: { print(\"onDisposed\") }      )      .disposed(by: disposeBag)           bind(to:)            UI 컴포넌트 프로퍼티에 바인딩할 때 사용       구독과 동시에 값이 특정 속성에 직접 들어가는 방식       값을 특정UI의 속성에 직접 구독해서 바인딩           // label.text = title처럼 자동으로 연결하는 직접 바인딩 방식   viewModel.title    .bind(to: label.rx.text)    .disposed(by: disposeBag)                           bind(onNext:)            단순히 이벤트를 수신하고 구독 형태       내부에 명시적으로 처리 로직을 작성해야 함       값을 받아서 직접 처리(프린트, 로직 실행)하는 방식으로 구독           viewModel.title    .bind(onNext: { text in    print(\"값 출력: \\(text)\")    })    .disposed(by: disposeBag)                           비교     // 1. 자동 UI 업데이트 (bind to UI)   viewModel.username // Observable&lt;String&gt;       .bind(to: label.rx.text) // 📲 label.text = 값       .disposed(by: disposeBag)    // 2. 내가 직접 프린트 (bind with closure)   viewModel.username       .bind(onNext: { name in           print(\"유저 이름은 \\(name)\")       })       .disposed(by: disposeBag)  ","categories": [],
        "tags": ["RxSwift"],
        "url": "/RxSwift-RxSwift-2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[UIKit] Delegate Pattern란?",
        "excerpt":"1. Delegate 조건  UIKit 클론코딩을 하다 보면 여러가지 상황에서 Delegate Protocol을 채택하고 Protocol 내부에서 제공하는 method를 사용하게 된다. UITextField, UITableView에서도 기능을 구현할 때 흔하게 사용되는 방식이다. Apple에서 우리가 유용하게 사용할 만한 기능들을 함수에 담아 미리 구현해두고 우리가 추가적인 코드를 작성함으로서 우리가 원하는 방식대로 앱이 동작하게 할 수 있다.   Delegate Pattern 은 아래의 조건을 총족함으로서 사용할 수 있다.  Delegate를 생성하는 뷰     Protocol을 생성하고, 구현하고 싶은 기능을 해당 Protocol의 메서드로 생성   Protocol을 Type으로 갖는 Delegate 인스턴스 생성   생성한 method가 동작해야하는 상황에 코드 작성   Delegate를 위임받는 뷰     ViewController에 Delegate Protocol을 채택   Protocol 필수 method 구현   Delegate 위임   2. 준비  FirstViewController는 결과값을 표시할 Label, 두번째 Controller를 뛰울 Button  SecondViewController는 결과값을 입력받을 TextField와 첫번째 Controller로 돌아갈 수 있는 Button을 배치   Protocol  /// 1 protocol CustomTextFieldDelegate: AnyObject {     func textDidInput(text: String) }   FirstViewController  // //  FirstViewController.swift //  MyDelegate // //  Created by 김동현 on 4/30/25. //  import UIKit  final class FirstViewController: UIViewController {          // MARK: - UI Components     private lazy var myLabel: UILabel = {         let label = UILabel()         label.text = \"hello world\"         label.textColor = .white         return label     }()          private lazy var nextButton: UIButton = {         let button = UIButton()         button.setTitle(\"secondView\", for: .normal)         button.setTitleColor(.black, for: .normal)         button.backgroundColor = .systemMint         button.layer.cornerRadius = 20         button.addTarget(self, action: #selector(goNextView), for: .touchUpInside)         return button     }()      override func viewDidLoad() {         super.viewDidLoad()         makeUI()     }          func makeUI() {         // MARK: - 뷰 추가         [myLabel, nextButton].forEach {             view.addSubview($0)             $0.translatesAutoresizingMaskIntoConstraints = false         }                  // MARK: - 제약조건 설정         // 레이블         NSLayoutConstraint.activate([             myLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),             myLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor)         ])                  // 버튼         NSLayoutConstraint.activate([             // 위치 제약             nextButton.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             nextButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),                          // 크기 제약             nextButton.heightAnchor.constraint(equalToConstant: 50),             nextButton.widthAnchor.constraint(equalToConstant: 200)         ])     }          @objc     func goNextView() {         let secondVC = SecondViewController()         secondVC.delegate = self         self.present(secondVC, animated: true)     } }  /// 3 extension FirstViewController: CustomTextFieldDelegate {     func textDidInput(text: String) {         myLabel.text = text     } }  #Preview {     FirstViewController() }    SecondViewController  // //  SecondViewController.swift //  MyDelegate // //  Created by 김동현 on 4/30/25. //  import UIKit  final class SecondViewController: UIViewController {     /// 2     weak var delegate: CustomTextFieldDelegate? = nil          // MARK: - UI Components     private lazy var texxtField: UITextField = {         let textField = UITextField()                  // placeholder 스타일         textField.attributedPlaceholder = NSAttributedString(             string: \"입력해주세요\",             attributes: [.foregroundColor: UIColor.lightGray]         )                  // 왼쪽 여백         textField.leftView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 0))         textField.leftViewMode = .always                  // 테두리 스타일         textField.layer.borderColor = UIColor.black.cgColor // 테두리 색상         textField.layer.borderWidth = 1.0 // 테두리 둑께         textField.layer.cornerRadius = 10 // 둘글게                  return textField     }()          private lazy var endButton: UIButton = {         let button = UIButton()         button.setTitle(\"secondView\", for: .normal)         button.setTitleColor(.black, for: .normal)         button.backgroundColor = .systemMint         button.layer.cornerRadius = 20         button.addTarget(self, action: #selector(goBack), for: .touchUpInside)         return button     }()          override func viewDidLoad() {         super.viewDidLoad()         view.backgroundColor = .darkGray         /// print(\"delegate 상태:\", delegate as Any)         makeUI()     }          private func makeUI() {         // MARK: - 뷰 추가         [texxtField, endButton].forEach {             view.addSubview($0)             $0.translatesAutoresizingMaskIntoConstraints = false         }                  // MARK: - 제약조건 설정         // 텍스트필드         NSLayoutConstraint.activate([             // 위치             texxtField.centerXAnchor.constraint(equalTo: view.centerXAnchor),             texxtField.centerYAnchor.constraint(equalTo: view.centerYAnchor),                          // 크기             texxtField.heightAnchor.constraint(equalToConstant: 50),             texxtField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20)         ])                  // 버튼         NSLayoutConstraint.activate([             // 위치 제약             endButton.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -50),             endButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),                          // 크기 제약             endButton.heightAnchor.constraint(equalToConstant: 50),             endButton.widthAnchor.constraint(equalToConstant: 200)         ])     }          @objc     private func goBack() {         let text = texxtField.text ?? \"\"         self.delegate?.textDidInput(text: text)         self.dismiss(animated: true)     } }  #Preview {     FirstViewController() }    3. Delegate Pattern 연습  Protocol 구현하기  구현하고자 하는 method를 Protocol을 생성하고 그 내부에 만들어 주어야 한다. Protocol은 class을 Type으로 가진다. class Type을 가지게 되면 이후 생성할 delegate 인스턴스를 weak 형태로 생성할 수 있다.  // 1. 프로토콜 정의 (class 전용) protocol ChatDelegate: AnyObject {     func didReceiveMessage(_ message: String) }  // 2. 메시지를 받는 쪽 (delegate를 호출하는 쪽) class ChatRoom {     // 2.1 순환 참조 방지를 위해 반드시 weak 사용     // 프로토콜에 AnyObject 또는 class 제약을 반드시 붙여야 함     weak var delegate: ChatDelegate?      func receiveNewMessage() {         let message = \"안녕하세요!\"         delegate?.didReceiveMessage(message)     } }  // 3. 메시지를 표시할 화면 (delegate를 구현하는 쪽) class ChatViewController: UIViewController, ChatDelegate {     let chatRoom = ChatRoom()      override func viewDidLoad() {         super.viewDidLoad()         chatRoom.delegate = self // 위임 설정     }      func didReceiveMessage(_ message: String) {         print(\"받은 메시지: \\(message)\")     } }   이 실습에서는 SecondViewController 의 UITextField 에 입력받은 내용을 FirstViewController 의 UILabel 에 전달해야하므로 우리가 구현할 method 는 String 을 Parameter 로 전달 받는다.  protocol CustomTextFieldDelegate: AnyObject {     func textDidInput(text: String) }   Delegate 인스턴스 생성하기  SecondViewController에서 delegate 인스턴스를 생성한다. delegate인스턴스는 CustomTextFieldDelegate를 타입으로 가짐으로서 이 인스턴스에 접근해서 우리가 Protocol 내부에 작성해두었던 함수에 접근할 수 있게 된다.  // weak 을 사용해 ARC 가 증가하지 않도록 만들어줌으로서 메모리 Leak 이 발생하지 않도록 방지해주는 것이 중요 weak var delegate: CustomTextFieldDelegate? = nil   Protocol 채택 및 필수 method 구현  Protocol을 채택시 우리가 생성한 Protocol을 채택하고 method까지 함께 구현한다.  Protocol을 채택할 때는 반드시 Extension으로 주어야 하는 것은 아니지만 필자는 가독성이 좋다고 판단하여 Extension으로 Delegate를 채택하는 것을 선호한다.  Protocol 이 채택되고 나면 경고창이 뜨면서 필수 함수를 구현하라고 나오는데 이 때 Xcode 가 지원하는 자동에러처리를 사용하면 함수 하나가 생성된다.   /// 3 extension FirstViewController: CustomTextFieldDelegate {     func textDidInput(text: String) {         myLabel.text = text     } }   Delegate 위임하기  delegate 인스턴스를 생성했을 때 Optional 형태로 생성하였다. 이 값에 CustomTextFieldDelegate를 채택한 FirstViewController를 할당해준다.  실제 Input은 SecondViewController에서 이루어지지만 그 값에 대한 처리가 FirstViewController에서 대행하겠다는 일종의 명시이다.  위임 방법은 FirstViewController에서 화면을 present할 때 구현해놓은 nextVC의 delegate에 접근에서 설정할 수 있다  @objc func goNextView() {     let secondVC = SecondViewController()     secondVC.delegate = self     self.present(secondVC, animated: true) }   SecondViewController에서 함수가 동작해야하는 시점 설정  우리가 원하는 타이밍에 함수가 작동할 수 있도록 코드 구현. 화면을 전달하면서 값을 전달하면된다. delegate의 textDidInput함수를 호출하는 시점이 결정되었고 이제 버튼이 눌리게 되면 View 가 Dismiss 되기 전 이 함수를 호출하며 FirstViewController 가 값을 전달받게 된다. 이게 가능한 이유는 SecondViewController 가 present 되기 전 우리가 FirstViewController 를 delegate 로 설정해주었기 때문이다.  @objc private func goBack() {     let text = texxtField.text ?? \"\"     self.delegate?.textDidInput(text: text)     self.dismiss(animated: true) }   Reference     https://kasroid.github.io/posts/ios/20201010-uikit-delegate-pattern/  ","categories": [],
        "tags": ["UIKit"],
        "url": "/UIKit-delegate/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 1. 테이블뷰 예제",
        "excerpt":"테이블 뷰  테이블뷰는 dataSource와 delegate, Cell로 이루어져있다.   구성     dataSource            데이터와 관련된 부분       셀을 어떻게 보여줄 지       데이터 크기, 종류에 따른 셀의 타입 정하기       리스트 개수가 몇개인지           delegate            특정 셀 선택시 엑션과 같은 이벤트 처리 담당           Cell            테이블뷰에 들어가는 각각의 알맹이           예제 1  import UIKit  class ViewController: UIViewController {      /// Interface Builder에 연결된 테이블 뷰 아울렛     @IBOutlet weak var myTableView: UITableView!          /// 더미 데이터     var dummyDataList: [String] = [         \"hello world1\",         \"hello world2\",         \"hello world3\",         \"hello world4\",         \"hello world5\",         \"hello world6\",         \"hello world7\",         \"hello world8\",         \"hello world9\",     ]          override func viewDidLoad() {         super.viewDidLoad()                  /// 테이블 뷰의 데이터 소스, 델리겟을 현재 뷰 컨트롤러로 설정         myTableView.dataSource = self         myTableView.delegate = self     } }  /// 프로토콜은 약속이다 -&gt; 준수해야한다 /// DateSource - 데이터 관련된 부분 /// 리스트는 섹션과 섹션안에 아이템들이 있다 /// 테이블뷰에서는 섹션과 로우로 부룬다 /// /// UITableView의 데이터 관리 역할을 담당 extension ViewController: UITableViewDataSource {          /// 섹션 내 보여줄 셀의 개수를 반환     /// - section: 섹션 인덱스 (기본적으로 1개 섹션 사용 중)     /// - returns: 행(Row)의 개수     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummyDataList.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.textLabel?.text = dummyDataList[indexPath.row]                  /// 셀의 서브 타이틀 설정         cell.detailTextLabel?.text = \"테스트\"         return cell     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension ViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   예제 2     더미 데이터 활용   struct DummyData {     let uuid: UUID     let title: String     let body: String          init() {         self.uuid = UUID()         self.title = \"타이틀입니다: \\(uuid)\"         self.body = \"바디입니다: \\(uuid)\"     }          static func getDumies(_ count: Int = 100) -&gt; [DummyData] {         return (1...count).map { _ in DummyData() }     } }   import UIKit  class ViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dummyDataList: [DummyData] = DummyData.getDumies()          override func viewDidLoad() {         super.viewDidLoad()         myTableView.dataSource = self         myTableView.delegate = self     } }  extension ViewController: UITableViewDataSource {          func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummyDataList.count     }          func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")         let cellData: DummyData = dummyDataList[indexPath.row]         cell.textLabel?.text = cellData.title         cell.detailTextLabel?.text = cellData.body         return cell     } }  extension ViewController: UITableViewDelegate {     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   예제 3     섹션의 header와 footer 활용   import Foundation  struct DummySection {     let uuid: UUID     let title: String     let body: String     let rows: [DummyData]          init() {         self.uuid = UUID()         self.title = \"섹션 타이틀입니다: \\(uuid)\"         self.body = \"섹션 바디입니다: \\(uuid)\"         self.rows = DummyData.getDumies(10)     }          static func getDumies(_ count: Int = 100) -&gt; [DummySection] {         return (1...count).map { _ in DummySection() }     } }  struct DummyData {     let uuid: UUID     let title: String     let body: String          init() {         self.uuid = UUID()         self.title = \"타이틀입니다: \\(uuid)\"         self.body = \"바디입니다: \\(uuid)\"     }          static func getDumies(_ count: Int = 100) -&gt; [DummyData] {         return (1...count).map { _ in DummyData() }     } }   import UIKit  class ViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dummySections: [DummySection] = DummySection.getDumies()          override func viewDidLoad() {         super.viewDidLoad()                  myTableView.dataSource = self         myTableView.delegate = self     } }  extension ViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")         let sectionData: DummySection = dummySections[indexPath.section]         let cellData: DummyData = sectionData.rows[indexPath.row]         cell.textLabel?.text = cellData.title         cell.detailTextLabel?.text = cellData.body         return cell     } }  extension ViewController: UITableViewDelegate {     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   예제 4     Fakery 라이블러리 활용   import Foundation import Fakery  struct DummySection {     let uuid: UUID     let title: String     let body: String     let rows: [DummyData]          init() {         self.uuid = UUID()         self.title = \"섹션 타이틀입니다: \\(uuid)\"         self.body = \"섹션 바디입니다: \\(uuid)\"         self.rows = DummyData.getDumies(10)     }          static func getDumies(_ count: Int = 100) -&gt; [DummySection] {         return (1...count).map { _ in DummySection() }     } }  struct DummyData {     let uuid: UUID     let title: String     let body: String          init() {         self.uuid = UUID()         let faker = Faker(locale: \"ko\")         let firstName = faker.name.firstName()  //=&gt; \"Emilie\"         let lastName = faker.name.lastName()    //=&gt; \"Hansen\"                  let body = faker.lorem.paragraphs(amount: 10)                  self.title = \"타이틀입니다: \\(lastName) \\(firstName)\"         self.body = \"바디입니다: \\(body)\"     }          static func getDumies(_ count: Int = 100) -&gt; [DummyData] {         return (1...count).map { _ in DummyData() }     } }   import UIKit  class ViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dummySections: [DummySection] = DummySection.getDumies()          override func viewDidLoad() {         super.viewDidLoad()                  myTableView.dataSource = self         myTableView.delegate = self     } }  extension ViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")         let sectionData: DummySection = dummySections[indexPath.section]         let cellData: DummyData = sectionData.rows[indexPath.row]         cell.textLabel?.text = cellData.title         cell.detailTextLabel?.text = cellData.body         return cell     } }  extension ViewController: UITableViewDelegate {     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }  ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView1/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 2. 스토리보드로 여러 화면 분기하기",
        "excerpt":"    스토리보드로 여러 화면 분기하기      필요 파일      MainViewController   Main.storyboard   MainStoryboard에서 Command + Shift + L을 눌러서 Storyboard를 추가하고 우측 하단의 Embeded In을 눌러서 Navigation Controller(화면 이동 관할)을 추가한다.           다음으로 현재 Main스토리보드에서 어떤 화변이 먼저 실행이 될 지 정해줘야 한다. Attribute Inspector에서 is Initial View Controller 클릭해서 첫 시작 뷰 컨트롤러를 설정해준다.        filled버튼들을 추가하고 전체 버튼들을 드래그하여 Embed In 클릭 후 Stack View를 눌러준다 그러면 버튼들이 StackView로 묶인다. 버튼들을 Stack에 같은 크기로 채우려면 alignment를 fill로 해주고 Distribution은 Fill Equally로 해준다. 그 이후 StackView를 SafeArea로 드래그하여 horizontal, vertical 각각 center 지정해준다. 주황색이 뜨면 새로고침 눌러준다.      alignment(정렬)는 요소들이 한 축을 기준으로 어떻게 정렬될지를 결정한다.  horizontal stack view일 경우:     .leading → 왼쪽 정렬   .center → 가운데 정렬   .trailing → 오른쪽 정렬   .top, .bottom → 요소들의 수직 위치 정렬 방식도 있음      distribution(분배)는 여러 UI 요소를 Stack View 안에서 얼마나 넓게 어떻게 나눌지 결정한다.  .fill → 가능한 공간만큼 채움  .fillEqually → 모든 요소가 동일한 크기로 공간 분배  .fillProportionally → 각 요소의 원래 크기 비율에 따라 분배  .equalSpacing → 요소들 사이 간격을 동일하게 유지  .equalCentering → 중심점 기준으로 균등하게 배치        Default버튼을 우측 ViewController쪽으로 드래그하여 Show를 눌러준다 이때 ViewController는 CustomClass에서 Class설정을 해줘서 ViewController코드와 연결해둬야한다. 그러면 Default를 누르면 화면이동이 된다. 동일하게 나머지 버튼들도 ViewController를 만들어서 연결해준다.        완성하면 이렇게 되는데 MainStoryBoard 파일 안에서 View가 많아지게 되면 상당히 무거워지기 때문에 작업이 힘들어 진다. 추천하는 방식은 Reference 방식이다.        StoryboardList.storyboard를 만들고 만들면 제공되는 ViewController를 없앤다. 그럼 이렇게 빈 화면이 나온다. 그리고 MainStoryboard에 있는 Storyboard 타이틀 VC를 Control + X로 잘라내어 StoryboardList.storyboard에 붙여넣는다        그리고 나서 타이틀을 설정해준다. 그리고 MainStoryboard로 가서 Command + Shift + L로 reference검색해서 드래그한다. 이는 스토리보드에 대한 참조(메모리 주소)이다. 즉 이로 서로 연걸이 되게끔 할 수 있다.        스토리보드Id를 설정한다 보통 클래스이름과 동일하게 적는다. 여기서 사진에는 표시 안되어 있지만 Use StoryboardId 체크 클릭해준다.          스토리보드와 스토리보드Id를 적어준다. 그리고 Identifier도 동일하게 스토리보드Id를 적어준다.        최종적으로 참조에 드래그를 해서 show로 지정해준다. 이러면 이전의 방식과 동일한 방식이다. 이렇게 하면 작업이 용이해진다. 나머지 코드들도 동일하게 해주자.       최종화면      ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView2/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 3. 스토리보드로 커스텀 테이블뷰 구현하기",
        "excerpt":"    스토리보드로 커스텀 테이블뷰 구현하기                           기존 셀     구현할 커스텀 셀     위 왼쪽 사진은 1. 테이블뷰 예제에서 구현한 방식이다. 사진처럼 셀 스타일이 기본 셀이라서 커스텀을 할 수 없다. 그래서 보통 UITableViewCell을 상속받아 커스텀 Cell Class를 만들어 입맛대로 만든다. 커스텀 Cell 적용 방식이 1. 스토리보드, 2. Nib파일, 3. 코드 방식 총 3가지가 있는데 이번 포스팅에서는 스토리보드 방식으로 커스템 셀 구현을 진행한다.         Shift + Command + L을 눌러서 TableView를 추가하고 상하좌우 제약을 0을 주도록 설정한다. 삼각형 모양이 Size Inspector이다.         Shift + Command + L을 눌러서 Table View Cell을 드래그해준다 이를 등록 과정(register)이라고 한다. ContentView가 핵심이다. 여기에 요소들 집어넣는다. 우측상단의 Raw Height로 셀 높이를 지정할 수 있다.         상단 Label은 Leading과 Top 걸어주고 하단 Label은 상단의 Leading, Vertical Spacing 설정, Bottom도 설정해준다. 이후 상단의 leading제약을 10으로 해준다. 그리고 상단 Label의 Top 제약을 10으로 걸면 빨간 에러가 뜬다.   Label 자체는 크기를 가지고 있지 않기 때문에 상단 Label을 늘릴지 하단 Label이 늘릴지 정해줘야한다.         상단Label의 크기는 유지하고 하단 Label의 크기를 늘려서 하단 Label의 Content Hugging Priority의 Vertical을 줄이면 된다.         마무리로 모든 제약을 10으로 해준다.        긴 문장이 들어오면 number of lines가 1이라서 뒷부분이 잘린다. 해결하기 위해 상단 label의 trailing도 10 제약을 준다.           두번째 Label에도 긴문장을 넣으면 뒷부분이 잘린다. 해결을 위해 number of lines를 0으로 하고 trailing도 10 잡아준다. 이때 빨간색 줄이 생기는데 이유는 number of lines가 0이라서 계속 늘어나기 때문이다. 늘어났을 때 ContentView 사이즈공간이 모자라서 상단 Label을 밀어내려고 하기 떄문에 발생한다. 이를 해결하기 위해 Compression Resistance를 설정해야한다. 만약 하단 Label의 vertical을 751로 올리면 상단 Label이 없어진다. 그래서 상단Label을 누르고 Compression Resistance를 751로올려야한다.                     항목       설명       효과                       Content Hugging = 낮음       늘어나도 괜찮음       다른 뷰들이 먼저 자기 크기 유지                 Compression Resistance = 낮음       줄어들어도 괜찮음       다른 뷰가 먼저 자기 크기 지킴                 상단 Label Hugging 높음       상단 Label이 더 이상 안 늘어나려 함       하단 Label이 늘어남                 상단 Label Resistance 높음       상단 Label이 안 줄어들고 버팀       하단 Label이 줄어듦           🔚 정리      Hugging: “나는 커지기 싫어”(숫자 높을수록 안커짐)   Compression Resistance: “나는 작아지기 싫어”(숫자 높을수록 안작아짐)   위 두 값을 적절히 조절해주면, Auto Layout이 충돌 없이 어떤 뷰가 늘어나거나 줄어들지 결정하게 된다.        import Foundation import UIKit  class StoryboardCell: UITableViewCell {     /// 1. 셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. awakeFromNib     override class func awakeFromNib() {         /// 2. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다         super.awakeFromNib()     } }   이제 커스텀 셀을 만들어야 한다. StoryboardCell.swift파일을 만들어준다.  셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. 이 라이프사이클을 awakeFromNib라고 한다. -&gt; Interface Builder같이 스토리보드로 추가되거나 Nib파일로 되었을 경우에 awakeFromNib()가 호출된다 ViewController의 ViewDidload랑 비슷한 역할이다. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다.          Label이 드래그안될때는 당황하지말고 직접 @IBOutlet weak var로 선언해준다. 그리고 반대로 드래그해서 Label로 연결시켜주면 된다. 알고보니 StoryboardList의 StoryboardCell의 CustomClass설정을 StoryboardCell로 해줘야하는데 안되있어서 연결이 안된 것이었다. 주의하자. 이까지 완료되면 등록 과정(Register) 완료이다.      // 커스텀 셀 import Foundation import UIKit  class StoryboardCell: UITableViewCell {          @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          /// 1. 셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. awakeFromNib     override func awakeFromNib() {         /// 2. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다         super.awakeFromNib()         print(#fileID, #function, #line, \"- awakeFromNib()\")     } }   // //  StoryboardListViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/8/25. //  import UIKit  class StoryboardListViewController: UIViewController {      @IBOutlet weak var MyTableView: UITableView!          var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         super.viewDidLoad()         self.MyTableView.dataSource = self         self.MyTableView.delegate = self     } }  /// UITableView의 데이터 관리 역할을 담당 extension StoryboardListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension StoryboardListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    이제 StoryboardListViewController로 돌아와서 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) 여기서 수정한다. 기존의 let cell 부분을 주석처리하고 바로 셀을 생성하는게 아니라 테이블 뷰 자체는 메모리를 재사용한다고 했으니 재사용 셀을 설정하기 위해 dequeueReusableCell를 설정한다.현재 셀을 가져온다.   Reference      https://hanipsum.com   ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView3/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 4. Nib으로 커스텀 테이블뷰 구현하기",
        "excerpt":"    Nib으로 커스텀 테이블뷰 구현하기                           Storyboard 커스텀 셀     Nib 커스텀 셀         파일만들기 -&gt; Cocoa Toucn -&gt; Nib파일이름, 체크박스 체크로 2개의 파일을 만든다. 그러면 Nib파일과, Swift파일이 생성된다.            TitleLabel만들고 ContentView로 드래그하여 Leading, Top, Trailing을 체크해준다. 그리고 이번에는 타이틀 Label의 number of lines를 1로 하자.            BodyLabel을 TitleLabel로 드래그하여 Leading, Vertical Spacing 체크해준다.   그리고 BodyLabel을 ContentView로 드래그하여 Trailing을 채크해준다.(TitleLabel은 한줄이라서..?)               Identifier, Class 설정해준다.             import UIKit  class NibCell: UITableViewCell {     @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          override func awakeFromNib() {         super.awakeFromNib()         self.backgroundColor = .systemMint     } }   IBOutlet 추가한다.                NibListStoryboard에서 테이블만들고 My Table View 이름 지정.해준다. 그리고 이를 NibListViewController에 드래그하여 myTableView만들어준다.          fileprivate func configureTableView() {      // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.     let cellNib = UINib(nibName: \"NibCell\", bundle: nil)     self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")      self.myTableView.dataSource = self     self.myTableView.delegate = self }   이대로 실행하면 에러가난다. Storyboard 방식과 달리 Nib 방식으로 할때는 등록 절차를 직접 해줘야 한다.          전체코드   NibCell.xib      NibCell.swift   // //  NibCell.swift //  UITableViewTutorial // //  Created by 김동현 on 5/11/25. //  import UIKit  class NibCell: UITableViewCell {           @IBOutlet weak var titleLabel: UILabel!          @IBOutlet weak var bodyLabel: UILabel!          override func awakeFromNib() {         super.awakeFromNib()         self.backgroundColor = .systemMint     }      /*     override func setSelected(_ selected: Bool, animated: Bool) {         super.setSelected(selected, animated: animated)          // Configure the view for the selected state     }      */ }    NibListViewController   // //  NibListViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/8/25. //  import UIKit  class NibListViewController: UIViewController {           @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.         let cellNib = UINib(nibName: \"NibCell\", bundle: nil)         self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }  /// UITableView의 데이터 관리 역할을 담당 extension NibListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"NibCell\", for: indexPath) as? NibCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension NibListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView4/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 5. 코드기반 커스텀 테이블뷰 구현하기",
        "excerpt":"    코드기반 커스텀 테이블뷰 구현하기                                  Storyboard 커스텀 셀     Nib 커스텀 셀       Code 커스텀 셀         CodeList.xiv파일로 와서 테이블뷰를 드래그해서 추가 후 제약조건을 상하좌우 전부 0으로 해준다.         myTableView를 ViewController로 드래그해서 IBOutlet 추가한다. 이떄 추가가안되면 xib파일의 viewController가 연결되있는지 확인한다.      CodeCell.swift   // //  CodeCell.swift //  UITableViewTutorial // //  Created by 김동현 on 5/11/25. //  import UIKit  class CodeCell: UITableViewCell {          lazy var titleLabel: UILabel = {         let label = UILabel()         label.translatesAutoresizingMaskIntoConstraints = false         label.text = \"타이틀 라벨타이틀 라벨타이틀 라벨타이틀 라벨타이틀 라벨\"         label.numberOfLines = 1         label.font = UIFont.systemFont(ofSize: 14, weight: .bold)         return label     }()          lazy var bodyLabel: UILabel = {         let label = UILabel()         label.translatesAutoresizingMaskIntoConstraints = false         label.text = \"바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨\"         label.numberOfLines = 0         label.font = UIFont.systemFont(ofSize: 12, weight: .regular)         return label     }()          fileprivate func configureUI() {         self.backgroundColor = .systemYellow                  // 타이틀 라벨 설정         self.contentView.addSubview(self.titleLabel)         NSLayoutConstraint.activate([             titleLabel.topAnchor.constraint(equalTo: self.contentView.topAnchor, constant: 10),             titleLabel.leadingAnchor.constraint(equalTo: self.contentView.leadingAnchor, constant: 10),             titleLabel.trailingAnchor.constraint(equalTo: self.contentView.trailingAnchor, constant: -10),         ])                  // 바디 라벨 설정         self.contentView.addSubview(self.bodyLabel)         NSLayoutConstraint.activate([             bodyLabel.topAnchor.constraint(equalTo: self.titleLabel.bottomAnchor, constant: 10),             bodyLabel.leadingAnchor.constraint(equalTo: self.contentView.leadingAnchor, constant: 10),             bodyLabel.trailingAnchor.constraint(equalTo: self.contentView.trailingAnchor, constant: -10),             bodyLabel.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -10)         ])     }          // 원래는 awakefromnib을 타지만 코드로 UI를 진행한다면 awakefromnib을 타지 않는다.     override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {         super.init(style: style, reuseIdentifier: reuseIdentifier) /// 부모의 로직을 싱행시키는 의미         configureUI()     }          required init?(coder: NSCoder) {         super.init(coder: coder)     }          override func layoutSubviews() {         super.layoutSubviews()     } }    #if DEBUG import SwiftUI  extension UIView {     private struct ViewRepresentable: UIViewRepresentable {         let uiView: UIView         func updateUIView(_ uiView: UIViewType, context: Context) {         }         func makeUIView(context: Context) -&gt; some UIView {             uiView         }     }          func getPreview() -&gt; some View {         ViewRepresentable(uiView: self)     } } #endif  #if DEBUG import SwiftUI  struct CodeCell_PreviewProvider_Previews: PreviewProvider {     static var previews: some View {         CodeCell().getPreview()             .previewLayout(.fixed(width: 200, height: 100))     } } #endif    CodeListViewController   // //  CodeListViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/8/25. //  import UIKit  class CodeListViewController: UIViewController {           @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)         override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CodeCell.self, forCellReuseIdentifier: \"CodeCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   /// UITableView의 데이터 관리 역할을 담당 extension CodeListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CodeCell\", for: indexPath) as? CodeCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension CodeListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    참고: 테이블뷰도 완전 코드베이스로 하는법   // //  MainViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/8/25. //  import UIKit  class MainViewController: UIViewController {           override func viewDidLoad() {         super.viewDidLoad()         print(\"MainViewController loaded\")     }          @IBAction func codeButtonTapped(_ sender: UIButton) {         print(\"눌림\")         let vc = OnlyCodeBaseViewController()         self.navigationController?.pushViewController(vc, animated: true)     } }    // //  OnlyCodeBaseViewController.swift //  UITableViewTutorial // //  Created by 김동현 on 5/11/25. //  import UIKit  class OnlyCodeBaseViewController: UIViewController {          private let myTableView: UITableView = {         let tableView = UITableView()         tableView.translatesAutoresizingMaskIntoConstraints = false         return tableView     }()          private func setupTableView() {         view.addSubview(myTableView)         NSLayoutConstraint.activate([             myTableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),             myTableView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),             myTableView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),             myTableView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)         ])     }          private func configureTableView() {         myTableView.register(CodeCell.self, forCellReuseIdentifier: \"CodeCell\")         myTableView.dataSource = self         myTableView.delegate = self     }          var dummySections: [DummySection] = DummySection.getDumies(10)      override func viewDidLoad() {         super.viewDidLoad()         view.backgroundColor = .white         setupTableView()         configureTableView()     } }  /// UITableView의 데이터 관리 역할을 담당 extension OnlyCodeBaseViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CodeCell\", for: indexPath) as? CodeCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension OnlyCodeBaseViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView5/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 6. Cell Configuration",
        "excerpt":"    Cell Configuration 알아보기   Cell Configuration은 iOS 14+부터 도입된 기능으로, 셀의 UI 구성과 데이터 설정을 보다 선언적으로 처리할 수 있도록 도와준다.   기존에는 셀마다 IBOutlet을 연결하거나, cell.textLabel.text = ... 방식으로 직접 설정했지만,    Cell Configuration은 UI와 데이터를 분리하고 설정 구조체를 통해 셀 내부 뷰를 생성 및 업데이트하는 구조다.    화면 구성 예시         테이블뷰를 스토리보드에서 추가하고, 상하좌우 제약을 0으로 설정한다               Storyboard ID는 CellConfigurationListViewController로 지정   Reference ID도 동일하게 맞춰야 코드에서 호출 가능     구성   Cell Configuration을 구성하는 핵심 요소는 다음과 같다:                  요소       설명                       UIContentConfiguration       데이터 설정을 위한 구조체 역할 (예: MyCellConfiguration)                 UIContentView       실제 UI를 그리는 뷰 (예: CellConfigurationView)                 UITableViewCell       시스템이 자동으로 UIContentView를 삽입해주는 셀 컨테이너 (CellConfigTableViewCell)             1. MyCellConfiguration.swift   struct MyCellConfiguration: UIContentConfiguration, Hashable {     var title: String = \"\"     var body: String = \"\"      func makeContentView() -&gt; UIView &amp; UIContentView {         return CellConfigurationView(config: self)     }      func updated(for state: UIConfigurationState) -&gt; MyCellConfiguration {         var updated = self         if let state = state as? UICellConfigurationState, state.isSelected {             updated.title = \"선택됨: \" + updated.title         }         return updated     } }      데이터(title, body)를 담고 있고, 상태(state)에 따라 동적으로 내용도 바꿀 수 있다.   makeContentView()를 통해 실제 UIContentView (CellConfigurationView) 생성     2. CellConfigurationView.swift   class CellConfigurationView: UIView, UIContentView {     var configuration: UIContentConfiguration {         get { customConfiguration }         set {             if let config = newValue as? MyCellConfiguration {                 applyConfig(config)             }         }     }      init(config: MyCellConfiguration) {         super.init(frame: .zero)         configureUI()         applyConfig(config)     }      fileprivate func applyConfig(_ config: MyCellConfiguration) {         self.customConfiguration = config         titleLabel.text = config.title         bodyLabel.text = config.body     } }      UIView이자 UIContentView를 채택   외부에서 전달받은 MyCellConfiguration을 적용해서 UILabel에 반영   내부적으로 titleLabel, bodyLabel을 AutoLayout으로 배치     3. CellConfigTableViewCell.swift   class CellConfigTableViewCell: UITableViewCell {     var title: String = \"\" {         didSet { setNeedsUpdateConfiguration() }     }      var body: String = \"\" {         didSet { setNeedsUpdateConfiguration() }     }      override func updateConfiguration(using state: UICellConfigurationState) {         var config = MyCellConfiguration().updated(for: state)         config.title = title         config.body = body         self.contentConfiguration = config     } }      setNeedsUpdateConfiguration() 호출 시 시스템이 updateConfiguration(using:)을 호출   title, body를 가지고 MyCellConfiguration을 만든 뒤 contentConfiguration에 설정   시스템은 이 설정을 보고 자동으로 CellConfigurationView를 생성 및 삽입     4. CellConfigurationListViewController.swift   func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {     guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CellConfigTableViewCell\", for: indexPath) as? CellConfigTableViewCell else {         return UITableViewCell()     }      let cellData = dummySections[indexPath.section].rows[indexPath.row]     cell.title = cellData.title     cell.body = cellData.body     return cell }      더미 데이터를 불러와 title, body만 할당하면 자동으로 UI가 구성된다   직접적으로 UILabel에 접근하거나 cell.subviews를 조작하지 않아도 된다     전체 예제 코드   1. MyCellConfiguration.swift   import UIKit  // 커스텀 셀에 대한 설정 struct MyCellConfiguration: UIContentConfiguration, Hashable {          var title: String = \"\"     var body: String = \"\"          // 보여줄 화면     // UIView이면서 UIContentView인 애를 반화내라     func makeContentView() -&gt; any UIView &amp; UIContentView {         return CellConfigurationView(config: self)     }               /// 셀 상태가 변경되면 발동     /// - Parameter state: 셀 상태     /// - Returns: 셀 설정 자체     func updated(for state: any UIConfigurationState) -&gt; MyCellConfiguration {         if let state = state as? UICellConfigurationState {             var updatedConfig = self                          if state.isSelected {                 updatedConfig.title = \"선택됨: \" + updatedConfig.title             }             return updatedConfig         }         return self     } }   2. CellConfigurationView.swift   import UIKit  // 뷰 안에 컨텐츠 Config를 가지고 있는 뷰 class CellConfigurationView: UIView, UIContentView {          // 여러 데이터를 가진 덩어리     fileprivate var customConfiguration: MyCellConfiguration!          // 데이터와 UI를 연결     fileprivate func applyConfigAndChangeUI(_ newConfiguration: MyCellConfiguration) {         self.customConfiguration = newConfiguration         titleLabel.text = newConfiguration.title         bodyLabel.text = newConfiguration.body     }          var configuration: UIContentConfiguration {         get { customConfiguration }         set {             if let newConfiguration = newValue as? MyCellConfiguration {                 applyConfigAndChangeUI(newConfiguration)             }         }     }         init(config: MyCellConfiguration) {         super.init(frame: .zero)         configureUI()         applyConfigAndChangeUI(config)     }      lazy var titleLabel: UILabel = {         let label = UILabel()         label.translatesAutoresizingMaskIntoConstraints = false         label.text = \"타이틀 라벨타이틀 라벨타이틀 라벨타이틀 라벨타이틀 라벨\"         label.numberOfLines = 1         label.textColor = .white         label.font = UIFont.systemFont(ofSize: 14, weight: .bold)         return label     }()          lazy var bodyLabel: UILabel = {         let label = UILabel()         label.translatesAutoresizingMaskIntoConstraints = false         label.text = \"바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨바디 라벨\"         label.numberOfLines = 0         label.textColor = .white         label.font = UIFont.systemFont(ofSize: 12, weight: .regular)         return label     }()          fileprivate func configureUI() {         self.backgroundColor = .systemBlue                  // 타이틀 라벨 설정         self.addSubview(self.titleLabel)         NSLayoutConstraint.activate([             titleLabel.topAnchor.constraint(equalTo: self.topAnchor, constant: 10),             titleLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 10),             titleLabel.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: -10),         ])                  // 바디 라벨 설정         self.addSubview(self.bodyLabel)         NSLayoutConstraint.activate([             bodyLabel.topAnchor.constraint(equalTo: self.titleLabel.bottomAnchor, constant: 10),             bodyLabel.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 10),             bodyLabel.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: -10),             bodyLabel.bottomAnchor.constraint(equalTo: self.bottomAnchor, constant: -10)         ])     }          required init?(coder: NSCoder) {         super.init(coder: coder)     }          override func layoutSubviews() {         super.layoutSubviews()     } }  #if DEBUG import SwiftUI  struct CellConfigurationView_PreviewProvider_Previews: PreviewProvider {     static var previews: some View {         CellConfigurationView(config: MyCellConfiguration(title: \"오늘도 코딩\", body: \"바디부분\")).getPreview()             .previewLayout(.fixed(width: 200, height: 100))     } } #endif   3. CellConfigTableViewCell.swift   import UIKit  // 기존 테이블뷰 셀은 데이터만 신경쓰면 됨 class CellConfigTableViewCell: UITableViewCell {          // 데이터 변경시 UI 변경해라     var title: String = \"\" {         didSet {             setNeedsUpdateConfiguration()         }     }          var body: String = \"\" {         didSet {             setNeedsUpdateConfiguration()         }     }      override func updateConfiguration(using state: UICellConfigurationState) {         super.updateConfiguration(using: state)                  var contentConfig = MyCellConfiguration().updated(for: state)         contentConfig.title = title         contentConfig.body = body         self.contentConfiguration = contentConfig     }          override func layoutSubviews() {         super.layoutSubviews()     } }  #if DEBUG import SwiftUI  struct CellConfigTableViewCell_PreviewProvider_Previews: PreviewProvider {     static var previews: some View {         CodeCell().getPreview()             .previewLayout(.fixed(width: 200, height: 100))     } } #endif   4. CellConfigurationListViewController.swift   import UIKit  class CellConfigurationListViewController: UIViewController {          @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         configureTableView()     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: \"CellConfigTableViewCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   /// UITableView의 데이터 관리 역할을 담당 extension CellConfigurationListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CellConfigTableViewCell\", for: indexPath) as? CellConfigTableViewCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         // cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         // cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0                  // 여기서는 UI에 접근하는게 아니라 Cell이 가지고 있는 멤버변수 데이터 자체에 접근         cell.title = cellData.title         cell.body = cellData.body         return cell     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension CellConfigurationListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }  ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView6/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 7. UITableViewCell 확장을 통해 셀 식별자 코드 재사용",
        "excerpt":"    코드 재사용   /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라 /// - indexPath: 셀의 위치를 나타내는 인덱스 경로 /// - returns: 구성된 UITableViewCell 객체 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {     /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)     /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")      // [guard let] 방식     guard let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell else {         return UITableViewCell()     }      let sectionData: DummySection = dummySections[indexPath.section]      let cellData: DummyData = sectionData.rows[indexPath.row]      /// 셀의 주 텍스트를 더미 데이터에서 가져오기     cell.titleLabel.text = cellData.title      /// 셀의 서브 타이틀 설정     cell.bodyLabel.text = cellData.body      //cell.detailTextLabel?.numberOfLines = 0     return cell }   지금까지 재사용되는 셀은 고유한 식별자를 상수로 넣어주는데 보통 클래스 명을 써주었다.   프로그래밍 하면서 상수가 있는 부분은 최대한 피하는게 좋다. 이유는 상수를 재사용할 수도 있고 오타가 발생할 수 있기 때문이다.      class StoryboardCell: UITableViewCell {          // 변수로     static let reuseIdentifier: String = \"StoryboardCell\"          @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          /// 1. 셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. awakeFromNib     override func awakeFromNib() {         /// 2. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다         super.awakeFromNib()         print(#fileID, #function, #line, \"- awakeFromNib()\")         self.backgroundColor = .systemYellow     } }   guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {     return UITableViewCell() }   그래서 셀에서 static으로 상수로 추가해둔다. 이 방법도 충분하지만 조금 더 편하게 할 수 있다.  UITableviewCell 자체가 전부 reuseIdentifier라는 static변수를 가질 수 있게 하면 더 편리해질 수 있다.       extension UITableViewCell {     static var reuseIdentifier: String {         return String(describing: Self.self) // 현재 타입.현재 타입의 타입 그자체, 현재 타입의 타입 객체(메타타입)     } }    참고로 확장에서는 저장 속성을 정의할 수 없음으로 계산 속성으로 변경해준다.       extension UITableViewCell {     static var reuseIdentifier: String {         return String(describing: Self.self) // 현재 타입.현재 타입의 타입 그자체, 현재 타입의 타입 객체(메타타입)     } }  extension UICollectionView {     static var reuseIdentifier: String {         return String(describing: Self.self) // 현재 타입.현재 타입의 타입 그자체, 현재 타입의 타입 객체(메타타입)     } }   하지만 이 방식도 UItableView, UICollectionVIew각각마다 만들어줘야하는 불편함이 있다.  반복을 더 줄일 수 있다.      protocol ReuseIdentifiable {     // 프로토콜에서 로직을 정의할 수 없어서 가져올 수 있도록 설정     static var reuseIdentifier: String { get } }  extension ReuseIdentifiable {     // 로직에 대한 정의는 Extension에서 간능     static var reuseIdentifier: String {         return String(describing: Self.self)     } }  // ReuseIdentifiable 채택 class StoryboardCell: UITableViewCell, ReuseIdentifiable {      @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          override func awakeFromNib() {         super.awakeFromNib()         print(#fileID, #function, #line, \"- awakeFromNib()\")         self.backgroundColor = .systemYellow     } }   프로토콜을 활용해서 해결하자. 프로토콜 이름은 아래 컨벤션을 따르면 좋다.  https://www.swift.org/documentation/api-design-guidelines/      class NibListViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.         let cellNib = UINib(nibName: \"NibCell\", bundle: nil)         self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   이를 활용하면 Nib파일을 등록할때도 적용할 수 있다. NibCell을 상수로 사용하지 않고 프로토로 해결해보자.      최종 코드   import UIKit  protocol Nibbed {     static var uinib: UINib { get } }  extension Nibbed {     static var uinib: UINib {         return UINib(nibName: String(describing: Self.self), bundle: nil)     } }  protocol ReuseIdentifiable {     // 프로토콜에서 로직을 정의할 수 없어서 가져올 수 있도록 설정     static var reuseIdentifier: String { get } }  extension ReuseIdentifiable {     // 로직에 대한 정의는 Extension에서 간능     static var reuseIdentifier: String {         return String(describing: Self.self)     } }  extension UITableViewCell: Nibbed, ReuseIdentifiable {}  class NibListViewController: UIViewController {          @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDumies(10)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.         // let cellNib = UINib(nibName: \"NibCell\", bundle: nil)                  // self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")         self.myTableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView7/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "[TableView] 8. 데이터 소스 이해, 따로써보기",
        "excerpt":"    8. 데이터 소스 이해, 따로써보기   테이블 뷰 만들기(List)      테이블뷰 컨트롤러로 만들기(기능이 한정적) vs 일반 뷰 컨트롤러로 만들기   우리는 일반 뷰 컨트롤러를 주로 쓰자   구성                     데이터 소스 - 데이터와 연관, 셀의 종류를 정하기, 보여줄 셀의 개수가 몇개인지 정하기             class viewController: UIViewController {}            extension viewController: UITableViewDataSource {       /// 섹션 내의 셀 개수를 반환하는 메서드       /// - Parameters:       ///   - tableView: 데이터를 표시할 테이블 뷰       ///   - section: 현재 섹션 인덱스       /// - Returns: 해당 섹션에 표시할 행(row)의 개수       func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {           // 예: return items.count       }                    /// 각 행에 표시될 셀을 반환하는 메서드       /// - Parameters:       ///   - tableView: 셀을 표시할 테이블 뷰       ///   - indexPath: 현재 행의 위치 정보 (섹션, row)       /// - Returns: 구성된 UITableViewCell 객체       func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {           // 예:           // let cell = tableView.dequeueReusableCell(withIdentifier: \"CellIdentifier\", for: indexPath)           // cell.textLabel?.text = items[indexPath.row]           // return cell       }   }                       델리겟 - 이벤트 처리(특정 셀 선택) = 테이블뷰에 대한 액션       셀 - 테이블뷰에 들어가는 알맹이           DataSource를 따로 빼보기   기존 코드   Cell 파일은 수정 x   protocol Nibbed {     static var uinib: UINib { get } }  extension Nibbed {     static var uinib: UINib {         return UINib(nibName: String(describing: Self.self), bundle: nil)     } }  protocol ReuseIdentifiable {     // 프로토콜에서 로직을 정의할 수 없어서 가져올 수 있도록 설정     static var reuseIdentifier: String { get } }  extension ReuseIdentifiable {     // 로직에 대한 정의는 Extension에서 간능     static var reuseIdentifier: String {         return String(describing: Self.self)     } }  extension UITableViewCell: Nibbed {} extension UITableViewCell : ReuseIdentifiable { } extension UITableViewHeaderFooterView : ReuseIdentifiable {}  class StoryboardCell: UITableViewCell {          // 변수로     //static let reuseIdentifier: String = \"StoryboardCell\"          @IBOutlet weak var titleLabel: UILabel!     @IBOutlet weak var bodyLabel: UILabel!          /// 1. 셀을 스토리보드에 추가하거나 Nib파일에 추가하게 되면 이 자체의 라이프사이클이 생긴다. awakeFromNib     override func awakeFromNib() {         /// 2. 상속을 한것이기 때문에 부모에 있는 awakeFromNib 로직을 터트려줘야한다         super.awakeFromNib()         print(#fileID, #function, #line, \"- awakeFromNib()\")         self.backgroundColor = .systemYellow     } }   import UIKit  class StoryboardListViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dummySections: [DummySection] = DummySection.getDummies(10)          override func viewDidLoad() {         super.viewDidLoad()         self.myTableView.dataSource = self         self.myTableView.delegate = self     } }  /// UITableView의 데이터 관리 역할을 담당 extension StoryboardListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension StoryboardListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   수정된 코드   import UIKit  class MyDataSource: NSObject, UITableViewDataSource {          var dummySections: [DummySection] = DummySection.getDummies()          override init() {         super.init()     }          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell     } }    import UIKit  class StoryboardListViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dataSource: MyDataSource = MyDataSource()          override func viewDidLoad() {         super.viewDidLoad()         self.myTableView.dataSource = dataSource         self.myTableView.delegate = self     } }   /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension StoryboardListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   NibListViewController도 MyDataSource로수정 가능   기존 코드   import UIKit  class NibListViewController: UIViewController {           @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDummies(10)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {                  // storyboard에서는 테이블뷰에서 셀을 직접 드래그하기때문에 등록이 되지만 Nib 방식에서 등록을 시켜줘야한다.         // let cellNib = UINib(nibName: \"NibCell\", bundle: nil)                  // self.myTableView.register(cellNib, forCellReuseIdentifier: \"NibCell\")         self.myTableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }  /// UITableView의 데이터 관리 역할을 담당 extension NibListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"NibCell\", for: indexPath) as? NibCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0         return cell                  /*         [if let] 방식         if let cell = tableView.dequeueReusableCell(withIdentifier: \"StoryBoardCell\", for: indexPath) as? StoryboardCell {             let sectionData: DummySection = dummySections[indexPath.section]                          let cellData: DummyData = sectionData.rows[indexPath.row]                          /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.titleLabel.text = cellData.title                          /// 셀의 서브 타이틀 설정             cell.bodyLabel.text = cellData.body                          //cell.detailTextLabel?.numberOfLines = 0             return cell         } else {             return UITableViewCell()         }         */     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension NibListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    수정된 코드   import UIKit  class MyDataSource: NSObject, UITableViewDataSource {          enum ListType {         case storyboard         case nib         case code         case cellConfig     }          var listType: ListType = .storyboard          var dummySections: [DummySection] = DummySection.getDummies()          override init() {         super.init()     }          convenience init(type: ListType = .storyboard) {         self.init()         self.listType = type     }          // MARK: - 셀을 등록하는 소스 관련     /// 셀을 등록     /// 스토리보드에서 셀을 추가하면 Xcode가 내부적으로 셀을 자동 등록한다     /// 이코드가 자동 등록된다고 생각 tableView.dequeueReusableCell(withIdentifier: \"StoryboardCell\")     /// - Parameter tableView: 등록할 테이블뷰     func registerCells(with tableView: UITableView) {         tableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)     }          // MARK: -  테이블뷰 데이터 소스 관련     /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식                  switch listType {         case .storyboard:             guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .nib:             guard let cell = tableView.dequeueReusableCell(withIdentifier: NibCell.reuseIdentifier, for: indexPath) as? NibCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .code:             guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .cellConfig:             guard let cell = tableView.dequeueReusableCell(withIdentifier: CellConfigTableViewCell.reuseIdentifier, for: indexPath) as? CellConfigTableViewCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.title = cellData.title             cell.body = cellData.body             return cell         }     } }   import UIKit  class NibListViewController: UIViewController {      @IBOutlet weak var myTableView: UITableView!          var dataSource: MyDataSource = MyDataSource(type: .nib)          override func viewDidLoad() {         super.viewDidLoad()         configureTableView()     }          fileprivate func configureTableView() {         // self.myTableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                  // 셀을 등록         self.dataSource.registerCells(with: myTableView)         self.myTableView.dataSource = dataSource         self.myTableView.delegate = self     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension NibListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   CellConfigurationListViewController도 MyDataSource로수정 가능   기존 코드   import UIKit  class CellConfigurationListViewController: UIViewController {          @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDummies(10)          override func viewDidLoad() {         configureTableView()     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요         self.myTableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: \"CellConfigTableViewCell\")                  self.myTableView.dataSource = self         self.myTableView.delegate = self     } }   /// UITableView의 데이터 관리 역할을 담당 extension CellConfigurationListViewController: UITableViewDataSource {          /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식         guard let cell = tableView.dequeueReusableCell(withIdentifier: \"CellConfigTableViewCell\", for: indexPath) as? CellConfigTableViewCell else {             return UITableViewCell()         }                  let sectionData: DummySection = dummySections[indexPath.section]                  let cellData: DummyData = sectionData.rows[indexPath.row]                  /// 셀의 주 텍스트를 더미 데이터에서 가져오기         // cell.titleLabel.text = cellData.title                  /// 셀의 서브 타이틀 설정         // cell.bodyLabel.text = cellData.body                  //cell.detailTextLabel?.numberOfLines = 0                  // 여기서는 UI에 접근하는게 아니라 Cell이 가지고 있는 멤버변수 데이터 자체에 접근         cell.title = cellData.title         cell.body = cellData.body         return cell     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension CellConfigurationListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }    수정된 코드   import UIKit  class MyDataSource: NSObject, UITableViewDataSource {          enum ListType {         case storyboard         case nib         case code         case cellConfig     }          var listType: ListType = .storyboard          var dummySections: [DummySection] = DummySection.getDummies(10)          override init() {         super.init()     }          convenience init(type: ListType = .storyboard) {         self.init()         self.listType = type     }          // MARK: - 셀을 등록하는 소스 관련     /// 셀을 등록     /// 스토리보드에서 셀을 추가하면 Xcode가 내부적으로 셀을 자동 등록한다     /// 이코드가 자동 등록된다고 생각 tableView.dequeueReusableCell(withIdentifier: \"StoryboardCell\")     /// - Parameter tableView: 등록할 테이블뷰     func registerCells(with tableView: UITableView) {         /// Nib 방식으로 만든 셀(NibCell.xib 파일)을 테이블 뷰에 등록         /// - NibCell.uinib : UINib(nibName: \"NibCell\", bundle: nil) 을 반환         /// - NibCell.reuseIdentifier : \"NibCell\" 문자열을 반환 (보통 클래스명을 기반으로 자동 생성)         /// → 이후 dequeue 시 이 identifier로 셀을 재사용할 수 있게 됨         /// tableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                  /// 코드로만 구현된 셀 클래스를 테이블 뷰에 등록         /// - CellConfigTableViewCell.self : 클래스 자체를 등록         /// - reuseIdentifier : \"CellConfigTableViewCell\" 문자열         /// → register(class:) 방식은 .xib 없이 순수 코드로 UI 구성한 셀에 사용         /// tableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: CellConfigTableViewCell.reuseIdentifier)         switch listType {         case .nib:             tableView.register(NibCell.uinib, forCellReuseIdentifier: NibCell.reuseIdentifier)                      case .code:             tableView.register(CodeCell.self, forCellReuseIdentifier: CodeCell.reuseIdentifier)                      case .cellConfig:             tableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: CellConfigTableViewCell.reuseIdentifier)                      case .storyboard:             // ❌ 스토리보드는 register 필요 없음!             break         }     }          // MARK: -  테이블뷰 데이터 소스 관련     /// 섹션이 여러개일때만 사용     /// 섹션의 타이틀 설정     func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {         return \"헤더: \" + dummySections[section].title     }          func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {         return \"푸터: \" + dummySections[section].title     }          /// 섹션이 여러개일때만 사용     /// 현재 섹션이 몇개인지     func numberOfSections(in tableView: UITableView) -&gt; Int {         return dummySections.count     }          /// 하나의 섹션에 몇개의 rows가 있냐     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return dummySections[section].rows.count     }          /// 각 셀에 대한 내용을 구성하여 반환 -&gt; 셀의 종류를 정하기 - 테이블뷰 셀을 만들어서 반환해라     /// - indexPath: 셀의 위치를 나타내는 인덱스 경로     /// - returns: 구성된 UITableViewCell 객체     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         /// 기본 스타일의 셀 생성 (textLabel과 detailTextLabel 포함)         /// let cell = UITableViewCell(style: .subtitle, reuseIdentifier: \"MyCell\")                  // [guard let] 방식                  switch listType {         case .storyboard:             guard let cell = tableView.dequeueReusableCell(withIdentifier: StoryboardCell.reuseIdentifier, for: indexPath) as? StoryboardCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .nib:             guard let cell = tableView.dequeueReusableCell(withIdentifier: NibCell.reuseIdentifier, for: indexPath) as? NibCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .code:             guard let cell = tableView.dequeueReusableCell(withIdentifier: CodeCell.reuseIdentifier, for: indexPath) as? CodeCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.titleLabel.text = cellData.title /// 셀의 주 텍스트를 더미 데이터에서 가져오기             cell.bodyLabel.text = cellData.body   /// 셀의 서브 타이틀 설정             return cell         case .cellConfig:             guard let cell = tableView.dequeueReusableCell(withIdentifier: CellConfigTableViewCell.reuseIdentifier, for: indexPath) as? CellConfigTableViewCell else {                 return UITableViewCell()             }             let sectionData: DummySection = dummySections[indexPath.section]             let cellData: DummyData = sectionData.rows[indexPath.row]             cell.title = cellData.title             cell.body = cellData.body             return cell         }     } }   import UIKit  class CellConfigurationListViewController: UIViewController {          @IBOutlet weak var myTableView: UITableView!     var dummySections: [DummySection] = DummySection.getDummies(10)     var dataSource: MyDataSource = MyDataSource(type: .cellConfig)          override func viewDidLoad() {         configureTableView()     }          fileprivate func configureTableView() {                  // CodeCell에서는 이 줄만 필요 //        self.myTableView.register(CellConfigTableViewCell.self, forCellReuseIdentifier: \"CellConfigTableViewCell\")                  self.dataSource.registerCells(with: myTableView)         self.myTableView.dataSource = dataSource         self.myTableView.delegate = self     } }  /// 이벤트 관련 부분 - 셀 선택 등 사용자 인터랙션(이벤트) 관련 처리 extension CellConfigurationListViewController: UITableViewDelegate {     /// 사용자가 특정 셀을 선택했을 때 호출되는 메서드     /// - Parameters:     ///   - tableView: 이벤트가 발생한 테이블 뷰     ///   - indexPath: 선택된 셀의 위치     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {         print(#fileID, #function, #line, \"- indexPath: \\(indexPath.row)\")     } }   ","categories": [],
        "tags": ["UIKit","TableView"],
        "url": "/UIKit-tableView8/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "Star Bridge: 생일카페 알리미",
        "excerpt":"소개      서비스 설명: K-pop 팬들을 위한 생일카페 정보를 자동으로 수집하고, 알림으로 제공하는 스케줄 앱   프로젝트 유형: 팀 프로젝트 (졸업작품)   개발 기간: 24.03 ~ 24.12   Github 링크: https://github.com/indextrown/senior-project   기술 스택: SwiftUI, Selenium, AWS EC2, Firebase   기여한 부분     SNS 기반 생일카페 스케줄 자동화 시스템 설계 및 구현   도입 배경  Swift를 배우기 시작하던 시기에 졸업 프로젝트에 합류하게 되어 앱 UI 구현보다는 시스템 개발 파트에 더 집중할 수 있었습니다.    크롤링 → GPT로 데이터 정제 → API 연동으로 백엔드 중심의 구조를 직접 설계하며, 정보를 어떻게 모으고, 걸러내고, 사용자에게 전달할지를 하나의 흐름으로 구현해보는 데 초점을 맞췄습니다.   해결 방법          크롤링 자동화            로그인 및 차단 문제 해결을 위해, 수동 로그인 후 발급한 쿠키를 저장하고 이를 크롤링 시 재사용하여 안정성 확보.           GPT 기반 정보 정제            크롤링된 게시물에서 연예인 이름, 날짜, 장소를 GPT API로 추출.           Google Maps API 장소 검증            GPT가 추출한 장소를 지도 API로 확인, 유효하지 않은 데이터는 자동 제외.           실시간 앱 연동            1~3단계 결과를 AWS EC2 서버에서 30분 주기로 자동화.       정제된 데이터를 MySQL에 저장하고, SwiftUI 앱에서 실시간 조회 가능하게 구성.           성과      2024 한국멀티미디어학회 Best Paper 수상.   SNS 크롤링 → GPT 정제 → 장소 검증 → 앱 연동까지 자동화 파이프라인 완성.   데이터 정확도 98.0%, 알림 98.5% 달성.   Swift 학습 초기였지만, 앱과 서버를 연동하고 데이터 흐름을 설계하며 실질적인 서비스 구축 경험 쌓음.  ","categories": [],
        "tags": ["SwiftUI","Selenium","AWS EC2","Firebase"],
        "url": "/projects/star-bridge/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "반창고: 건강 관리 앱",
        "excerpt":"소개      서비스 설명: 주변 약국 위치를 지도에서 확인하고, 걸음 수와 칼로리를 기록·조회할 수 있는 건강 관리 앱   프로젝트 유형: 개인 프로젝트   개발 기간: 24.11 ~ 24.12   Github 링크: https://github.com/indextrown/Ban-Chang-Go   기술 스택: SwiftUI, MapKit, CoreLocation, CoreMotion, Firebase   기여한 부분     약국 운영 여부 포함 리스트 구성 (async / await 기반 연쇄 API 흐름 구조)   도입 배경     위치 기반 약국 API는 약국명과 위치만 제공하고 실제 운영 중인지 알 수 없었습니다.   반면 운영 여부 API는 약국 이름만 검색이 가능해 단독으로는 사용할 수 없었습니다.   사용자에게 실시간으로 문을 연 약국만 보여주기 위해 두 API의 흐름을 연결하는 구조가 필요했습니다.   해결 방법      위치 API로 받은 약국 리스트를 기준으로, 운영 여부 API를 순차 호출하는 구조 설계.   지도 이동 시 과도한 호출은 DispatchWorkItem과 Debounce로 조정.   이미 조회한 약국은 Set에 저장해 중복 호출 방지.   성과      운영 중인 약국은 빨간 핀, 종료 약국은 회색 핀으로 표시해 직관성 향상.   지도 이동 시 API 중복 호출을 차단해, 핀 렌더링 속도를 평균 1.2초 → 0.4초로 단축.  ","categories": [],
        "tags": ["SwiftUI","MapKit","CoreLocation","CoreMotion","Firebase"],
        "url": "/projects/banchanggo/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "코드라운지: 개발자 Q&A 학습 서비스",
        "excerpt":"소개      서비스 설명: CS, iOS 면접 질문과 답변을 마크다운 형식으로 정리하여 제공하는 학습용 서비스   프로젝트 유형: 개인 프로젝트   개발 기간: 24.11 ~ 25.01   Github 링크: https://github.com/team-GitDeulida/CodeLounge-iOS   기술 스택: SwiftUI, Combine, fastlane, Firebase   기여한 부분     SwiftUI 기반 마크다운 렌더링 직접 구현   도입 배경     코드라운지는 CS·iOS 면접 질문과 답변을 제공하는 학습 앱입니다.   SwiftUI 기본 Text 컴포넌트는 표현과 커스터마이징에 한계가 있어, 고급 마크다운 처리가 가능한 파서를 직접 구현하게 되었습니다.   해결 방법          대학에서 배운 프로그래밍언어 과목의 EBNF 문법과 Top-Down, 재귀 하강 파싱 개념을 앱에 적용.   전체 문서를 EBNF 기반으로 문법적으로 정의한 후, Heading, ListItem, Paragraph 등 Top Down 방식의 블록 단위 파싱을 구현.   줄 내에 있는 Bold, Underline 등은 재귀 하강 파싱으로 중첩 구조까지 분석.   파싱된 결과는 SwiftUI에서 Text, HStack, VStack 등으로 동적으로 렌더링.   성과      텍스트 강조, 코드블럭, 밑줄 표현이 가능한 마크다운 메서드 구현.   긴 텍스트를 가독성 높게 표현할 수 있게 됨.   다양한 기기에서도 일관된 텍스트 크기와 여백을 자동으로 조정하는 라이브러리 구현.   기능을 범용 라이브러리 형태로 분리하여 프로젝트 간 재사용이 가능하도록 모듈화.  ","categories": [],
        "tags": ["SwiftUI","Combine","fastlane","Firebase"],
        "url": "/projects/codelounge/",
        "teaser": "/assets/logos/background.png"
      },{
        "title": "음메요: 음성 메모 요약 서비스",
        "excerpt":"소개      서비스 설명: 음메요는 음성 메모 요약의 줄임말로, 음성 또는 텍스트를 메모로 남기면 GPT가 자동으로 핵심 내용을 요약해주는 메모 정리 알림 서비스입니다.   프로젝트 유형: 팀 프로젝트   개발 기간: 24.09 ~ 25.04   Github 링크: https://github.com/team-RETI/EUMMEYO   기술 스택: SwiftUI, Combine, OpenAI, MVVM + CleanArchitecture, Firebase   기여한 부분     GPT 기반 음성 감정 기록 및 요약 처리 시스템 구현 (Whisper API + GPT API 연계)   도입 배경     기존 메모 앱은 키보드 입력 중심이라 사용자의 기록 부담이 컸고, 음성 기록 기능이 있어도 단순 저장에 그치는 경우가 많았습니다.   음메요는 음성 또는 텍스트로 기록 → 핵심 요약 → 텍스트 저장으로 이어지는 연쇄적인 비동기 호출 구조가 요구되었습니다.   해결 방법      Whisper API로 음성을 한국어 텍스트로 변환.   변환된 텍스트를 GPT-4o mini API로 보내 감정 요약.   Swift Combine flatMap으로 연동, 오류는 enum 기반 에러로 세분화 처리.   성과      Whisper → GPT → 요약까지 이어지는 연쇄 비동기 흐름을 앱 내부에 안정적으로 구현.   음성 감정 기록을 자동 요약해 실제 사용자 최고 경험 향상.        클린 아키텍처로 프로젝트 구조 개선하기   도입 배경     초기에는 대부분의 기능을 하나의 ViewModel에 구현하고, 모든 파일을 단일 폴더에 구성하는 방식으로 개발을 진행했습니다. 하지만 음성 인식, GPT 요약, 메모 저장 등 기능이 점차 늘어나면서 ViewModel이 비대해졌고, 수정 시 다른 화면이나 컴포넌트까지 영향이 미치는 문제가 발생했습니다. 이러한 복잡도를 해소하고, 코드 간 경계를 명확히 구분하기 위해 MVVM + Clean Architecture 구조로 전환하게 되었습니다.   해결 방법      View → ViewModel → Service → Repository 계층 분리.   외부 의존성(Firebase, OpenAI 등)은 모두 Repository에서 관리하고, ViewModel은 비즈니스 로직에만 집중하도록 구조화.   DIP(의존성 역전 원칙)를 적용하여 인터페이스 기반 설계를 통해 각 계층 간 느슨한 결합을 유지.   성과      ViewModel 크기가 줄고, 각 기능이 책임 기반으로 분리되어 유지보수성과 확장성이 크게 향상.   구조가 명확해짐에 따라 신규 기능 추가나 다른 기능에 영향을 주지 않는 독립적인 개발 구조 확보.   팀 프로젝트에서 책임 구분이 명확해져 코드 리뷰와 협업 효율 증가.  ","categories": [],
        "tags": ["SwiftUI","Combine","OpenAI","MVVM + CleanArchitecture","Firebase"],
        "url": "/projects/eummeyo/",
        "teaser": "/assets/logos/background.png"
      }]
