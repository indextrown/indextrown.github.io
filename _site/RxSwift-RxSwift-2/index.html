<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[RxSwift] 2. 개념 및 예제 - DongHyeon Kim’s Blog</title>
<meta name="description" content="1. Observable &amp; Observer    데이터를 연결해줄 수 있는 이벤트가 있고, 이 이벤트에 따라 변경되는 뷰, 로직이 있다.   즉 이벤트를 방출할 수 있는 Observable가 있고, 이벤트를 처리하는 Observer가 있다.   Observable와 Observer를 통해 데이터의 흐름(=Stream)을 통제할 수 있고   Operator를 통해 Stream을 변경, 조작할 수 있다.   사용자에게 텍스트 필드로 입력값을 받아서, 해당 입력값으로 닉네임을 저장할 때 아래의 그림과 같다.     예시로 표현하자면 유투버(Observable)은 영상을 올리고, 구독자(Observer)는 그 영상을 구독하고 알림을 받는다.   반대로 구독자(Observer)는 영상을 올리고 유투버(Observable)가 그 영상을 구독할 수 없다,  // 가능한 방식 nicknameTextField.rx.text            // ControlProperty&lt;String&gt; - UIKit 요소를 Rx로 다룰 수 있게 만든 특별한 Observable     .orEmpty     .withUnretained(self)            // 메모리 누수 방지 + self 캡처     .bind(onNext: { vc, value in     // 텍스트 변경시마다 nickname에 저장         vc.nickname = value     })     .disposed(by: disposeBag)        // 구독해제는 disposeBag에 맞김  // 불가능한 방식 nicknameTextField.rx.text = nickname     Observable은 subscribe를 하지 못하기 때문에 이벤트 방출만 할 수 있고 이벤트에 대한 처리는 할 수 없다.   Observer역시 받은 이벤트를 다른 Observer에게 전달하지 못한다.   nicknameTextField.rx.text = nickname 처럼 (Observable)에 바로 nickname이벤트 전달이 안된다.   이를 해결하기 위해 Observer와 Observable 역할을 모두 할 수 있는 Subject가 등장하였다.     Subject    Subject는 이벤트를 발행(emit)하고 구독(subscribe)모두 할 수 있는 중간 다리 역할을 한다.            Observable처럼 이벤트를 방출할 수 있고       Observer처럼 다른 Observable로부터 이벤트를 받을 수 있다.       즉 입출력이 모두 가능한 특별한 Observable 이다.           Subject는 4가지 종류가 있다.            Publish Subject: 구독 이후에 발생한 이벤트만 전달       Behavior Subject: 구독 시 마지막 이벤트 + 이후 이벤트 전달       Replay Subject: 지정한 수만큼 과거 이벤트를 버퍼로 저장해 구독 시 전달       Async Subject: 완료 시점에 발생한 마지막 값만 전달           하지만 UI에 좀 더 적합한 형태가 필요하였고 Subject를 Wrapping한 Relay를 제공한다.     Relay    Relay는 두 가지 종류가 있다.            Publish Relay       Behavior Relay           Subject와 거의 유사하지만 UI에 특화된 형태이다.   Subject와의 가장 큰 차이점은:            Relay는 .completed와 .error 이벤트를 전달하거나 처리하지 않는다.           ❓왜 .error와 .completed를 막았을까?    일반적인 Subject는 .onNext, .onCompleted, .onError 3가지 이벤트를 처리한다.   그러나 UI에서 사용하는 스트림은 에러나 종료가 발생하지 않고 계속 살아 있어야 한다.   만약 .error 또는 .completed 이벤트가 전달되면            스트림이 종료(disposed)되고       이후 .next 이벤트를 받을 수 없고       Rx의 반응형 업데이트 흐름이 끊기게 된다.           Relay 주요 특징    .next 이벤트만 전달하며, accept(_:) 메서드를 통해 값을 방출한다.   .error, .completed는 전달하지 않기 때문에 dispose되지 않습니다.            그렇기에 Relay는 명시적으로 disposeBag에 담거나, deinit시점에 수동으로 정리해주어야 한다.           항상 살아 있는 스트림이므로 UI 바인딩에 안정적으로 사용된다.     Driver    UI 바인딩 특화된 Observable로, 메인스레드 보장 + 에러 무시 + 공유를 기본으로 가진 RXCocoa 전용 타입이다.            메인스레드 보장 -&gt; .observe(on: MainScheduler.instance)가 내장       에러 발생 x -&gt; .onError가 자동으로 무시되거나 기본값으로 대체됨       공유(share) -&gt; 여러 곳에서 구독해도 side effect 없이 공유됨 (hot observable)       Subscrive만 가능하고 값 변경 불가       bind와 다르게 stream 공유가 된다.                    bind는 subscribe의 별칭           drive는 내부적으로 share(replay: 1, scope: .whileConnected)가 구현되어 있다.                           Driver가 필요한 이유    일반 Observable은            UI 스레드 보장 안되고       에러 발생시 스트림 끈힉고       매 구독마다 실행(side effect)이 발생할 수 있다.           그래서 UI에 직접 바인딩시 Driver가 훨씬 안전하다.   Relay는 값을 저장 &amp; 전달하는(Input)용   Driver는 UI 바인딩에 최적화된 Observable(Output)용                  항목       Relay       Driver                       주 용도       ViewModel Input 처리       ViewModel → View Output 전달                 에러 처리       .error 불가       .error 불가 + 자동 대체 필요                 스레드 보장       ❌ MainScheduler 보장 없음       ✅ 항상 MainScheduler에서 실행                 공유 여부       ❌ 직접 .share() 필요       ✅ 내부적으로 share(replay:1) 적용됨                 값 수동 전달       ✅ .accept() 사용 가능       ❌ 수동 값 전달 불가 (drive로만 가능)                 bind 가능 대상       Relay, Binder 등       Binder, drive(to:)                 구독 방식  1. Subscribe button.rx.tap // ControlEvent&lt;Void&gt; (Observable&lt;Void&gt;를 래핑한 타입)으로 내부적으로 .error 이벤트를 방출하지 않도록 설계되어 있어 스트림이 끊기지 않는다     .observe(on: MainScheduler.instance)      .withUnretained(self)     .subscribe { vc, _ in         vc.label.text = &quot;hello world     }     .disposed(by: disposeBag)     button.rx.tap은 Observable 타입의 ControlEvent 버튼이 탭될 때마다 이벤트를 방출한다.   이 Observable를 구독한다.   Background Schedular에서 동작할 가능성(네트워크 통신)이 있기 때문에 Observable 데이터 흐름을 MainSchedular(메인 스레드)에서 동작할 수 있도록 변경한다.   2. bind // bind(onNext:) button.rx.tap      .withUnretained(self)     .bind(onNext: { vc, _ in         vc.label.text = &quot;hello&quot;     })     .disposed(by: disposeBag)     subscribe와 유사하지만 MainSchedular(메인 스레드)동작 보장과 Error 이벤트를 방출하지 않는 특성을 통해 스트림이 끊기지 않는다.   // bind(to:) // 예시1 button.rx.tap // ControlEvent&lt;Void&gt; (Observable&lt;Void&gt;를 래핑한 타입)     .map { &quot;hello world&quot; }     .bind(to: label.rx.text)      .disposed(by: disposeBag) // 예시2 viewModel.nickname // Observable&lt;String&gt;     .bind(to: nicknameLabel.rx.text) // Binder&lt;String&gt;     .disposed(by: disposeBag)     tap의 ControlEvent를 map Operator를 통해 데이터의 흐름을 조작한다.   ControlEvent 타입이 String 타입으로 변경 되면서 label.rx.text로 간단히 bind 가능하다.   bind(to:), bind(onNext:) 두 형태 모두 메인 스레드에서 실행되고 에러를 무시하기 때문에, UI 바인딩에 적합하다.                  bind(to:)       bind(onNext:)                       observable.bind(to: label.rx.text)       observable.bind(onNext: { value in … })                 UI 바인딩       클로저에서 값 처리                 Binder&lt;T&gt; 타입의 대상에만 가능 자동으로 메인 스레드에서 동작 에러 무시       직접 처리 가능 (print, 가공, 저장 등)에러 무시메인 스레드에서 동작 보장           ✅ 정리    bind(onNext:): 클로저 내에서 직접 처리할 때 사용   bind(to:): 값을 다른 Rx 객체(UI 속성, Relay 등)에 전달할 때 사용   둘 다:            MainSchedular에서 항상 동작하고       .error 이벤트를 방출하지 않으며           → 결과적으로 스트림이 끊기지 않으며, UI 바인딩에 매우 안정적   drive viewModel.nicknameDriver // Driver&lt;String&gt;     .drive(nicknameLabel.rx.text)   // drive(to: Binder&lt;String&gt;)     .disposed(by: disposeBag)     drive는 Driver 전용 구독 연산자로,            MainSchedular에서 항상 동작하고       .error 이벤트를 방출하지 않으며       내부적으로 share(replay: 1)가 적용되어 여러 구독자에게 안전하게 공유된다.           bind(to:)와 유사하지만 Driver의 안정성을 최대한 활용하기 위한 전용 바인딩 방법이다.   오직 Driver 타입에서만 사용할 수 있으며, 일반 Observable에는 사용할 수 없다.       에제  1. 구성    보내는 것 - Observable   연결 - subScribe   중간처리 - 연산자   2. 큰 개념 보내는 것 - 옵저버블(총알 = 구독 가능한 것)    Observable            가장 기본 베이스, 생성하자마자 이벤트를 전달한다       .onNext(), .onError(), .onCompleted()를 통해 이벤트를 받을 수 있다       .subscribe()를 통해 이벤트를 발행 가능       이벤트를 정의하고, 정적인 스트림 생성(한방향: 선언 -&gt; 구독)            // 1. Observable은 가장 기본적인 Rx 스트림  // 내부에서 [1, 2, 3]을 한번 방출하고 끝  let observable = Observable&lt;[Int]&gt;.just([1, 2, 3])       // 2. subscribe를 통해 값을 받아 처리  observable      .subscribe(          onNext: { value in              print(&quot;Received: \(value)&quot;)          },          onError: { error in              print(&quot;❌ onError: \(error.localizedDescription)&quot;)          },          onCompleted: {              print(&quot;✅ Stream Completed&quot;)          },          onDisposed: {              print(&quot;🧹 Subscription Disposed&quot;)          }      ).disposed(by: disposeBag)           Subject      기본 Observable은 생성될 때 방출할 값이 정해져 있고, 외부에서 값을 주입할 수 없다. 그래서 외부에서 직접 값을 전달하고 싶을 때는 Subject를 사용한다.   Subject는 값을 방출할 수도 있고, 다른 Observable처럼 구독도 받을 수 있는 양방향 통로다.   Observable(구독 가능한 것)이면서 Observer(관찰자)   일단 연결을 해두고 원하는 시점에 이벤트를 보낸다.   외부에서 직접 값을 넣고, 동적인 스트림 생성(양방향)     // &quot;Hello&quot;라는 값을 한번 방출하고 끝. 외부에서 바꿀 수 없음 Observable.just(&quot;Hello&quot;)      // 외부에서 onNext(&quot;Hello&quot;)로 값을 보내면 그때 스트림이 시작됨 PublishSubject&lt;String&gt;()                 BehaviorSubject - 상태                    초기값 필수           구독 시, 가장 최신값 1개를 즉시 전달받음           이후에는 일반 Observable처럼 .onNext 이벤트를 수신                   // 1. BehaviorSubject는 초기값을 설정하고, 구독 시 가장 최근 값을 전달 let behaviorSubject = BehaviorSubject&lt;String&gt;(value: &quot;초기값&quot;)        // 2. 구독 설정 → &quot;초기값&quot;이 바로 전달됨 behaviorSubject     .subscribe(onNext: { print(&quot;BehaviorSubject:&quot;, $0) })     .disposed(by: disposeBag)        // 3. 새로운 이벤트 전달 behaviorSubject.onNext(&quot;새로운 값&quot;)                       PublishSubjcet - 단방향 이벤트                    구독 이후 이벤트만 받음(초기값 없음)           주로 이벤트 전달용                   // 1. PublishSubject는 구독 이후에 발생한 이벤트만 전달 let publishSubject = PublishSubject&lt;String&gt;()      // 2. 구독 설정 publishSubject     .subscribe(onNext: { print(&quot;PublishSubject:&quot;, $0) })     .disposed(by: disposeBag)      // 3. 이벤트 직접 발생 (구독 이후라 전달됨) publishSubject.onNext(&quot;첫 번째 이벤트&quot;)      // subject는 구독을 받고, 동시에 외부에서 onNext로 값을 직접 보낼 수 있는 Observable // Observable처럼 구독자를 가질 수 있고, Observer처럼 값을 외부에서 직접 넣을 수 있음 (onNext() 등)                              Relay            Subject의 변형으로, error가 없고 UI바인딩에 최적화       PublishRelay                          단방향 이벤트 전달(버튼 클릭)          // 1. PublishRelay는 error가 없고 UI에 최적화된 Subject let publishRelay = PublishRelay&lt;String&gt;()        // 2. 구독 설정 publishRelay     .subscribe(onNext: { print(&quot;PublishRelay:&quot;, $0) })     .disposed(by: disposeBag)        // 3. 이벤트 발생 → accept()로 전달 publishRelay.accept(&quot;이벤트 발생!&quot;)                       BehaviorRelay                상태 저장, 초기값 필수 -&gt; accept() 사용          // 1. BehaviorRelay는 초기값이 필요하며, 상태 저장에 적합 let behaviorRelay = BehaviorRelay&lt;String&gt;(value: &quot;기본값&quot;)        // 2. 구독 설정 → &quot;기본값&quot;이 바로 전달됨 behaviorRelay     .subscribe(onNext: { print(&quot;BehaviorRelay:&quot;, $0) })     .disposed(by: disposeBag)        // 3. 값 업데이트 → accept() 사용 behaviorRelay.accept(&quot;업데이트된 값&quot;)                           Driver            메인스레드, share(1)                UI 바인딩 전용으로 사용되는 옵저버블             // 1. Relay에서 값을 가져와 Driver로 변환  let textRelay = BehaviorRelay&lt;String&gt;(value: &quot;Hello&quot;)         // 2. Driver로 변환 (에러 없이, MainThread에서 작동)  let textDriver = textRelay.asDriver()         // 3. UI 요소에 drive (drive는 MainThread에서 UI 바인딩 시 사용)  textDriver      .drive(label.rx.text)      .disposed(by: disposeBag)                           구독    subscribe(onNext:)            next, error, completed 시퀀스 이벤트를 받을 수 있다       직점 onError 처리 가능하다       viewModel 내부, 로직 처리, 이벤트 감지, 에러 대응       Disposable 반환해야한다       모든 Observable계열 구독 가능                bind(onNext:) 보다 범용적, 완료/에러 받을 수 있다           // 1. onNext만 사용하는 기본적인 구독  let observable = Observable.just(&quot;Hello, RxSwift!&quot;)         observable      .subscribe(onNext: { value in          print(&quot;onNext:&quot;, value)      })      .disposed(by: disposeBag)         // 2. onNext, onError, onCompleted 모두 명시  let observable = Observable&lt;String&gt;.create { observer in      observer.onNext(&quot;첫 번째 이벤트&quot;)      observer.onCompleted()      return Disposables.create()  }         observable      .subscribe(          onNext: { print(&quot;onNext:&quot;, $0) },          onError: { print(&quot;onError:&quot;, $0.localizedDescription) },          onCompleted: { print(&quot;onCompleted&quot;) },          onDisposed: { print(&quot;onDisposed&quot;) }      )      .disposed(by: disposeBag)                           bind(to:)            UI 컴포넌트 프로퍼티에 바인딩할 때 사용       구독과 동시에 값이 특정 속성에 직접 들어가는 방식       값을 특정UI의 속성에 직접 구독해서 바인딩           // label.text = title처럼 자동으로 연결하는 직접 바인딩 방식   viewModel.title    .bind(to: label.rx.text)    .disposed(by: disposeBag)                           bind(onNext:)            단순히 이벤트를 수신하고 구독 형태       내부에 명시적으로 처리 로직을 작성해야 함       값을 받아서 직접 처리(프린트, 로직 실행)하는 방식으로 구독           viewModel.title    .bind(onNext: { text in    print(&quot;값 출력: \(text)&quot;)    })    .disposed(by: disposeBag)                                비교       // 1. 자동 UI 업데이트 (bind to UI)  viewModel.username // Observable&lt;String&gt;      .bind(to: label.rx.text) // 📲 label.text = 값      .disposed(by: disposeBag)   // 2. 내가 직접 프린트 (bind with closure)  viewModel.username      .bind(onNext: { name in          print(&quot;유저 이름은 \(name)&quot;)      })      .disposed(by: disposeBag)           drive (RxCocoa 전용 UI 바인딩 방식)            Driver 타입만 사용할 수 있는 구독 방식       UI 업데이트에 특화 → MainThread 보장 + 에러 자동 무시 + 공유(share) 내장       .asDriver(onErrorJustReturn:) 또는 .asDriver()를 통해 변환 후 사용       UI 요소(UILabel, UIButton, UISwitch, etc.)에 직접 바인딩 가능       내부적으로 bind(to:)와 매우 유사하지만, Driver만 사용할 수 있음            // 예시 1: ViewModel의 Driver&lt;String&gt;을 UILabel에 바인딩  viewModel.nicknameDriver      .drive(nicknameLabel.rx.text)      .disposed(by: disposeBag)   // 예시 2: ViewModel의 Driver&lt;Void&gt;을 버튼 클릭에 바인딩  viewModel.didTapSomething      .drive(onNext: {          print(&quot;탭 감지됨!&quot;)      })      .disposed(by: disposeBag)           Reference    https://so-kyte.tistory.com/192">


  <meta name="author" content="Dong Hyeon">
  
  <meta property="article:author" content="Dong Hyeon">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="DongHyeon Kim's Blog">
<meta property="og:title" content="[RxSwift] 2. 개념 및 예제">
<meta property="og:url" content="http://localhost:4000/RxSwift-RxSwift-2/">


  <meta property="og:description" content="1. Observable &amp; Observer    데이터를 연결해줄 수 있는 이벤트가 있고, 이 이벤트에 따라 변경되는 뷰, 로직이 있다.   즉 이벤트를 방출할 수 있는 Observable가 있고, 이벤트를 처리하는 Observer가 있다.   Observable와 Observer를 통해 데이터의 흐름(=Stream)을 통제할 수 있고   Operator를 통해 Stream을 변경, 조작할 수 있다.   사용자에게 텍스트 필드로 입력값을 받아서, 해당 입력값으로 닉네임을 저장할 때 아래의 그림과 같다.     예시로 표현하자면 유투버(Observable)은 영상을 올리고, 구독자(Observer)는 그 영상을 구독하고 알림을 받는다.   반대로 구독자(Observer)는 영상을 올리고 유투버(Observable)가 그 영상을 구독할 수 없다,  // 가능한 방식 nicknameTextField.rx.text            // ControlProperty&lt;String&gt; - UIKit 요소를 Rx로 다룰 수 있게 만든 특별한 Observable     .orEmpty     .withUnretained(self)            // 메모리 누수 방지 + self 캡처     .bind(onNext: { vc, value in     // 텍스트 변경시마다 nickname에 저장         vc.nickname = value     })     .disposed(by: disposeBag)        // 구독해제는 disposeBag에 맞김  // 불가능한 방식 nicknameTextField.rx.text = nickname     Observable은 subscribe를 하지 못하기 때문에 이벤트 방출만 할 수 있고 이벤트에 대한 처리는 할 수 없다.   Observer역시 받은 이벤트를 다른 Observer에게 전달하지 못한다.   nicknameTextField.rx.text = nickname 처럼 (Observable)에 바로 nickname이벤트 전달이 안된다.   이를 해결하기 위해 Observer와 Observable 역할을 모두 할 수 있는 Subject가 등장하였다.     Subject    Subject는 이벤트를 발행(emit)하고 구독(subscribe)모두 할 수 있는 중간 다리 역할을 한다.            Observable처럼 이벤트를 방출할 수 있고       Observer처럼 다른 Observable로부터 이벤트를 받을 수 있다.       즉 입출력이 모두 가능한 특별한 Observable 이다.           Subject는 4가지 종류가 있다.            Publish Subject: 구독 이후에 발생한 이벤트만 전달       Behavior Subject: 구독 시 마지막 이벤트 + 이후 이벤트 전달       Replay Subject: 지정한 수만큼 과거 이벤트를 버퍼로 저장해 구독 시 전달       Async Subject: 완료 시점에 발생한 마지막 값만 전달           하지만 UI에 좀 더 적합한 형태가 필요하였고 Subject를 Wrapping한 Relay를 제공한다.     Relay    Relay는 두 가지 종류가 있다.            Publish Relay       Behavior Relay           Subject와 거의 유사하지만 UI에 특화된 형태이다.   Subject와의 가장 큰 차이점은:            Relay는 .completed와 .error 이벤트를 전달하거나 처리하지 않는다.           ❓왜 .error와 .completed를 막았을까?    일반적인 Subject는 .onNext, .onCompleted, .onError 3가지 이벤트를 처리한다.   그러나 UI에서 사용하는 스트림은 에러나 종료가 발생하지 않고 계속 살아 있어야 한다.   만약 .error 또는 .completed 이벤트가 전달되면            스트림이 종료(disposed)되고       이후 .next 이벤트를 받을 수 없고       Rx의 반응형 업데이트 흐름이 끊기게 된다.           Relay 주요 특징    .next 이벤트만 전달하며, accept(_:) 메서드를 통해 값을 방출한다.   .error, .completed는 전달하지 않기 때문에 dispose되지 않습니다.            그렇기에 Relay는 명시적으로 disposeBag에 담거나, deinit시점에 수동으로 정리해주어야 한다.           항상 살아 있는 스트림이므로 UI 바인딩에 안정적으로 사용된다.     Driver    UI 바인딩 특화된 Observable로, 메인스레드 보장 + 에러 무시 + 공유를 기본으로 가진 RXCocoa 전용 타입이다.            메인스레드 보장 -&gt; .observe(on: MainScheduler.instance)가 내장       에러 발생 x -&gt; .onError가 자동으로 무시되거나 기본값으로 대체됨       공유(share) -&gt; 여러 곳에서 구독해도 side effect 없이 공유됨 (hot observable)       Subscrive만 가능하고 값 변경 불가       bind와 다르게 stream 공유가 된다.                    bind는 subscribe의 별칭           drive는 내부적으로 share(replay: 1, scope: .whileConnected)가 구현되어 있다.                           Driver가 필요한 이유    일반 Observable은            UI 스레드 보장 안되고       에러 발생시 스트림 끈힉고       매 구독마다 실행(side effect)이 발생할 수 있다.           그래서 UI에 직접 바인딩시 Driver가 훨씬 안전하다.   Relay는 값을 저장 &amp; 전달하는(Input)용   Driver는 UI 바인딩에 최적화된 Observable(Output)용                  항목       Relay       Driver                       주 용도       ViewModel Input 처리       ViewModel → View Output 전달                 에러 처리       .error 불가       .error 불가 + 자동 대체 필요                 스레드 보장       ❌ MainScheduler 보장 없음       ✅ 항상 MainScheduler에서 실행                 공유 여부       ❌ 직접 .share() 필요       ✅ 내부적으로 share(replay:1) 적용됨                 값 수동 전달       ✅ .accept() 사용 가능       ❌ 수동 값 전달 불가 (drive로만 가능)                 bind 가능 대상       Relay, Binder 등       Binder, drive(to:)                 구독 방식  1. Subscribe button.rx.tap // ControlEvent&lt;Void&gt; (Observable&lt;Void&gt;를 래핑한 타입)으로 내부적으로 .error 이벤트를 방출하지 않도록 설계되어 있어 스트림이 끊기지 않는다     .observe(on: MainScheduler.instance)      .withUnretained(self)     .subscribe { vc, _ in         vc.label.text = &quot;hello world     }     .disposed(by: disposeBag)     button.rx.tap은 Observable 타입의 ControlEvent 버튼이 탭될 때마다 이벤트를 방출한다.   이 Observable를 구독한다.   Background Schedular에서 동작할 가능성(네트워크 통신)이 있기 때문에 Observable 데이터 흐름을 MainSchedular(메인 스레드)에서 동작할 수 있도록 변경한다.   2. bind // bind(onNext:) button.rx.tap      .withUnretained(self)     .bind(onNext: { vc, _ in         vc.label.text = &quot;hello&quot;     })     .disposed(by: disposeBag)     subscribe와 유사하지만 MainSchedular(메인 스레드)동작 보장과 Error 이벤트를 방출하지 않는 특성을 통해 스트림이 끊기지 않는다.   // bind(to:) // 예시1 button.rx.tap // ControlEvent&lt;Void&gt; (Observable&lt;Void&gt;를 래핑한 타입)     .map { &quot;hello world&quot; }     .bind(to: label.rx.text)      .disposed(by: disposeBag) // 예시2 viewModel.nickname // Observable&lt;String&gt;     .bind(to: nicknameLabel.rx.text) // Binder&lt;String&gt;     .disposed(by: disposeBag)     tap의 ControlEvent를 map Operator를 통해 데이터의 흐름을 조작한다.   ControlEvent 타입이 String 타입으로 변경 되면서 label.rx.text로 간단히 bind 가능하다.   bind(to:), bind(onNext:) 두 형태 모두 메인 스레드에서 실행되고 에러를 무시하기 때문에, UI 바인딩에 적합하다.                  bind(to:)       bind(onNext:)                       observable.bind(to: label.rx.text)       observable.bind(onNext: { value in … })                 UI 바인딩       클로저에서 값 처리                 Binder&lt;T&gt; 타입의 대상에만 가능 자동으로 메인 스레드에서 동작 에러 무시       직접 처리 가능 (print, 가공, 저장 등)에러 무시메인 스레드에서 동작 보장           ✅ 정리    bind(onNext:): 클로저 내에서 직접 처리할 때 사용   bind(to:): 값을 다른 Rx 객체(UI 속성, Relay 등)에 전달할 때 사용   둘 다:            MainSchedular에서 항상 동작하고       .error 이벤트를 방출하지 않으며           → 결과적으로 스트림이 끊기지 않으며, UI 바인딩에 매우 안정적   drive viewModel.nicknameDriver // Driver&lt;String&gt;     .drive(nicknameLabel.rx.text)   // drive(to: Binder&lt;String&gt;)     .disposed(by: disposeBag)     drive는 Driver 전용 구독 연산자로,            MainSchedular에서 항상 동작하고       .error 이벤트를 방출하지 않으며       내부적으로 share(replay: 1)가 적용되어 여러 구독자에게 안전하게 공유된다.           bind(to:)와 유사하지만 Driver의 안정성을 최대한 활용하기 위한 전용 바인딩 방법이다.   오직 Driver 타입에서만 사용할 수 있으며, 일반 Observable에는 사용할 수 없다.       에제  1. 구성    보내는 것 - Observable   연결 - subScribe   중간처리 - 연산자   2. 큰 개념 보내는 것 - 옵저버블(총알 = 구독 가능한 것)    Observable            가장 기본 베이스, 생성하자마자 이벤트를 전달한다       .onNext(), .onError(), .onCompleted()를 통해 이벤트를 받을 수 있다       .subscribe()를 통해 이벤트를 발행 가능       이벤트를 정의하고, 정적인 스트림 생성(한방향: 선언 -&gt; 구독)            // 1. Observable은 가장 기본적인 Rx 스트림  // 내부에서 [1, 2, 3]을 한번 방출하고 끝  let observable = Observable&lt;[Int]&gt;.just([1, 2, 3])       // 2. subscribe를 통해 값을 받아 처리  observable      .subscribe(          onNext: { value in              print(&quot;Received: \(value)&quot;)          },          onError: { error in              print(&quot;❌ onError: \(error.localizedDescription)&quot;)          },          onCompleted: {              print(&quot;✅ Stream Completed&quot;)          },          onDisposed: {              print(&quot;🧹 Subscription Disposed&quot;)          }      ).disposed(by: disposeBag)           Subject      기본 Observable은 생성될 때 방출할 값이 정해져 있고, 외부에서 값을 주입할 수 없다. 그래서 외부에서 직접 값을 전달하고 싶을 때는 Subject를 사용한다.   Subject는 값을 방출할 수도 있고, 다른 Observable처럼 구독도 받을 수 있는 양방향 통로다.   Observable(구독 가능한 것)이면서 Observer(관찰자)   일단 연결을 해두고 원하는 시점에 이벤트를 보낸다.   외부에서 직접 값을 넣고, 동적인 스트림 생성(양방향)     // &quot;Hello&quot;라는 값을 한번 방출하고 끝. 외부에서 바꿀 수 없음 Observable.just(&quot;Hello&quot;)      // 외부에서 onNext(&quot;Hello&quot;)로 값을 보내면 그때 스트림이 시작됨 PublishSubject&lt;String&gt;()                 BehaviorSubject - 상태                    초기값 필수           구독 시, 가장 최신값 1개를 즉시 전달받음           이후에는 일반 Observable처럼 .onNext 이벤트를 수신                   // 1. BehaviorSubject는 초기값을 설정하고, 구독 시 가장 최근 값을 전달 let behaviorSubject = BehaviorSubject&lt;String&gt;(value: &quot;초기값&quot;)        // 2. 구독 설정 → &quot;초기값&quot;이 바로 전달됨 behaviorSubject     .subscribe(onNext: { print(&quot;BehaviorSubject:&quot;, $0) })     .disposed(by: disposeBag)        // 3. 새로운 이벤트 전달 behaviorSubject.onNext(&quot;새로운 값&quot;)                       PublishSubjcet - 단방향 이벤트                    구독 이후 이벤트만 받음(초기값 없음)           주로 이벤트 전달용                   // 1. PublishSubject는 구독 이후에 발생한 이벤트만 전달 let publishSubject = PublishSubject&lt;String&gt;()      // 2. 구독 설정 publishSubject     .subscribe(onNext: { print(&quot;PublishSubject:&quot;, $0) })     .disposed(by: disposeBag)      // 3. 이벤트 직접 발생 (구독 이후라 전달됨) publishSubject.onNext(&quot;첫 번째 이벤트&quot;)      // subject는 구독을 받고, 동시에 외부에서 onNext로 값을 직접 보낼 수 있는 Observable // Observable처럼 구독자를 가질 수 있고, Observer처럼 값을 외부에서 직접 넣을 수 있음 (onNext() 등)                              Relay            Subject의 변형으로, error가 없고 UI바인딩에 최적화       PublishRelay                          단방향 이벤트 전달(버튼 클릭)          // 1. PublishRelay는 error가 없고 UI에 최적화된 Subject let publishRelay = PublishRelay&lt;String&gt;()        // 2. 구독 설정 publishRelay     .subscribe(onNext: { print(&quot;PublishRelay:&quot;, $0) })     .disposed(by: disposeBag)        // 3. 이벤트 발생 → accept()로 전달 publishRelay.accept(&quot;이벤트 발생!&quot;)                       BehaviorRelay                상태 저장, 초기값 필수 -&gt; accept() 사용          // 1. BehaviorRelay는 초기값이 필요하며, 상태 저장에 적합 let behaviorRelay = BehaviorRelay&lt;String&gt;(value: &quot;기본값&quot;)        // 2. 구독 설정 → &quot;기본값&quot;이 바로 전달됨 behaviorRelay     .subscribe(onNext: { print(&quot;BehaviorRelay:&quot;, $0) })     .disposed(by: disposeBag)        // 3. 값 업데이트 → accept() 사용 behaviorRelay.accept(&quot;업데이트된 값&quot;)                           Driver            메인스레드, share(1)                UI 바인딩 전용으로 사용되는 옵저버블             // 1. Relay에서 값을 가져와 Driver로 변환  let textRelay = BehaviorRelay&lt;String&gt;(value: &quot;Hello&quot;)         // 2. Driver로 변환 (에러 없이, MainThread에서 작동)  let textDriver = textRelay.asDriver()         // 3. UI 요소에 drive (drive는 MainThread에서 UI 바인딩 시 사용)  textDriver      .drive(label.rx.text)      .disposed(by: disposeBag)                           구독    subscribe(onNext:)            next, error, completed 시퀀스 이벤트를 받을 수 있다       직점 onError 처리 가능하다       viewModel 내부, 로직 처리, 이벤트 감지, 에러 대응       Disposable 반환해야한다       모든 Observable계열 구독 가능                bind(onNext:) 보다 범용적, 완료/에러 받을 수 있다           // 1. onNext만 사용하는 기본적인 구독  let observable = Observable.just(&quot;Hello, RxSwift!&quot;)         observable      .subscribe(onNext: { value in          print(&quot;onNext:&quot;, value)      })      .disposed(by: disposeBag)         // 2. onNext, onError, onCompleted 모두 명시  let observable = Observable&lt;String&gt;.create { observer in      observer.onNext(&quot;첫 번째 이벤트&quot;)      observer.onCompleted()      return Disposables.create()  }         observable      .subscribe(          onNext: { print(&quot;onNext:&quot;, $0) },          onError: { print(&quot;onError:&quot;, $0.localizedDescription) },          onCompleted: { print(&quot;onCompleted&quot;) },          onDisposed: { print(&quot;onDisposed&quot;) }      )      .disposed(by: disposeBag)                           bind(to:)            UI 컴포넌트 프로퍼티에 바인딩할 때 사용       구독과 동시에 값이 특정 속성에 직접 들어가는 방식       값을 특정UI의 속성에 직접 구독해서 바인딩           // label.text = title처럼 자동으로 연결하는 직접 바인딩 방식   viewModel.title    .bind(to: label.rx.text)    .disposed(by: disposeBag)                           bind(onNext:)            단순히 이벤트를 수신하고 구독 형태       내부에 명시적으로 처리 로직을 작성해야 함       값을 받아서 직접 처리(프린트, 로직 실행)하는 방식으로 구독           viewModel.title    .bind(onNext: { text in    print(&quot;값 출력: \(text)&quot;)    })    .disposed(by: disposeBag)                                비교       // 1. 자동 UI 업데이트 (bind to UI)  viewModel.username // Observable&lt;String&gt;      .bind(to: label.rx.text) // 📲 label.text = 값      .disposed(by: disposeBag)   // 2. 내가 직접 프린트 (bind with closure)  viewModel.username      .bind(onNext: { name in          print(&quot;유저 이름은 \(name)&quot;)      })      .disposed(by: disposeBag)           drive (RxCocoa 전용 UI 바인딩 방식)            Driver 타입만 사용할 수 있는 구독 방식       UI 업데이트에 특화 → MainThread 보장 + 에러 자동 무시 + 공유(share) 내장       .asDriver(onErrorJustReturn:) 또는 .asDriver()를 통해 변환 후 사용       UI 요소(UILabel, UIButton, UISwitch, etc.)에 직접 바인딩 가능       내부적으로 bind(to:)와 매우 유사하지만, Driver만 사용할 수 있음            // 예시 1: ViewModel의 Driver&lt;String&gt;을 UILabel에 바인딩  viewModel.nicknameDriver      .drive(nicknameLabel.rx.text)      .disposed(by: disposeBag)   // 예시 2: ViewModel의 Driver&lt;Void&gt;을 버튼 클릭에 바인딩  viewModel.didTapSomething      .drive(onNext: {          print(&quot;탭 감지됨!&quot;)      })      .disposed(by: disposeBag)           Reference    https://so-kyte.tistory.com/192">







  <meta property="article:published_time" content="2025-04-21T00:00:00+00:00">





  

  


<link rel="canonical" href="http://localhost:4000/RxSwift-RxSwift-2/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "indextrown",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->

<!-- 여기에 analytics 추가 -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="DongHyeon Kim's Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



<!--JQ cloud-->
<link rel="stylesheet" href="/assets/css/jqcloud.min.css">

<!-- pseudocode.js -->
<script src="/assets/pseudocode.js-2.4.1/pseudocode.js" type="text/javascript"></script>
<link rel="stylesheet" href="/assets/pseudocode.js-2.4.1/pseudocode.css">
    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-square-neo.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-gothic-coding.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
    
  <script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
    <script src="https://code.jquery.com/jquery-3.4.1.js"></script>

    <!-- Mermaid.js를 로드 기능 추가 - [index] -->
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<script src="https://unpkg.com/ionicons@4.5.10-0/dist/ionicons.js"></script>

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <!-- <a class="site-logo" href="/">
          <img src="/assets/logos/logo.svg" alt="DongHyeon Kim's Blog"></a> -->
        <a class="site-title" href="/">
          @dong_h_kim
          <span class="site-subtitle">iOS Developer Blog</span>
        </a>
        <!-- Dark mode toggle -->
        <!-- <input type="checkbox" id="switch" name="theme">
        <label for="switch" class="switch_label">
          <span class="onf_btn"></span>
        </label> -->
        <script src="https://code.iconify.design/1/1.0.4/iconify.min.js">   </script>
<label class="switch_label">
<input class='toggle-checkbox' type='checkbox'></input>
<div class='toggle-slot'>
    <div class='sun-icon-wrapper'>
    <div class="iconify sun-icon" data-icon="feather-sun" data-inline="false"></div>
    </div>
    <div class='toggle-button'></div>
    <div class='moon-icon-wrapper'>
    <div class="iconify moon-icon" data-icon="feather-moon" data-inline="false"></div>
    </div>
</div>
</label>
  

  
<style>

.toggle-checkbox {
  position: absolute;
  opacity: 0;
  cursor: pointer;
  height: 0;
  width: 0;
}

.toggle-slot {
  position: relative;
  height: 35px; /* Adjusted height for PC */
  width: 70px; /* Adjusted width for PC */
  border: 5px solid #e4e7ec;
  border-radius: 35px; /* Adjusted border-radius for PC */
  background-color: white;
  /* box-shadow: 0px 10px 25px #e4e7ec; */
  transition: background-color 250ms;
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-slot {
    height: 25px; /* Adjusted height for mobile */
    width: 50px; /* Adjusted width for mobile */
    border-radius: 25px; /* Adjusted border-radius for mobile */
    border: 3px solid #e4e7ec;
  }
}

.toggle-checkbox:checked ~ .toggle-slot {
  background-color: #374151;
}

.toggle-button {
  transform: translate(35px, 4px); /* Adjusted position for PC */
  position: absolute;
  height: 17.5px; /* Adjusted height for PC */
  width: 17.5px; /* Adjusted width for PC */
  border-radius: 50%;
  background-color: #ffeccf;
  box-shadow: inset 0px 0px 0px 3.5px #ffbb52; /* Adjusted box-shadow for PC */
  transition: background-color 250ms, border-color 250ms, transform 500ms;
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-button {
    transform: translate(27px, 3.5px); /* Adjusted position for mobile */
    height: 12.5px; /* Adjusted height for mobile */
    width: 12.5px; /* Adjusted width for mobile */
    box-shadow: inset 0px 0px 0px 2.5px #ffbb52; /* Adjusted box-shadow for mobile */
  }
}

.toggle-checkbox:checked ~ .toggle-slot .toggle-button {
  background-color: #485367;
  box-shadow: inset 0px 0px 0px 3.5px white; /* Adjusted box-shadow for PC */
  transform: translate(7px, 4px); /* Adjusted position for PC */
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-checkbox:checked ~ .toggle-slot .toggle-button {
    box-shadow: inset 0px 0px 0px 2.5px white; /* Adjusted box-shadow for mobile */
    transform: translate(4px, 3.5px); /* Adjusted position for mobile */
  }
}

.sun-icon {
  position: absolute;
  height: 18px; /* Adjusted height for PC */
  width: 18px; /* Adjusted width for PC */
  color: #ffbb52;
}

.sun-icon-wrapper {
  position: absolute;
  top: 10%;
  height: 18px; /* Adjusted height for PC */
  width: 18px; /* Adjusted width for PC */
  opacity: 1;
  transform: translate(5px, 1px) rotate(15deg); /* Adjusted position for PC */
  transform-origin: 50% 50%;
  transition: opacity 150ms, transform 500ms;
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .sun-icon,
  .sun-icon-wrapper {
    height: 11px; /* Adjusted height for mobile */
    width: 11px; /* Adjusted width for mobile */
    transform: translate(5px, 3px) rotate(15deg); /* Adjusted position for mobile */
  }
}

.toggle-checkbox:checked ~ .toggle-slot .sun-icon-wrapper {
  opacity: 0;
  transform: translate(0px, 1px) rotate(0deg); /* Adjusted position for PC */
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-checkbox:checked ~ .toggle-slot .sun-icon-wrapper {
    transform: translate(2px, 2.5px) rotate(0deg); /* Adjusted position for mobile */
  }
}

.moon-icon {
  position: absolute;
  height: 18px; /* Adjusted height for PC */
  width: 18px; /* Adjusted width for PC */
  color: white;
}

.moon-icon-wrapper {
  position: absolute;
  top: 10%;
  height: 18px; /* Adjusted height for PC */
  width: 18px; /* Adjusted width for PC */
  opacity: 0;
  transform: translate(30px, 1px) rotate(0deg); /* Adjusted position for PC */
  transform-origin: 50% 50%;
  transition: opacity 150ms, transform 500ms;
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .moon-icon,
  .moon-icon-wrapper {
    height: 11px; /* Adjusted height for mobile */
    width: 11px; /* Adjusted width for mobile */
    transform: translate(25px, 2.5px) rotate(0deg); /* Adjusted position for mobile */
  }
}

.toggle-checkbox:checked ~ .toggle-slot .moon-icon-wrapper {
  opacity: 1;
  transform: translate(35px, 1px) rotate(-15deg); /* Adjusted position for PC */
}

@media (max-width: 767px) {
  /* Styles for screens less than 768px wide (mobile) */
  .toggle-checkbox:checked ~ .toggle-slot .moon-icon-wrapper {
    transform: translate(28px, 2.5px) rotate(-15deg); /* Adjusted position for mobile */
  }
}


</style>

<script>
var checkbox = document.querySelector('.toggle-checkbox');

// 페이지 로드 시 로컬 스토리지에서 테마 설정을 불러옵니다.
if (localStorage.getItem('theme') === 'dark') {
  checkbox.checked = true;
  document.body.classList.add('dark');
} else {
  checkbox.checked = false;
  document.body.classList.remove('dark');
}

checkbox.addEventListener('change', function() {
  // 테마를 토글하고 로컬 스토리지에 저장합니다.
  // trans();
  document.body.classList.toggle('dark');
  localStorage.setItem('theme', this.checked ? 'dark' : 'light');
});
</script>

        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li><li class="masthead__menu-item">
              <a href="/posts/">Articles</a>
            </li><li class="masthead__menu-item">
              <a href="/projects/">Projects</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

<script>
  $(function(){
  var $header = $('masthead'); //헤더를 변수에 넣기
  var $page = $('.initial-content'); //색상이 변할 부분
  var $window = $(window);
  var pageOffsetTop = $page.offset().top;//색상 변할 부분의 top값 구하기
  
  $window.resize(function(){ //반응형을 대비하여 리사이즈시 top값을 다시 계산
    pageOffsetTop = $page.offset().top;
  });
  
  $window.on('scroll', function(){ //스크롤시
    var scrolled = $window.scrollTop() >= pageOffsetTop; //스크롤된 상태; true or false
    $header.toggleClass('down', scrolled); //클래스 토글
  });
});

// var menuToggleButton = document.querySelector("button.toggle");
// var menuTarget = document.querySelector(".side-menu");
// var menuBlock = document.querySelector("menu");

// function toggleMenuVisibility(){
// 	menuTarget.classList.toggle("side-menu--active");
// 	animateCSS(".menu", "fadeIn");
// }

// function animateCSS(element, animationName, callback) {
//     var node = document.querySelector(element)
//     node.classList.add('animated', animationName)

//     function handleAnimationEnd() {
//         node.classList.remove('animated', animationName)
//         node.removeEventListener('animationend', handleAnimationEnd)

//         if (typeof callback === 'function') callback()
//     }

//     node.addEventListener('animationend', handleAnimationEnd)
// }

// menuToggleButton.addEventListener('click', toggleMenuVisibility);

// Dark mode toggle

var checkbox = document.querySelector('input[name=theme]');

// 페이지 로드 시 로컬 스토리지에서 테마 설정을 불러옵니다.
if (localStorage.getItem('theme') === 'dark') {
  checkbox.checked = true;
  document.body.classList.add('dark');
} else {
  checkbox.checked = false;
  document.body.classList.remove('dark');
}

checkbox.addEventListener('change', function() {
  // 테마를 토글하고 로컬 스토리지에 저장합니다.
  // trans();
  document.body.classList.toggle('dark');
  localStorage.setItem('theme', this.checked ? 'dark' : 'light');
});


// let trans = () => {
//   document.documentElement.classList.add('transition');
//   window.setTimeout(() => {
//     document.documentElement.classList.remove('transition');
//   }, 500);
// }
</script>

    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[RxSwift] 2. 개념 및 예제">
    <meta itemprop="description" content="1. Observable &amp; Observer  데이터를 연결해줄 수 있는 이벤트가 있고, 이 이벤트에 따라 변경되는 뷰, 로직이 있다.  즉 이벤트를 방출할 수 있는 Observable가 있고, 이벤트를 처리하는 Observer가 있다.  Observable와 Observer를 통해 데이터의 흐름(=Stream)을 통제할 수 있고  Operator를 통해 Stream을 변경, 조작할 수 있다.사용자에게 텍스트 필드로 입력값을 받아서, 해당 입력값으로 닉네임을 저장할 때 아래의 그림과 같다.예시로 표현하자면 유투버(Observable)은 영상을 올리고, 구독자(Observer)는 그 영상을 구독하고 알림을 받는다.반대로 구독자(Observer)는 영상을 올리고 유투버(Observable)가 그 영상을 구독할 수 없다,// 가능한 방식nicknameTextField.rx.text            // ControlProperty&lt;String&gt; - UIKit 요소를 Rx로 다룰 수 있게 만든 특별한 Observable    .orEmpty    .withUnretained(self)            // 메모리 누수 방지 + self 캡처    .bind(onNext: { vc, value in     // 텍스트 변경시마다 nickname에 저장        vc.nickname = value    })    .disposed(by: disposeBag)        // 구독해제는 disposeBag에 맞김// 불가능한 방식nicknameTextField.rx.text = nickname  Observable은 subscribe를 하지 못하기 때문에 이벤트 방출만 할 수 있고 이벤트에 대한 처리는 할 수 없다.  Observer역시 받은 이벤트를 다른 Observer에게 전달하지 못한다.  nicknameTextField.rx.text = nickname 처럼 (Observable)에 바로 nickname이벤트 전달이 안된다.  이를 해결하기 위해 Observer와 Observable 역할을 모두 할 수 있는 Subject가 등장하였다.Subject  Subject는 이벤트를 발행(emit)하고 구독(subscribe)모두 할 수 있는 중간 다리 역할을 한다.          Observable처럼 이벤트를 방출할 수 있고      Observer처럼 다른 Observable로부터 이벤트를 받을 수 있다.      즉 입출력이 모두 가능한 특별한 Observable 이다.        Subject는 4가지 종류가 있다.          Publish Subject: 구독 이후에 발생한 이벤트만 전달      Behavior Subject: 구독 시 마지막 이벤트 + 이후 이벤트 전달      Replay Subject: 지정한 수만큼 과거 이벤트를 버퍼로 저장해 구독 시 전달      Async Subject: 완료 시점에 발생한 마지막 값만 전달        하지만 UI에 좀 더 적합한 형태가 필요하였고 Subject를 Wrapping한 Relay를 제공한다.Relay  Relay는 두 가지 종류가 있다.          Publish Relay      Behavior Relay        Subject와 거의 유사하지만 UI에 특화된 형태이다.  Subject와의 가장 큰 차이점은:          Relay는 .completed와 .error 이벤트를 전달하거나 처리하지 않는다.      ❓왜 .error와 .completed를 막았을까?  일반적인 Subject는 .onNext, .onCompleted, .onError 3가지 이벤트를 처리한다.  그러나 UI에서 사용하는 스트림은 에러나 종료가 발생하지 않고 계속 살아 있어야 한다.  만약 .error 또는 .completed 이벤트가 전달되면          스트림이 종료(disposed)되고      이후 .next 이벤트를 받을 수 없고      Rx의 반응형 업데이트 흐름이 끊기게 된다.      Relay 주요 특징  .next 이벤트만 전달하며, accept(_:) 메서드를 통해 값을 방출한다.  .error, .completed는 전달하지 않기 때문에 dispose되지 않습니다.          그렇기에 Relay는 명시적으로 disposeBag에 담거나, deinit시점에 수동으로 정리해주어야 한다.        항상 살아 있는 스트림이므로 UI 바인딩에 안정적으로 사용된다.Driver  UI 바인딩 특화된 Observable로, 메인스레드 보장 + 에러 무시 + 공유를 기본으로 가진 RXCocoa 전용 타입이다.          메인스레드 보장 -&gt; .observe(on: MainScheduler.instance)가 내장      에러 발생 x -&gt; .onError가 자동으로 무시되거나 기본값으로 대체됨      공유(share) -&gt; 여러 곳에서 구독해도 side effect 없이 공유됨 (hot observable)      Subscrive만 가능하고 값 변경 불가      bind와 다르게 stream 공유가 된다.                  bind는 subscribe의 별칭          drive는 내부적으로 share(replay: 1, scope: .whileConnected)가 구현되어 있다.                    Driver가 필요한 이유  일반 Observable은          UI 스레드 보장 안되고      에러 발생시 스트림 끈힉고      매 구독마다 실행(side effect)이 발생할 수 있다.        그래서 UI에 직접 바인딩시 Driver가 훨씬 안전하다.  Relay는 값을 저장 &amp; 전달하는(Input)용  Driver는 UI 바인딩에 최적화된 Observable(Output)용            항목      Relay      Driver                  주 용도      ViewModel Input 처리      ViewModel → View Output 전달              에러 처리      .error 불가      .error 불가 + 자동 대체 필요              스레드 보장      ❌ MainScheduler 보장 없음      ✅ 항상 MainScheduler에서 실행              공유 여부      ❌ 직접 .share() 필요      ✅ 내부적으로 share(replay:1) 적용됨              값 수동 전달      ✅ .accept() 사용 가능      ❌ 수동 값 전달 불가 (drive로만 가능)              bind 가능 대상      Relay, Binder 등      Binder, drive(to:)      구독 방식1. Subscribebutton.rx.tap // ControlEvent&lt;Void&gt; (Observable&lt;Void&gt;를 래핑한 타입)으로 내부적으로 .error 이벤트를 방출하지 않도록 설계되어 있어 스트림이 끊기지 않는다    .observe(on: MainScheduler.instance)     .withUnretained(self)    .subscribe { vc, _ in        vc.label.text = &quot;hello world    }    .disposed(by: disposeBag)  button.rx.tap은 Observable 타입의 ControlEvent 버튼이 탭될 때마다 이벤트를 방출한다.  이 Observable를 구독한다.  Background Schedular에서 동작할 가능성(네트워크 통신)이 있기 때문에 Observable 데이터 흐름을 MainSchedular(메인 스레드)에서 동작할 수 있도록 변경한다.2. bind// bind(onNext:)button.rx.tap     .withUnretained(self)    .bind(onNext: { vc, _ in        vc.label.text = &quot;hello&quot;    })    .disposed(by: disposeBag)  subscribe와 유사하지만 MainSchedular(메인 스레드)동작 보장과 Error 이벤트를 방출하지 않는 특성을 통해 스트림이 끊기지 않는다.// bind(to:)// 예시1button.rx.tap // ControlEvent&lt;Void&gt; (Observable&lt;Void&gt;를 래핑한 타입)    .map { &quot;hello world&quot; }    .bind(to: label.rx.text)     .disposed(by: disposeBag)// 예시2viewModel.nickname // Observable&lt;String&gt;    .bind(to: nicknameLabel.rx.text) // Binder&lt;String&gt;    .disposed(by: disposeBag)  tap의 ControlEvent를 map Operator를 통해 데이터의 흐름을 조작한다.  ControlEvent 타입이 String 타입으로 변경 되면서 label.rx.text로 간단히 bind 가능하다.  bind(to:), bind(onNext:) 두 형태 모두 메인 스레드에서 실행되고 에러를 무시하기 때문에, UI 바인딩에 적합하다.            bind(to:)      bind(onNext:)                  observable.bind(to: label.rx.text)      observable.bind(onNext: { value in … })              UI 바인딩      클로저에서 값 처리              Binder&lt;T&gt; 타입의 대상에만 가능 자동으로 메인 스레드에서 동작 에러 무시      직접 처리 가능 (print, 가공, 저장 등)에러 무시메인 스레드에서 동작 보장      ✅ 정리  bind(onNext:): 클로저 내에서 직접 처리할 때 사용  bind(to:): 값을 다른 Rx 객체(UI 속성, Relay 등)에 전달할 때 사용  둘 다:          MainSchedular에서 항상 동작하고      .error 이벤트를 방출하지 않으며        → 결과적으로 스트림이 끊기지 않으며, UI 바인딩에 매우 안정적driveviewModel.nicknameDriver // Driver&lt;String&gt;    .drive(nicknameLabel.rx.text)   // drive(to: Binder&lt;String&gt;)    .disposed(by: disposeBag)  drive는 Driver 전용 구독 연산자로,          MainSchedular에서 항상 동작하고      .error 이벤트를 방출하지 않으며      내부적으로 share(replay: 1)가 적용되어 여러 구독자에게 안전하게 공유된다.        bind(to:)와 유사하지만 Driver의 안정성을 최대한 활용하기 위한 전용 바인딩 방법이다.  오직 Driver 타입에서만 사용할 수 있으며, 일반 Observable에는 사용할 수 없다.에제1. 구성  보내는 것 - Observable  연결 - subScribe  중간처리 - 연산자2. 큰 개념보내는 것 - 옵저버블(총알 = 구독 가능한 것)  Observable          가장 기본 베이스, 생성하자마자 이벤트를 전달한다      .onNext(), .onError(), .onCompleted()를 통해 이벤트를 받을 수 있다      .subscribe()를 통해 이벤트를 발행 가능      이벤트를 정의하고, 정적인 스트림 생성(한방향: 선언 -&gt; 구독)         // 1. Observable은 가장 기본적인 Rx 스트림 // 내부에서 [1, 2, 3]을 한번 방출하고 끝 let observable = Observable&lt;[Int]&gt;.just([1, 2, 3])     // 2. subscribe를 통해 값을 받아 처리 observable     .subscribe(         onNext: { value in             print(&quot;Received: \(value)&quot;)         },         onError: { error in             print(&quot;❌ onError: \(error.localizedDescription)&quot;)         },         onCompleted: {             print(&quot;✅ Stream Completed&quot;)         },         onDisposed: {             print(&quot;🧹 Subscription Disposed&quot;)         }     ).disposed(by: disposeBag)        Subject  기본 Observable은 생성될 때 방출할 값이 정해져 있고, 외부에서 값을 주입할 수 없다. 그래서 외부에서 직접 값을 전달하고 싶을 때는 Subject를 사용한다.  Subject는 값을 방출할 수도 있고, 다른 Observable처럼 구독도 받을 수 있는 양방향 통로다.  Observable(구독 가능한 것)이면서 Observer(관찰자)  일단 연결을 해두고 원하는 시점에 이벤트를 보낸다.  외부에서 직접 값을 넣고, 동적인 스트림 생성(양방향)    // &quot;Hello&quot;라는 값을 한번 방출하고 끝. 외부에서 바꿀 수 없음Observable.just(&quot;Hello&quot;)    // 외부에서 onNext(&quot;Hello&quot;)로 값을 보내면 그때 스트림이 시작됨PublishSubject&lt;String&gt;()              BehaviorSubject - 상태                  초기값 필수          구독 시, 가장 최신값 1개를 즉시 전달받음          이후에는 일반 Observable처럼 .onNext 이벤트를 수신                // 1. BehaviorSubject는 초기값을 설정하고, 구독 시 가장 최근 값을 전달let behaviorSubject = BehaviorSubject&lt;String&gt;(value: &quot;초기값&quot;)      // 2. 구독 설정 → &quot;초기값&quot;이 바로 전달됨behaviorSubject    .subscribe(onNext: { print(&quot;BehaviorSubject:&quot;, $0) })    .disposed(by: disposeBag)      // 3. 새로운 이벤트 전달behaviorSubject.onNext(&quot;새로운 값&quot;)                    PublishSubjcet - 단방향 이벤트                  구독 이후 이벤트만 받음(초기값 없음)          주로 이벤트 전달용                // 1. PublishSubject는 구독 이후에 발생한 이벤트만 전달let publishSubject = PublishSubject&lt;String&gt;()    // 2. 구독 설정publishSubject    .subscribe(onNext: { print(&quot;PublishSubject:&quot;, $0) })    .disposed(by: disposeBag)    // 3. 이벤트 직접 발생 (구독 이후라 전달됨)publishSubject.onNext(&quot;첫 번째 이벤트&quot;)    // subject는 구독을 받고, 동시에 외부에서 onNext로 값을 직접 보낼 수 있는 Observable// Observable처럼 구독자를 가질 수 있고, Observer처럼 값을 외부에서 직접 넣을 수 있음 (onNext() 등)                      Relay          Subject의 변형으로, error가 없고 UI바인딩에 최적화      PublishRelay                      단방향 이벤트 전달(버튼 클릭)        // 1. PublishRelay는 error가 없고 UI에 최적화된 Subjectlet publishRelay = PublishRelay&lt;String&gt;()      // 2. 구독 설정publishRelay    .subscribe(onNext: { print(&quot;PublishRelay:&quot;, $0) })    .disposed(by: disposeBag)      // 3. 이벤트 발생 → accept()로 전달publishRelay.accept(&quot;이벤트 발생!&quot;)                    BehaviorRelay              상태 저장, 초기값 필수 -&gt; accept() 사용        // 1. BehaviorRelay는 초기값이 필요하며, 상태 저장에 적합let behaviorRelay = BehaviorRelay&lt;String&gt;(value: &quot;기본값&quot;)      // 2. 구독 설정 → &quot;기본값&quot;이 바로 전달됨behaviorRelay    .subscribe(onNext: { print(&quot;BehaviorRelay:&quot;, $0) })    .disposed(by: disposeBag)      // 3. 값 업데이트 → accept() 사용behaviorRelay.accept(&quot;업데이트된 값&quot;)                      Driver          메인스레드, share(1)              UI 바인딩 전용으로 사용되는 옵저버블           // 1. Relay에서 값을 가져와 Driver로 변환 let textRelay = BehaviorRelay&lt;String&gt;(value: &quot;Hello&quot;)       // 2. Driver로 변환 (에러 없이, MainThread에서 작동) let textDriver = textRelay.asDriver()       // 3. UI 요소에 drive (drive는 MainThread에서 UI 바인딩 시 사용) textDriver     .drive(label.rx.text)     .disposed(by: disposeBag)                    구독  subscribe(onNext:)          next, error, completed 시퀀스 이벤트를 받을 수 있다      직점 onError 처리 가능하다      viewModel 내부, 로직 처리, 이벤트 감지, 에러 대응      Disposable 반환해야한다      모든 Observable계열 구독 가능              bind(onNext:) 보다 범용적, 완료/에러 받을 수 있다         // 1. onNext만 사용하는 기본적인 구독 let observable = Observable.just(&quot;Hello, RxSwift!&quot;)       observable     .subscribe(onNext: { value in         print(&quot;onNext:&quot;, value)     })     .disposed(by: disposeBag)       // 2. onNext, onError, onCompleted 모두 명시 let observable = Observable&lt;String&gt;.create { observer in     observer.onNext(&quot;첫 번째 이벤트&quot;)     observer.onCompleted()     return Disposables.create() }       observable     .subscribe(         onNext: { print(&quot;onNext:&quot;, $0) },         onError: { print(&quot;onError:&quot;, $0.localizedDescription) },         onCompleted: { print(&quot;onCompleted&quot;) },         onDisposed: { print(&quot;onDisposed&quot;) }     )     .disposed(by: disposeBag)                      bind(to:)          UI 컴포넌트 프로퍼티에 바인딩할 때 사용      구독과 동시에 값이 특정 속성에 직접 들어가는 방식      값을 특정UI의 속성에 직접 구독해서 바인딩          // label.text = title처럼 자동으로 연결하는 직접 바인딩 방식  viewModel.title   .bind(to: label.rx.text)   .disposed(by: disposeBag)                      bind(onNext:)          단순히 이벤트를 수신하고 구독 형태      내부에 명시적으로 처리 로직을 작성해야 함      값을 받아서 직접 처리(프린트, 로직 실행)하는 방식으로 구독          viewModel.title   .bind(onNext: { text in   print(&quot;값 출력: \(text)&quot;)   })   .disposed(by: disposeBag)                          비교     // 1. 자동 UI 업데이트 (bind to UI) viewModel.username // Observable&lt;String&gt;     .bind(to: label.rx.text) // 📲 label.text = 값     .disposed(by: disposeBag) // 2. 내가 직접 프린트 (bind with closure) viewModel.username     .bind(onNext: { name in         print(&quot;유저 이름은 \(name)&quot;)     })     .disposed(by: disposeBag)        drive (RxCocoa 전용 UI 바인딩 방식)          Driver 타입만 사용할 수 있는 구독 방식      UI 업데이트에 특화 → MainThread 보장 + 에러 자동 무시 + 공유(share) 내장      .asDriver(onErrorJustReturn:) 또는 .asDriver()를 통해 변환 후 사용      UI 요소(UILabel, UIButton, UISwitch, etc.)에 직접 바인딩 가능      내부적으로 bind(to:)와 매우 유사하지만, Driver만 사용할 수 있음         // 예시 1: ViewModel의 Driver&lt;String&gt;을 UILabel에 바인딩 viewModel.nicknameDriver     .drive(nicknameLabel.rx.text)     .disposed(by: disposeBag) // 예시 2: ViewModel의 Driver&lt;Void&gt;을 버튼 클릭에 바인딩 viewModel.didTapSomething     .drive(onNext: {         print(&quot;탭 감지됨!&quot;)     })     .disposed(by: disposeBag)      Reference  https://so-kyte.tistory.com/192">
    <meta itemprop="datePublished" content="2025-04-21T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="http://localhost:4000/RxSwift-RxSwift-2/" class="u-url" itemprop="url">[RxSwift] 2. 개념 및 예제
</a>
          </h1>
          <footer class="page__meta">
            
  



  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags : </strong>
    <span class="archive__item-tags">
    
    
    
      <a class="posttag tagged" href="/posts/?tag=ReactiveX">ReactiveX</a>
    
    
    
    
      <a class="posttag tagged" href="/posts/?tag=RxSwift">RxSwift</a>
    
    
    </span>  
  </p>



<!--  -->
            

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Date :</strong> <time class="dt-published" datetime="2025-04-21T00:00:00+00:00">April 21, 2025</time></p>

          </footer>
        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <p><img src="/assets/img/2025-03-25-%5BRxSwift%5D-RxSwift-1/image.png" alt="커스텀셀" width="70%" /></p>

<h2 id="1-observable--observer">1. Observable &amp; Observer</h2>
<ul>
  <li>데이터를 연결해줄 수 있는 이벤트가 있고, 이 이벤트에 따라 변경되는 뷰, 로직이 있다.</li>
  <li>즉 이벤트를 방출할 수 있는 Observable가 있고, 이벤트를 처리하는 Observer가 있다.</li>
  <li>Observable와 Observer를 통해 데이터의 흐름(=Stream)을 통제할 수 있고</li>
  <li>Operator를 통해 Stream을 변경, 조작할 수 있다.</li>
</ul>

<h3 id="사용자에게-텍스트-필드로-입력값을-받아서-해당-입력값으로-닉네임을-저장할-때-아래의-그림과-같다">사용자에게 텍스트 필드로 입력값을 받아서, 해당 입력값으로 닉네임을 저장할 때 아래의 그림과 같다.</h3>

<p><img src="/assets/img/2025-04-21-%5BRxSwift%5D-RxSwift-2/good.png" alt="커스텀셀" width="70%" /></p>

<p><img src="/assets/img/2025-04-21-%5BRxSwift%5D-RxSwift-2/good-9965934.png" alt="커스텀셀" width="70%" /><br />
예시로 표현하자면 유투버(Observable)은 영상을 올리고, 구독자(Observer)는 그 영상을 구독하고 알림을 받는다.</p>

<p><img src="/assets/img/2025-04-21-%5BRxSwift%5D-RxSwift-2/bad2-9966743.png" alt="커스텀셀" width="70%" /><br />
반대로 구독자(Observer)는 영상을 올리고 유투버(Observable)가 그 영상을 구독할 수 없다,</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 가능한 방식</span>
<span class="n">nicknameTextField</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span>            <span class="c1">// ControlProperty&lt;String&gt; - UIKit 요소를 Rx로 다룰 수 있게 만든 특별한 Observable</span>
    <span class="o">.</span><span class="n">orEmpty</span>
    <span class="o">.</span><span class="nf">withUnretained</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>            <span class="c1">// 메모리 누수 방지 + self 캡처</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">vc</span><span class="p">,</span> <span class="n">value</span> <span class="k">in</span>     <span class="c1">// 텍스트 변경시마다 nickname에 저장</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">nickname</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>        <span class="c1">// 구독해제는 disposeBag에 맞김</span>

<span class="c1">// 불가능한 방식</span>
<span class="n">nicknameTextField</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">nickname</span>
</code></pre></div></div>
<ul>
  <li>Observable은 subscribe를 하지 못하기 때문에 이벤트 방출만 할 수 있고 이벤트에 대한 처리는 할 수 없다.</li>
  <li>Observer역시 받은 이벤트를 다른 Observer에게 전달하지 못한다.</li>
  <li>nicknameTextField.rx.text = nickname 처럼 (Observable)에 바로 nickname이벤트 전달이 안된다.</li>
  <li>이를 해결하기 위해 Observer와 Observable 역할을 모두 할 수 있는 Subject가 등장하였다.</li>
</ul>

<hr />

<h2 id="subject">Subject</h2>
<ul>
  <li>Subject는 이벤트를 발행(emit)하고 구독(subscribe)모두 할 수 있는 중간 다리 역할을 한다.
    <ul>
      <li>Observable처럼 이벤트를 방출할 수 있고</li>
      <li>Observer처럼 다른 Observable로부터 이벤트를 받을 수 있다.</li>
      <li>즉 입출력이 모두 가능한 특별한 Observable 이다.</li>
    </ul>
  </li>
  <li>Subject는 4가지 종류가 있다.
    <ul>
      <li>Publish Subject: 구독 이후에 발생한 이벤트만 전달</li>
      <li>Behavior Subject: 구독 시 마지막 이벤트 + 이후 이벤트 전달</li>
      <li>Replay Subject: 지정한 수만큼 과거 이벤트를 버퍼로 저장해 구독 시 전달</li>
      <li>Async Subject: 완료 시점에 발생한 마지막 값만 전달</li>
    </ul>
  </li>
  <li>하지만 UI에 좀 더 적합한 형태가 필요하였고 Subject를 Wrapping한 Relay를 제공한다.</li>
</ul>

<hr />

<h2 id="relay">Relay</h2>
<ul>
  <li>Relay는 두 가지 종류가 있다.
    <ul>
      <li>Publish Relay</li>
      <li>Behavior Relay</li>
    </ul>
  </li>
  <li>Subject와 거의 유사하지만 UI에 특화된 형태이다.</li>
  <li>Subject와의 가장 큰 차이점은:
    <ul>
      <li>Relay는 .completed와 .error 이벤트를 전달하거나 처리하지 않는다.</li>
    </ul>
  </li>
</ul>

<h2 id="왜-error와-completed를-막았을까">❓왜 .error와 .completed를 막았을까?</h2>
<ul>
  <li>일반적인 Subject는 .onNext, .onCompleted, .onError 3가지 이벤트를 처리한다.</li>
  <li>그러나 UI에서 사용하는 스트림은 에러나 종료가 발생하지 않고 계속 살아 있어야 한다.</li>
  <li>만약 .error 또는 .completed 이벤트가 전달되면
    <ul>
      <li>스트림이 종료(disposed)되고</li>
      <li>이후 .next 이벤트를 받을 수 없고</li>
      <li>Rx의 반응형 업데이트 흐름이 끊기게 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="relay-주요-특징">Relay 주요 특징</h2>
<ul>
  <li>.next 이벤트만 전달하며, accept(_:) 메서드를 통해 값을 방출한다.</li>
  <li>.error, .completed는 전달하지 않기 때문에 dispose되지 않습니다.
    <ul>
      <li>그렇기에 Relay는 명시적으로 disposeBag에 담거나, deinit시점에 수동으로 정리해주어야 한다.</li>
    </ul>
  </li>
  <li>항상 살아 있는 스트림이므로 UI 바인딩에 안정적으로 사용된다.</li>
</ul>

<hr />

<h2 id="driver">Driver</h2>
<ul>
  <li>UI 바인딩 특화된 Observable로, 메인스레드 보장 + 에러 무시 + 공유를 기본으로 가진 RXCocoa 전용 타입이다.
    <ul>
      <li>메인스레드 보장 -&gt; .observe(on: MainScheduler.instance)가 내장</li>
      <li>에러 발생 x -&gt; .onError가 자동으로 무시되거나 기본값으로 대체됨</li>
      <li>공유(share) -&gt; 여러 곳에서 구독해도 side effect 없이 공유됨 (hot observable)</li>
      <li>Subscrive만 가능하고 값 변경 불가</li>
      <li>bind와 다르게 stream 공유가 된다.
        <ul>
          <li>bind는 subscribe의 별칭</li>
          <li>drive는 내부적으로 share(replay: 1, scope: .whileConnected)가 구현되어 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="driver가-필요한-이유">Driver가 필요한 이유</h2>
<ul>
  <li>일반 Observable은
    <ul>
      <li>UI 스레드 보장 안되고</li>
      <li>에러 발생시 스트림 끈힉고</li>
      <li>매 구독마다 실행(side effect)이 발생할 수 있다.</li>
    </ul>
  </li>
  <li>그래서 UI에 직접 바인딩시 Driver가 훨씬 안전하다.</li>
  <li>Relay는 값을 저장 &amp; 전달하는(Input)용</li>
  <li>Driver는 UI 바인딩에 최적화된 Observable(Output)용</li>
</ul>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th><code class="language-plaintext highlighter-rouge">Relay</code></th>
      <th><code class="language-plaintext highlighter-rouge">Driver</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>주 용도</td>
      <td>ViewModel <strong>Input 처리</strong></td>
      <td>ViewModel → View <strong>Output 전달</strong></td>
    </tr>
    <tr>
      <td>에러 처리</td>
      <td><code class="language-plaintext highlighter-rouge">.error</code> 불가</td>
      <td><code class="language-plaintext highlighter-rouge">.error</code> 불가 + <strong>자동 대체 필요</strong></td>
    </tr>
    <tr>
      <td>스레드 보장</td>
      <td>❌ MainScheduler 보장 없음</td>
      <td>✅ 항상 MainScheduler에서 실행</td>
    </tr>
    <tr>
      <td>공유 여부</td>
      <td>❌ 직접 <code class="language-plaintext highlighter-rouge">.share()</code> 필요</td>
      <td>✅ 내부적으로 <code class="language-plaintext highlighter-rouge">share(replay:1)</code> 적용됨</td>
    </tr>
    <tr>
      <td>값 수동 전달</td>
      <td>✅ <code class="language-plaintext highlighter-rouge">.accept()</code> 사용 가능</td>
      <td>❌ 수동 값 전달 불가 (<code class="language-plaintext highlighter-rouge">drive</code>로만 가능)</td>
    </tr>
    <tr>
      <td>bind 가능 대상</td>
      <td><code class="language-plaintext highlighter-rouge">Relay</code>, <code class="language-plaintext highlighter-rouge">Binder</code> 등</td>
      <td><code class="language-plaintext highlighter-rouge">Binder</code>, <code class="language-plaintext highlighter-rouge">drive(to:)</code></td>
    </tr>
  </tbody>
</table>

<hr />

<p><br /><br /><br /></p>

<!-- |  RxSwift  |  RxCocoa   |
| :-------: | :--------: |
| Subscribe | Bind/Drive |
|  Subject  |   Relay    | -->

<h2 id="구독-방식">구독 방식</h2>

<h3 id="1-subscribe">1. Subscribe</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">button</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span> <span class="c1">// ControlEvent&lt;Void&gt; (Observable&lt;Void&gt;를 래핑한 타입)으로 내부적으로 .error 이벤트를 방출하지 않도록 설계되어 있어 스트림이 끊기지 않는다</span>
    <span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">MainScheduler</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span> 
    <span class="o">.</span><span class="nf">withUnretained</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="o">.</span><span class="n">subscribe</span> <span class="p">{</span> <span class="n">vc</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"hello world
    }
    .disposed(by: disposeBag)
</span></code></pre></div></div>
<ul>
  <li>button.rx.tap은 Observable<Void> 타입의 ControlEvent 버튼이 탭될 때마다 이벤트를 방출한다.</Void></li>
  <li>이 Observable를 구독한다.</li>
  <li>Background Schedular에서 동작할 가능성(네트워크 통신)이 있기 때문에 Observable 데이터 흐름을 MainSchedular(메인 스레드)에서 동작할 수 있도록 변경한다.</li>
</ul>

<h2 id="2-bind">2. bind</h2>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bind(onNext:)</span>
<span class="n">button</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span> 
    <span class="o">.</span><span class="nf">withUnretained</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">vc</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"hello"</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>subscribe와 유사하지만 MainSchedular(메인 스레드)동작 보장과 Error 이벤트를 방출하지 않는 특성을 통해 스트림이 끊기지 않는다.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bind(to:)</span>
<span class="c1">// 예시1</span>
<span class="n">button</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span> <span class="c1">// ControlEvent&lt;Void&gt; (Observable&lt;Void&gt;를 래핑한 타입)</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="s">"hello world"</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">label</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> 
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
<span class="c1">// 예시2</span>
<span class="n">viewModel</span><span class="o">.</span><span class="n">nickname</span> <span class="c1">// Observable&lt;String&gt;</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">nicknameLabel</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="c1">// Binder&lt;String&gt;</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>tap의 ControlEvent<Void>를 map Operator를 통해 데이터의 흐름을 조작한다.</Void></li>
  <li>ControlEvent<Void> 타입이 String 타입으로 변경 되면서 label.rx.text로 간단히 bind 가능하다.</Void></li>
  <li>bind(to:), bind(onNext:) 두 형태 모두 메인 스레드에서 실행되고 에러를 무시하기 때문에, UI 바인딩에 적합하다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">bind(to:)</th>
      <th style="text-align: center">bind(onNext:)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">observable.bind(to: label.rx.text)</td>
      <td style="text-align: center">observable.bind(onNext: { value in … })</td>
    </tr>
    <tr>
      <td style="text-align: center">UI 바인딩</td>
      <td style="text-align: center">클로저에서 값 처리</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Binder&lt;T&gt;</code> 타입의 대상에만 가능 자동으로 메인 스레드에서 동작 에러 무시</td>
      <td style="text-align: center">직접 처리 가능 (print, 가공, 저장 등)<br />에러 무시<br />메인 스레드에서 동작 보장</td>
    </tr>
  </tbody>
</table>

<h3 id="-정리">✅ 정리</h3>
<ul>
  <li>bind(onNext:): 클로저 내에서 직접 처리할 때 사용</li>
  <li>bind(to:): 값을 다른 Rx 객체(UI 속성, Relay 등)에 전달할 때 사용</li>
  <li>둘 다:
    <ul>
      <li>MainSchedular에서 항상 동작하고</li>
      <li>.error 이벤트를 방출하지 않으며</li>
    </ul>
  </li>
  <li>→ 결과적으로 스트림이 끊기지 않으며, UI 바인딩에 매우 안정적</li>
</ul>

<h2 id="drive">drive</h2>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">viewModel</span><span class="o">.</span><span class="n">nicknameDriver</span> <span class="c1">// Driver&lt;String&gt;</span>
    <span class="o">.</span><span class="nf">drive</span><span class="p">(</span><span class="n">nicknameLabel</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>   <span class="c1">// drive(to: Binder&lt;String&gt;)</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>drive는 Driver 전용 구독 연산자로,
    <ul>
      <li>MainSchedular에서 항상 동작하고</li>
      <li>.error 이벤트를 방출하지 않으며</li>
      <li>내부적으로 share(replay: 1)가 적용되어 여러 구독자에게 안전하게 공유된다.</li>
    </ul>
  </li>
  <li>bind(to:)와 유사하지만 Driver의 안정성을 최대한 활용하기 위한 전용 바인딩 방법이다.</li>
  <li>오직 Driver 타입에서만 사용할 수 있으며, 일반 Observable에는 사용할 수 없다.</li>
</ul>

<!-- ## 1. Rx란?
파이프라인 연결이다 -->

<hr />

<h2 id="에제">에제</h2>

<h2 id="1-구성">1. 구성</h2>
<ul>
  <li>보내는 것 - Observable</li>
  <li>연결 - subScribe</li>
  <li>중간처리 - 연산자</li>
</ul>

<h2 id="2-큰-개념">2. 큰 개념</h2>
<h3 id="보내는-것---옵저버블총알--구독-가능한-것">보내는 것 - 옵저버블(총알 = 구독 가능한 것)</h3>
<ol>
  <li>Observable
    <ul>
      <li>가장 기본 베이스, 생성하자마자 이벤트를 전달한다</li>
      <li>.onNext(), .onError(), .onCompleted()를 통해 이벤트를 받을 수 있다</li>
      <li>.subscribe()를 통해 이벤트를 발행 가능</li>
      <li>이벤트를 정의하고, 정적인 스트림 생성(한방향: 선언 -&gt; 구독)</li>
    </ul>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 1. Observable은 가장 기본적인 Rx 스트림</span>
 <span class="c1">// 내부에서 [1, 2, 3]을 한번 방출하고 끝</span>
 <span class="k">let</span> <span class="nv">observable</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="o">&gt;.</span><span class="nf">just</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    
 <span class="c1">// 2. subscribe를 통해 값을 받아 처리</span>
 <span class="n">observable</span>
     <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span>
         <span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
             <span class="nf">print</span><span class="p">(</span><span class="s">"Received: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
         <span class="p">},</span>
         <span class="nv">onError</span><span class="p">:</span> <span class="p">{</span> <span class="n">error</span> <span class="k">in</span>
             <span class="nf">print</span><span class="p">(</span><span class="s">"❌ onError: </span><span class="se">\(</span><span class="n">error</span><span class="o">.</span><span class="n">localizedDescription</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
         <span class="p">},</span>
         <span class="nv">onCompleted</span><span class="p">:</span> <span class="p">{</span>
             <span class="nf">print</span><span class="p">(</span><span class="s">"✅ Stream Completed"</span><span class="p">)</span>
         <span class="p">},</span>
         <span class="nv">onDisposed</span><span class="p">:</span> <span class="p">{</span>
             <span class="nf">print</span><span class="p">(</span><span class="s">"🧹 Subscription Disposed"</span><span class="p">)</span>
         <span class="p">}</span>
     <span class="p">)</span><span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Subject</li>
</ol>

<ul>
  <li>기본 Observable은 생성될 때 방출할 값이 정해져 있고, 외부에서 값을 주입할 수 없다. 그래서 외부에서 직접 값을 전달하고 싶을 때는 Subject를 사용한다.</li>
  <li>Subject는 값을 방출할 수도 있고, 다른 Observable처럼 구독도 받을 수 있는 양방향 통로다.</li>
  <li>Observable(구독 가능한 것)이면서 Observer(관찰자)</li>
  <li>일단 연결을 해두고 원하는 시점에 이벤트를 보낸다.</li>
  <li>외부에서 직접 값을 넣고, 동적인 스트림 생성(양방향)
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// "Hello"라는 값을 한번 방출하고 끝. 외부에서 바꿀 수 없음</span>
<span class="kt">Observable</span><span class="o">.</span><span class="nf">just</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
    
<span class="c1">// 외부에서 onNext("Hello")로 값을 보내면 그때 스트림이 시작됨</span>
<span class="kt">PublishSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">()</span>
</code></pre></div>    </div>
    <ul>
      <li>BehaviorSubject - 상태
        <ul>
          <li>초기값 필수</li>
          <li>구독 시, 가장 최신값 1개를 즉시 전달받음</li>
          <li>이후에는 일반 Observable처럼 .onNext 이벤트를 수신</li>
        </ul>

        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. BehaviorSubject는 초기값을 설정하고, 구독 시 가장 최근 값을 전달</span>
<span class="k">let</span> <span class="nv">behaviorSubject</span> <span class="o">=</span> <span class="kt">BehaviorSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="s">"초기값"</span><span class="p">)</span>
      
<span class="c1">// 2. 구독 설정 → "초기값"이 바로 전달됨</span>
<span class="n">behaviorSubject</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"BehaviorSubject:"</span><span class="p">,</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
      
<span class="c1">// 3. 새로운 이벤트 전달</span>
<span class="n">behaviorSubject</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="s">"새로운 값"</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
      <li>PublishSubjcet - 단방향 이벤트
        <ul>
          <li>구독 이후 이벤트만 받음(초기값 없음)</li>
          <li>주로 이벤트 전달용</li>
        </ul>

        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. PublishSubject는 구독 이후에 발생한 이벤트만 전달</span>
<span class="k">let</span> <span class="nv">publishSubject</span> <span class="o">=</span> <span class="kt">PublishSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">()</span>
    
<span class="c1">// 2. 구독 설정</span>
<span class="n">publishSubject</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"PublishSubject:"</span><span class="p">,</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
    
<span class="c1">// 3. 이벤트 직접 발생 (구독 이후라 전달됨)</span>
<span class="n">publishSubject</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="s">"첫 번째 이벤트"</span><span class="p">)</span>
    
<span class="c1">// subject는 구독을 받고, 동시에 외부에서 onNext로 값을 직접 보낼 수 있는 Observable</span>
<span class="c1">// Observable처럼 구독자를 가질 수 있고, Observer처럼 값을 외부에서 직접 넣을 수 있음 (onNext() 등)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<ol>
  <li>Relay
    <ul>
      <li>Subject의 변형으로, error가 없고 UI바인딩에 최적화</li>
      <li>PublishRelay</li>
    </ul>
    <ul>
      <li>
        <p>단방향 이벤트 전달(버튼 클릭)</p>

        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. PublishRelay는 error가 없고 UI에 최적화된 Subject</span>
<span class="k">let</span> <span class="nv">publishRelay</span> <span class="o">=</span> <span class="kt">PublishRelay</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">()</span>
      
<span class="c1">// 2. 구독 설정</span>
<span class="n">publishRelay</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"PublishRelay:"</span><span class="p">,</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
      
<span class="c1">// 3. 이벤트 발생 → accept()로 전달</span>
<span class="n">publishRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="s">"이벤트 발생!"</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
      <li>BehaviorRelay</li>
      <li>
        <p>상태 저장, 초기값 필수 -&gt; accept() 사용</p>

        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. BehaviorRelay는 초기값이 필요하며, 상태 저장에 적합</span>
<span class="k">let</span> <span class="nv">behaviorRelay</span> <span class="o">=</span> <span class="kt">BehaviorRelay</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="s">"기본값"</span><span class="p">)</span>
      
<span class="c1">// 2. 구독 설정 → "기본값"이 바로 전달됨</span>
<span class="n">behaviorRelay</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"BehaviorRelay:"</span><span class="p">,</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
      
<span class="c1">// 3. 값 업데이트 → accept() 사용</span>
<span class="n">behaviorRelay</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="s">"업데이트된 값"</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Driver
    <ul>
      <li>메인스레드, share(1)</li>
      <li>
        <p>UI 바인딩 전용으로 사용되는 옵저버블</p>

        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="c1">// 1. Relay에서 값을 가져와 Driver로 변환</span>
 <span class="k">let</span> <span class="nv">textRelay</span> <span class="o">=</span> <span class="kt">BehaviorRelay</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="s">"Hello"</span><span class="p">)</span>
      
 <span class="c1">// 2. Driver로 변환 (에러 없이, MainThread에서 작동)</span>
 <span class="k">let</span> <span class="nv">textDriver</span> <span class="o">=</span> <span class="n">textRelay</span><span class="o">.</span><span class="nf">asDriver</span><span class="p">()</span>
      
 <span class="c1">// 3. UI 요소에 drive (drive는 MainThread에서 UI 바인딩 시 사용)</span>
 <span class="n">textDriver</span>
     <span class="o">.</span><span class="nf">drive</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
     <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h3 id="구독">구독</h3>
<ol>
  <li>subscribe(onNext:)
    <ul>
      <li>next, error, completed 시퀀스 이벤트를 받을 수 있다</li>
      <li>직점 onError 처리 가능하다</li>
      <li>viewModel 내부, 로직 처리, 이벤트 감지, 에러 대응</li>
      <li>Disposable 반환해야한다</li>
      <li>모든 Observable계열 구독 가능</li>
      <li>
        <p>bind(onNext:) 보다 범용적, 완료/에러 받을 수 있다</p>

        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 1. onNext만 사용하는 기본적인 구독</span>
 <span class="k">let</span> <span class="nv">observable</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">just</span><span class="p">(</span><span class="s">"Hello, RxSwift!"</span><span class="p">)</span>
      
 <span class="n">observable</span>
     <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"onNext:"</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
     <span class="p">})</span>
     <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
      
 <span class="c1">// 2. onNext, onError, onCompleted 모두 명시</span>
 <span class="k">let</span> <span class="nv">observable</span> <span class="o">=</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;.</span><span class="n">create</span> <span class="p">{</span> <span class="n">observer</span> <span class="k">in</span>
     <span class="n">observer</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="s">"첫 번째 이벤트"</span><span class="p">)</span>
     <span class="n">observer</span><span class="o">.</span><span class="nf">onCompleted</span><span class="p">()</span>
     <span class="k">return</span> <span class="kt">Disposables</span><span class="o">.</span><span class="nf">create</span><span class="p">()</span>
 <span class="p">}</span>
      
 <span class="n">observable</span>
     <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span>
         <span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"onNext:"</span><span class="p">,</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">},</span>
         <span class="nv">onError</span><span class="p">:</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"onError:"</span><span class="p">,</span> <span class="nv">$0</span><span class="o">.</span><span class="n">localizedDescription</span><span class="p">)</span> <span class="p">},</span>
         <span class="nv">onCompleted</span><span class="p">:</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"onCompleted"</span><span class="p">)</span> <span class="p">},</span>
         <span class="nv">onDisposed</span><span class="p">:</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"onDisposed"</span><span class="p">)</span> <span class="p">}</span>
     <span class="p">)</span>
     <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>bind(to:)
    <ul>
      <li>UI 컴포넌트 프로퍼티에 바인딩할 때 사용</li>
      <li>구독과 동시에 값이 특정 속성에 직접 들어가는 방식</li>
      <li>값을 특정UI의 속성에 직접 구독해서 바인딩
        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// label.text = title처럼 자동으로 연결하는 직접 바인딩 방식</span>
  <span class="n">viewModel</span><span class="o">.</span><span class="n">title</span>
   <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">label</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
   <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>bind(onNext:)
    <ul>
      <li>단순히 이벤트를 수신하고 구독 형태</li>
      <li>내부에 명시적으로 처리 로직을 작성해야 함</li>
      <li>값을 받아서 직접 처리(프린트, 로직 실행)하는 방식으로 구독
        <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">viewModel</span><span class="o">.</span><span class="n">title</span>
   <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">text</span> <span class="k">in</span>
   <span class="nf">print</span><span class="p">(</span><span class="s">"값 출력: </span><span class="se">\(</span><span class="n">text</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
   <span class="p">})</span>
   <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>비교</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 1. 자동 UI 업데이트 (bind to UI)</span>
 <span class="n">viewModel</span><span class="o">.</span><span class="n">username</span> <span class="c1">// Observable&lt;String&gt;</span>
     <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">label</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="c1">// 📲 label.text = 값</span>
     <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>

 <span class="c1">// 2. 내가 직접 프린트 (bind with closure)</span>
 <span class="n">viewModel</span><span class="o">.</span><span class="n">username</span>
     <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">name</span> <span class="k">in</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"유저 이름은 </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
     <span class="p">})</span>
     <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>drive (RxCocoa 전용 UI 바인딩 방식)
    <ul>
      <li>Driver 타입만 사용할 수 있는 구독 방식</li>
      <li>UI 업데이트에 특화 → MainThread 보장 + 에러 자동 무시 + 공유(share) 내장</li>
      <li>.asDriver(onErrorJustReturn:) 또는 .asDriver()를 통해 변환 후 사용</li>
      <li>UI 요소(UILabel, UIButton, UISwitch, etc.)에 직접 바인딩 가능</li>
      <li>내부적으로 bind(to:)와 매우 유사하지만, Driver만 사용할 수 있음</li>
    </ul>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 예시 1: ViewModel의 Driver&lt;String&gt;을 UILabel에 바인딩</span>
 <span class="n">viewModel</span><span class="o">.</span><span class="n">nicknameDriver</span>
     <span class="o">.</span><span class="nf">drive</span><span class="p">(</span><span class="n">nicknameLabel</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
     <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>

 <span class="c1">// 예시 2: ViewModel의 Driver&lt;Void&gt;을 버튼 클릭에 바인딩</span>
 <span class="n">viewModel</span><span class="o">.</span><span class="n">didTapSomething</span>
     <span class="o">.</span><span class="nf">drive</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>
         <span class="nf">print</span><span class="p">(</span><span class="s">"탭 감지됨!"</span><span class="p">)</span>
     <span class="p">})</span>
     <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="reference">Reference</h2>
<ul>
  <li>https://so-kyte.tistory.com/192</li>
</ul>

        
      </section>

      

      
  <nav class="pagination">
    
      <a href="/Haruhancut-Haruhancut-1/" class="pagination--pager" title="[하루한컷] 1. iOS 카카오 로그인
">Previous</a>
    
    
      <a href="/UIKit-delegate/" class="pagination--pager" title="[UIKit] Delegate Pattern란?
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/indextrown" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 indextrown. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

<script src="/assets/js/jqcloud.min.js" charset="utf-8"></script>
      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>



    <script>
  'use strict';

  var theme = localStorage.getItem('theme');

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'indextrown/indextrown.github.io');
    script.setAttribute('issue-term', 'pathname');
    

    if (theme === 'dark') {
      script.setAttribute('theme', 'github-dark');
    } else {
      script.setAttribute('theme', 'github-light');
    }
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





    <aside class="sidebar__home">
      <a href="/posts">
        <div style="font-size: 0.5rem;"><i class="fas fa-h-square fa-5x"></i></div>
      </a>
    </aside>

    <aside class="sidebar__top">
      <a href="#site-nav">
        <div style="font-size: 0.5rem;"><i class="fas fa-caret-square-up fa-5x"></i></div>
      </a>
    </aside>

    <aside class="sidebar__bottom">
      <a href="#footer">
        <div style="font-size: 0.5rem;"><i class="fas fa-caret-square-down fa-5x"></i></div>
      </a>
    </aside>

  </body>
</html>
