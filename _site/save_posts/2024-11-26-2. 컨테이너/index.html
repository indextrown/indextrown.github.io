<pre><code class="language-C++">// 1차원 Vector 사용법
vector&lt;int&gt; v;                      // 빈 벡터
vector&lt;int&gt; v2 = {1, 2, 3, 4, 5};   // 초기화와 동시에 원소 삽입
vector&lt;int&gt; v3(4, 3);               // 요소 3이 4개
vector&lt;int&gt; v4(v3)                  // v3를 복사
</code></pre>

<pre><code class="language-C++">// 2차원 Vector 사용법
// 빈 2차원 벡터 선언
vector&lt;vector&lt;int&gt;&gt; v1;      

// 특정 크기로 초기화된 2차원 벡터
int rows=3;
int cols=4;
vector&lt;vector&lt;int&gt;&gt; v2(rows, vector&lt;int&gt;(cols)); 

// 특정 값으로 초기화된 2차원 벡터
vector&lt;vector&lt;int&gt;&gt; v3(rows, vector&lt;int&gt;(cols, vals));

// 초기화 리스트를 사용한 2차원 벡터 초기화
vector&lt;vector&lt;int&gt;&gt; v4 = {
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9}
};
</code></pre>

<h3 id="벡터의-삽입과-삭제">벡터의 삽입과 삭제</h3>
<p>벡터 내부는 배열로 구성되어 있다  <br />
장점: 따라서 맨 뒤에서의 삽입 삭제는 효율적이다 O(1)  <br />
단점: 맨 앞에서 원소를 삽입 삭제 연산을 할때 비효율적이다 O(N)    <br />
맨 앞 원소를 효율적으로 삽입, 삭제할 수 있는 자료구조는 덱(Deque)이며 시간복잡도는 O(1)이다</p>

<h3 id="문문제-01-배열-정렬하기">문문제 01: 배열 정렬하기</h3>
<p>권장 시간 복잡도: O(NlogN)</p>

<p>[제약 조건]  <br />
arr의 길이는 2 이상 10^5 이하<br />
arr의 원소 값은 -100,000 이상 10,00000 이하</p>

<p>[문제 분석]  <br />
데이터 개수는 최대 10^5 이다. 즉 제한시간이 3초라면 O(N^2) 알고리즘 사용할 수 없다  <br />
만약 정수 벡터의 최대 길이가 10이라면 O(N^2) 알고리즘 사용해도 된다  <br />
즉, O(N^2)의 정렬 알고리즘으로 해결 불가능하다</p>

<p>[시간복잡도]  <br />
N은 arr 길이이므로 시간복잡도는 O(NlogN)이다</p>

