---
title: "[Data Structure] 1. 자료구조와 알고리즘"
tags:
- Data Structure
header:
  teaser:
typora-root-url: ../
---

<!-- <img src="{{ '이미지경로' | relative_url }}" alt="이미지" width="30%"> -->

## 자료구조(Data Structure)
<!-- 데이터를 효율적으로 저장하고 관리하는 방식을 말한다.  
대량의 데이터를 효율적으로 관리할 수 있는 데이터 구조를 의미한다.  
삽입, 수정, 삭제, 검색, 정렬, 병합, 순회 등 기본 연산을 지원하고   
데이터를 표현하고 조작하는 데 핵심적인 역할을 한다.  
자료구조는 크기 선형 자료구조와 비선형 자료구조로 나누어진다. 
선형 자료구조(데이터를 일렬로 나열하는 구조)
- 배열, 연결리스트, 스택, 큐

비션형 자료구조(데이터를 계층적 또는 복잡한 관계로 연결하는 구조)
- 트리, 그래프
-->
자료구조는 데이터를 효율적으로 저장하고 관리하는 방식입니다.  
대량의 데이터를 다룰 때 삽입, 삭제, 검색, 정렬, 순회 같은 기본 연산을 효율적으로 처리하도록 도와줍니다.  
자료구조는 크게 두 가지로 나누어집니다:
- 선형 자료구조: 배열, 연결 리스트, 스택, 큐처럼 데이터를 순서대로 나열하는 구조
- 비선형 자료구조: 트리, 그래프처럼 계층적이거나 복잡한 관계를 표현하는 구조

## 자료구조 특징
<!-- 1. 효율성
- 자료구조 사용의 목적은 효율적인 데이터관리 및 사용이다. 문제에 알맞은 자료구조를 사용하면 효율성이 증가한다.
2. 추상화
- 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념, 기능을 간추려 내는 것이다.
3. 재사용성
- 자료구조를 설계할 때 특정 프로그램에서만 동작하게 설계하지 않는다. 다양한 프로그램에서 동작할 수 있도록 범용성 있게 설계해 다른 프로젝트에서도 사용 가능하다. -->
1. 효율성  
문제에 적절한 자료구조를 사용하면 속도와 자원 효율이 향상됩니다.
2. 추상화  
복잡한 내부 구조는 숨기고 핵심적인 기능만을 표현함으로써 사용자는 사용법에 집중할 수 있습니다.
3. 재사용성  
범용적으로 설계된 자료구조는 여러 프로젝트에서 재사용이 가능하여 유지보수에도 유리합니다.

## 알고리즘(Algorithms)
<!-- 특정 문제를 해결하기 위한 단계적인 절차이다.  
컴퓨터 과학에서 알고리즘은 입력 데이터를 받아 원하는 결과를 출력하는 절차이며,   
효율적인 알고리즘은 실행 시간과 자원 사용을 최소화한다. -->
알고리즘은 문제를 해결하기 위한 단계적인 절차입니다.  
입력을 받아 원하는 출력을 만들어내는 과정을 의미하며,  
좋은 알고리즘은 빠르게 실행되면서도 적은 자원을 사용합니다.

## 자료형(Data Type)
<!-- 데이터의 종류를 의미한다.  
정수, 실수, 문자열 등이 기초적인 자료형이다.  
복잡한 자료형을 만들때는 연산자가 아닌 함수로 작성한다. -->
자료형은 데이터의 종류와 형식을 정의한 것입니다.  
예를 들어, 정수형(Int), 실수형(Float), 문자열(String) 등은 기초 자료형(Primitive Type)에 해당합니다.  
이 외에도 여러 데이터를 묶은 구조체, 클래스 같은 복합 자료형(Composite Type)도 존재합니다.  

## 추상 자료형(Abstruct Data Types, ADT)
<!-- 데이터의 논리적 구조와 연산을 정의하면서 구현 세부사항은 숨기는 개념이다.  
사용자는 기능에만 집중할 수 있고, 내부 구현은 몰라도 된다.  
장보 은닉과 모듈화를 통해 코드의 재사용성과 유지보수성을 높일 수 있다.  
스택, 큐, 리스트, 트리와 같은 자료형을 의미한디.  
실제적인 구현으로부터 군리되어 정의된 자료형으로 자료형을 추상적(수학적)으로 정의함을 의미한다. -->
추상 자료형은 데이터의 구조와 이를 처리하는 연산만 정의하고, 구체적인 구현은 숨기는 개념입니다.  
사용자는 내부 구현을 몰라도 되고, 기능(인터페이스)만 알면 됩니다.

대표적인 ADT 예시: 스택, 큐, 리스트, 트리
정보 은닉과 모듈화를 통해 재사용성과 유지보수성이 뛰어납니다.  
수학적으로 정의된 개념으로, 실제 구현(배열, 연결 리스트 등)과는 분리되어 있습니다.  
➡️ 즉, ADT는 '무엇을 할 수 있는가'에 집중하고, 구현 방식은 자유롭게 선택할 수 있는 설계 방식입니다.  

## 추상화(Abstraction)
<!-- 시스템의 간략화된 기술 또는 명세로서 시스템의 핵심적인 구조나 동작에만 집중하는 것이다.  
좋은 추상화는 사용자에게 중요한 정보는 강조되고 중요하지 않는 구현 세부 사항은 제거된다. -->
추상화는 불필요한 세부 사항을 숨기고, 핵심 기능에 집중하는 것입니다.  
복잡한 시스템을 단순하게 바라보게 해 주며, 유지보수성과 이해도를 높입니다.

## 프로그램
프로그램 = 자료구조 + 알고리즘  
소프트웨어는 결국 데이터를 어떻게 **구조화(자료구조)**하고,
그 데이터를 어떻게 처리할지(알고리즘) 결정하는 것이 핵심입니다.

<!-- ## 알고리즘 수행시간 측정방법
단순한 방법은 알고리즘을 프로그래밍 언어로 작성 및 실행시켜서 수행시간을 측정하는 방식이다.   
하지만 하드웨어나 프로그래밍 언어에 따라 수행 시간이 다르고 실험되지 않는 입력에 대해서는 수행시간을 주장할 수 없다.

## 알고리즘 복잡도 분석방법
알고리즘 분석에서 좋다는 의미는 크게 2가지의 측면을 고려할 수 있다.  
알고리즘의 수행시간과 기억공간의 양이다.  
알고리즘 수행시간 분석을 시간복잡도(time complexity)라고 하고   
알고리즘이 사용하는 기억 공간 분석을 공간복잡도(space complexity)라고 한다.  
알고리즘 복잡도는 시간복잡도를 사용한다. 이유는 알고리즘이 차지하는 공간보다는 수행 시간에 더 관심이 있기 때문이다.    -->

## 시간복잡도
<!-- 알고리즘의 절대적인 수행 시간을 나타내는 것이 아니라 알고리즘을 이루고 있는 연산들이 몇번이나 수행되는지를 숫자로 표시한다.  
연산에는 산술연산, 대입연산, 비교연산, 이동연산 등이 있다.   
즉 연산의 개수를 계산하여 알고리즘을 비교할 수 있다. -->
시간 복잡도는 알고리즘이 실행될 때 주요 연산이 얼마나 반복되는지를 정량적으로 나타낸 값입니다.  
연산에는 산술, 대입, 비교, 이동 연산 등이 포함되며,  
이를 통해 알고리즘 간 성능 비교가 가능합니다.  

## 순환(Recursion)
어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법입니다.  
주어진 문제를 더 작은 동일한 문제들로 분해하여 해결하는 분할 정복이 있습니다.  
순환 호출시에는 호출이 일어날 때마다 호출하는 함수의 상태를 기억해야 하므로 여분의 기억장소가 필요합니다.
순환은 이해하기 쉽지만 비효율적인 경우가 많습니다. 

## 활성 레코드(Activation Record)
프로그래밍 언어에서 하나의 함수가 자기 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일합니다.  
복귀주소가 시스템 스택에 저장되고 호출되는 함수를 위한 매개변수(parameter)와 지역변수를 스택으로부터 할당받는데 이러한 공간을 활성 레코드라고 합니다. 호출된 함수가 자기 자신이라면 자기 자신의 시작 위치로 점프하게 됩니다. 호출된 함수가 끝나게 되면 시스템 스택에서 복귀주소를 추출하여 호출한 함수로 되돌아갑니다.

## 꼬리 순환(Tail Recursion)
순환 호출이 끝에서 이루어지는 순환을 꼬리 순환이라고 하는데 이를 반복 알고리즘으로 쉽게 바꾸어 쓸 수 있습니다.
- 반복이 빠른 예시
  - 팩토리얼(순환, 반복 둘다 시간복잡도는 O(n)이지만 순환에서는 여분의 기억공간이 필요하고 함수를 호출하기 위해 함수의 매개변수들을 스택에 저장하는 사전 작업이 필요하다.)
- 순환이 빠른 예시
   - 거듭제곱(logn)


## Reference
- https://bnzn2426.tistory.com/115
- https://developer-haru.tistory.com/70
- https://wikidocs.net/224929
- https://velog.io/@ghldjfldj/자료구조-자료구조란